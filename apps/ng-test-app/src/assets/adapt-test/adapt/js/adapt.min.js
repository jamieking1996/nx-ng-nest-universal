define('core/js/models/lockingModel',[],function() {

	var set = Backbone.Model.prototype.set;

	_.extend(Backbone.Model.prototype, {

		set: function(attrName, attrVal, options) {
			var stopProcessing = !this.lockedAttributes || typeof attrName === "object" || typeof attrVal !== "boolean" || !this.isLocking(attrName);
			if (stopProcessing) return set.apply(this, arguments);
			
			options = options || {};

			var isSettingValueForSpecificPlugin = options && options.pluginName;
			if (!isSettingValueForSpecificPlugin) {
				console.error("Must supply a pluginName to change a locked attribute");
				options.pluginName = "compatibility";
			}

			var pluginName  = options.pluginName;
			if (this.defaults[attrName] !== undefined) {
				this.lockedAttributes[attrName] = !this.defaults[attrName];
			}
			var lockingValue = this.lockedAttributes[attrName];
			var isAttemptingToLock = (lockingValue === attrVal);

			if (isAttemptingToLock) {

				this.setLockState(attrName, true, {pluginName:pluginName, skipcheck: true});

				//console.log(options.pluginName, "locking", attrName, "on", this.get("_id"));
				return set.call(this, attrName, lockingValue);

			}

			this.setLockState(attrName, false, {pluginName:pluginName, skipcheck: true});

			var totalLockValue = this.getLockCount(attrName, {skipcheck: true});
			//console.log(options.pluginName, "attempting to unlock", attrName, "on", this.get("_id"), "lockValue", totalLockValue, this._lockedAttributesValues[attrName]);
			if (totalLockValue === 0) {
				//console.log(options.pluginName, "unlocking", attrName, "on", this.get("_id"));
				return set.call(this, attrName, !lockingValue);
			}

			return this;

		},

		setLocking: function(attrName, defaultLockValue) {
			if (this.isLocking(attrName)) return;
			if (!this.lockedAttributes) this.lockedAttributes = {};
			this.lockedAttributes[attrName] = defaultLockValue;
		},

		unsetLocking: function(attrName) {
			if (!this.isLocking(attrName)) return;
			if (!this.lockedAttributes) return;
			delete this.lockedAttributes[attrName];
			delete this._lockedAttributesValues[attrName];
			if (_.keys(this.lockedAttributes).length === 0) {
				delete this.lockedAttributes;
				delete this._lockedAttributesValues;
			}
		},

		isLocking: function(attrName) {
			var isCheckingGeneralLockingState = (attrName === undefined);
			var isUsingLockedAttributes = (this.lockedAttributes !== undefined);

			if (isCheckingGeneralLockingState) {
				return isUsingLockedAttributes;
			}

			if (!isUsingLockedAttributes) return false;

			var isAttributeALockingAttribute = this.lockedAttributes[attrName] !== undefined;
			if (!isAttributeALockingAttribute) return false;

			if (this._lockedAttributesValues === undefined) {
				this._lockedAttributesValues = {};
			}

			if (this._lockedAttributesValues[attrName] === undefined) {
				this._lockedAttributesValues[attrName] = {};	
			}

			return true;
		},

		isLocked: function(attrName, options) {
			var shouldSkipCheck = (options && options.skipcheck);
			if (!shouldSkipCheck) { 
				var stopProcessing =  !this.isLocking(attrName);
				if (stopProcessing) return;
			}

			return this.getLockCount(attrName) > 0;
		},

		getLockCount: function(attrName, options) {
			var shouldSkipCheck = (options && options.skipcheck);
			if (!shouldSkipCheck) { 
				var stopProcessing =  !this.isLocking(attrName);
				if (stopProcessing) return;
			}

			var isGettingValueForSpecificPlugin = options && options.pluginName;
			if (isGettingValueForSpecificPlugin) {

				return this._lockedAttributesValues[attrName][options.pluginName] ? 1 : 0;
			}

			var lockingAttributeValues = _.values(this._lockedAttributesValues[attrName]);
			var lockingAttributeValuesSum = _.reduce(lockingAttributeValues, function(sum, value){ return sum + (value ? 1 : 0); }, 0);
			
			return lockingAttributeValuesSum;
		},

		setLockState: function(attrName, value, options) {
			var shouldSkipCheck = (options && options.skipcheck);
			if (!shouldSkipCheck) { 
				var stopProcessing =  !this.isLocking(attrName);
				if (stopProcessing) return this;
			}

			var isSettingValueForSpecificPlugin = options && options.pluginName;
			if (!isSettingValueForSpecificPlugin) {
				console.error("Must supply a pluginName to set a locked attribute lock value");
				options.pluginName = "compatibility";
			}

			if (value) {
				this._lockedAttributesValues[attrName][options.pluginName] = value;
			} else {
				delete this._lockedAttributesValues[attrName][options.pluginName];
			}

			return this;

		}

	});

});

define('core/js/wait',[],function() {

     var Wait = Backbone.Controller.extend({

        initialize: function() {
            _.bindAll(this, "begin", "end");
        },

        _waitCount: 0,
        _callbackHandle: null,

        /**
         * Returns true if there are items in the waiting count.
         * 
         * @return {Boolean}
         */
        isWaiting: function() {
            return (this._waitCount !== 0);
        },

        /**
         * Add one item to the waiting count.
         * 
         * @return {Object}
         */
        begin: function() {

            if (!this.isWaiting()) {
                this.trigger("wait");
            }

            this._waitCount++;

            if (this._callbackHandle) {
                clearTimeout(this._callbackHandle);
                this._callbackHandle = null;
            }

            return this;

        },

        /**
         * Remove an item from the waiting count and trigger ready asynchronously if no more items are waiting.
         * 
         * @return {Object}
         */
        end: function() {

            if (!this.isWaiting()) {
                return this;
            }

            this._waitCount--;

            if (this.isWaiting()) {
                return this;
            }
            
            if (this._callbackHandle) {
                return this;
            }

            this._callbackHandle = setTimeout(function() {

                this._callbackHandle = null;
                this.trigger("ready");

            }.bind(this), 0);

            return this;

        },

        /**
         * Queue this function until all open waits have been ended.
         * 
         * @param  {Function} callback
         * @return {Object}
         */
        queue: function(callback) {

            this.begin();
            this.once("ready", callback);
            this.end();

            return this;

        },

        /**
         * Wait for this asynchonous function to execute before triggering ready event.
         * 
         * @param  {Function} callback   [ Function to execute whilst holding queued callback. Once complete run first argiument, done(). ]
         * @return {Object}
         */
        for: function(callback) {

            this.begin();
            _.defer(function() {
                callback(this.end);
            }.bind(this));

            return this;

        }

    });

    return Wait;

});
define('core/js/adapt',[
    'core/js/models/lockingModel',
    'core/js/wait'
], function(lockingModel, Wait) {

    var AdaptModel = Backbone.Model.extend({

        defaults: {
            _canScroll: true, //to stop scrollTo behaviour,
            _outstandingCompletionChecks: 0,
            _pluginWaitCount:0,
            _isStarted: false
        },

        lockedAttributes: {
            _canScroll: false
        },

        initialize: function () {
            this.setupWait();
        },

        //call when entering an asynchronous completion check
        checkingCompletion: function() {
            var outstandingChecks = this.get("_outstandingCompletionChecks");
            this.set("_outstandingCompletionChecks", ++outstandingChecks);
        },

        //call when exiting an asynchronous completion check
        checkedCompletion: function() {
            var outstandingChecks = this.get("_outstandingCompletionChecks");
            this.set("_outstandingCompletionChecks", --outstandingChecks);
        },

        //wait until there are no outstanding completion checks
        deferUntilCompletionChecked: function(callback) {

            if (this.get("_outstandingCompletionChecks") === 0) return callback();

            var checkIfAnyChecksOutstanding = function(model, outstandingChecks) {
                if (outstandingChecks !== 0) return;

                Adapt.off("change:_outstandingCompletionChecks", checkIfAnyChecksOutstanding);

                callback();
            };

            Adapt.on("change:_outstandingCompletionChecks", checkIfAnyChecksOutstanding);

        },

        setupWait: function() {

            this.wait = new Wait();

            // Setup legcay events and handlers
            var beginWait = function () {
                Adapt.log.warn("DEPRECATED - Use Adapt.wait.begin() as Adapt.trigger('plugin:beginWait') may be removed in the future");
                this.wait.begin();
            }.bind(this);

            var endWait = function() {
                Adapt.log.warn("DEPRECATED - Use Adapt.wait.end() as Adapt.trigger('plugin:endWait') may be removed in the future");
                this.wait.end();
            }.bind(this);

            var ready = function() {

                if (this.wait.isWaiting()) {
                    return;
                }

                var isEventListening = (this._events['plugins:ready']);
                if (!isEventListening) {
                    return;
                }

                Adapt.log.warn("DEPRECATED - Use Adapt.wait.queue(callback) as Adapt.on('plugins:ready', callback) may be removed in the future");
                this.trigger('plugins:ready');

            }.bind(this);

            this.listenTo(this.wait, "ready", ready);
            this.listenTo(this, {
                'plugin:beginWait': beginWait,
                'plugin:endWait': endWait
            });

        },

        isWaitingForPlugins:function() {
            Adapt.log.warn("DEPRECATED - Use Adapt.wait.isWaiting() as Adapt.isWaitingForPlugins() may be removed in the future");
            return this.wait.isWaiting();
        },

        checkPluginsReady:function() {
            Adapt.log.warn("DEPRECATED - Use Adapt.wait.isWaiting() as Adapt.checkPluginsReady() may be removed in the future");
            if (this.isWaitingForPlugins()) {
                return;
            }
            this.trigger('plugins:ready');
        }

    });

    var Adapt = new AdaptModel();

    Adapt.location = {};
    Adapt.componentStore = {};
    Adapt.mappedIds = {};

    Adapt.loadScript = window.__loadScript;

    Adapt.initialize = function() {

        //wait until no more completion checking
        Adapt.deferUntilCompletionChecked(function() {

            //start adapt in a full restored state
            Adapt.trigger('adapt:start');

            if (!Backbone.History.started) {
                Backbone.history.start();
            }

            Adapt.set("_isStarted", true);

            Adapt.trigger('adapt:initialize');

        });

    };

    Adapt.scrollTo = function(selector, settings) {
        // Get the current location - this is set in the router
        var location = (Adapt.location._contentType) ?
            Adapt.location._contentType : Adapt.location._currentLocation;
        // Trigger initial scrollTo event
        Adapt.trigger(location+':scrollTo', selector);
        //Setup duration variable passed upon arguments
        var settings = (settings || {});
        var disableScrollToAnimation = Adapt.config.has('_disableAnimation') ? Adapt.config.get('_disableAnimation') : false;
        if (disableScrollToAnimation) {
            settings.duration = 0;
        }
        else if (!settings.duration) {
            settings.duration = $.scrollTo.defaults.duration;
        }

        var offsetTop = -$(".navigation").outerHeight();
        // prevent scroll issue when component description aria-label coincident with top of component
        if (Adapt.config.get('_accessibility')._isActive &&
            $(selector).hasClass('component')) {
            offsetTop -= $(selector).find('.aria-label').height() || 0;
        }

        if (!settings.offset) settings.offset = { top: offsetTop, left: 0 };
        if (settings.offset.top === undefined) settings.offset.top = offsetTop;
        if (settings.offset.left === undefined) settings.offset.left = 0;

        if (settings.offset.left === 0) settings.axis = "y";

        if (Adapt.get("_canScroll") !== false) {
            // Trigger scrollTo plugin
            $.scrollTo(selector, settings);
        }

        // Trigger an event after animation
        // 300 milliseconds added to make sure queue has finished
        _.delay(function() {
            $(selector).a11y_focus();
            Adapt.trigger(location+':scrolledTo', selector);
        }, settings.duration+300);

    };

    Adapt.navigateToElement = function(selector, settings) {
        // Allows a selector to be passed in and Adapt will navigate to this element

        // Setup settings object
        var settings = (settings || {});

        // Removes . symbol from the selector to find the model
        var currentModelId = selector.replace(/\./g, '');
        var currentModel = Adapt.findById(currentModelId);
        // Get current page to check whether this is the current page
        var currentPage = (currentModel._siblings === 'contentObjects') ? currentModel : currentModel.findAncestor('contentObjects');

        // If current page - scrollTo element
        if (currentPage.get('_id') === Adapt.location._currentId) {
           return Adapt.scrollTo(selector, settings);
        }

        // If the element is on another page navigate and wait until pageView:ready is fired
        // Then scrollTo element
        Adapt.once('pageView:ready', function() {
            _.defer(function() {
                Adapt.scrollTo(selector, settings);
            });
        });

        var shouldReplaceRoute = settings.replace || false;

        Backbone.history.navigate('#/id/' + currentPage.get('_id'), {trigger: true, replace: shouldReplaceRoute});
    };

    Adapt.register = function(name, object) {
        // Used to register components
        // Store the component view
        if (Adapt.componentStore[name]) {
            throw Error('The component "' + name + '" already exists in your project');
        }
        
        if (object.view) {
            //use view+model object
            if(!object.view.template) object.view.template = name;
        } else {
            //use view object
            if(!object.template) object.template = name;
        }

        Adapt.componentStore[name] = object;

        return object;
    };

    Adapt.getViewClass = function(name) {
        var object = Adapt.componentStore[name];
        if (!object) {
            throw Error('The component "' + name + '" doesn\'t exist in your project');
        }
        return object.view || object;
    };

    // Used to map ids to collections
    Adapt.setupMapping = function() {
        // Clear any existing mappings.
        Adapt.mappedIds = {};

        // Setup course Id
        Adapt.mappedIds[Adapt.course.get('_id')] = "course";

        // Setup each collection
        var collections = ["contentObjects", "articles", "blocks", "components"];

        for (var i = 0, len = collections.length; i < len; i++) {
            var collection = collections[i];
            var models = Adapt[collection].models;
            for (var j = 0, lenj = models.length; j < lenj; j++) {
                var model = models[j];
                Adapt.mappedIds[model.get('_id')] = collection;

            }
        }

    };

    Adapt.mapById = function(id) {
        // Returns collection name that contains this models Id
        return Adapt.mappedIds[id];
    };

    Adapt.findById = function(id) {

        // Return a model
        // Checks if the Id passed in is the course Id
        if (id === Adapt.course.get('_id')) {
            return Adapt.course;
        }

        var collectionType = Adapt.mapById(id);

        if (!collectionType) {
            console.warn('Adapt.findById() unable to find collection type for id: ' + id);
            return;
        }

        return Adapt[collectionType]._byAdaptID[id][0];

    };

    // Relative strings describe the number and type of hops in the model hierarchy
    //
    // "@component +1" means to move one component forward from the current model
    // This function would return the following:
    // {
    //       type: "component",
    //       offset: 1
    // }
    // Trickle uses this function to determine where it should scrollTo after it unlocks
    Adapt.parseRelativeString = function(relativeString) {

        if (relativeString[0] === "@") {
            relativeString = relativeString.substr(1);
        }

        var type = relativeString.match(/(component|block|article|page|menu)/);
        if (!type) {
            Adapt.log.error("Adapt.parseRelativeString() could not match relative type", relativeString);
            return;
        }
        type = type[0];

        var offset = parseInt(relativeString.substr(type.length).trim()||0);
        if (isNaN(offset)) {
            Adapt.log.error("Adapt.parseRelativeString() could not parse relative offset", relativeString);
            return;
        }

        return {
            type: type,
            offset: offset
        };

    };

    Adapt.remove = function() {
        Adapt.trigger('preRemove');
        Adapt.trigger('remove');
        _.defer(function() {
            Adapt.trigger('postRemove');
        });
    };

    return Adapt;

});

define('core/js/adaptCollection',[
    'core/js/adapt'
], function(Adapt) {

    var AdaptCollection = Backbone.Collection.extend({
        initialize : function(models, options){
            this.url = options.url;

            this.once('reset', this.loadedData, this);
            if (this.url) {
                this.fetch({
                    reset:true,
                    error: _.bind(function(model, xhr, options) {
                        console.error("ERROR: unable to load file " + this.url);
                    }, this)
                });
            }
        },

        loadedData: function() {
            Adapt.trigger('adaptCollection:dataLoaded');
        }

    });

    return AdaptCollection;

});

define('core/js/startController',[
    'core/js/adapt'
], function(Adapt) {
    
    var StartController = Backbone.Controller.extend({

        model: null,

        initialize: function() {
            this.model = new Backbone.Model(Adapt.course.get("_start"));
        },

        setStartLocation: function() {
            if (!this.isEnabled()) return;
            window.history.replaceState('', '', this.getStartHash());
        },

        getStartHash: function(alwaysForce) {
            var startId = this.getStartId();

            var hasStartId = (startId)
                ? true
                : false;

            var isRouteSpecified = (_.indexOf(window.location.href,"#") > -1);
            var shouldForceStartId = alwaysForce || this.model.get("_force");
            var shouldNavigateToStartId = hasStartId && (!isRouteSpecified || shouldForceStartId);

            var startHash = "#/";
            if (shouldNavigateToStartId) {
                if (startId !== Adapt.course.get("_id")) {
                    startHash = "#/id/"+startId;
                }
            } else {
                //go to specified route or course main menu
                var hasLocationHash = (window.location.hash)
                    ? true
                    : false;

                startHash = hasLocationHash ? window.location.hash : startHash;
            }

            return startHash;
        },

        isEnabled: function() {
            if (!this.model || !this.model.get("_isEnabled")) return false;
            return true;
        },

        getStartId: function() {
            var startId = this.model.get("_id");
            var startIds = this.model.get("_startIds");
            var $html = $("html");
            
            var hasStartIdsConfiguration = (startIds && startIds.length > 0);
            if (hasStartIdsConfiguration) {
                for (var i = 0, l =  startIds.length; i < l; i++) {
                    var item = startIds[i];
                    var className =  item._className;
                    var skipIfComplete = item._skipIfComplete;
                    
                    var model = Adapt.findById(item._id);
                    
                    if (!model) {
                        console.log("startController: cannot find id", item._id);
                        continue;
                    }
                    
                    if (skipIfComplete) {
                        if (model.get("_isComplete")) continue;
                    }

                    if (!className || $html.is(className) || $html.hasClass(className)) {
                        startId = item._id;
                        break;
                    }
                }
            }

            return startId;
        }

    });

    Adapt.once("adapt:start", function() {
        var startController = new StartController();
        startController.setStartLocation();
    });

    return StartController;

});

define('core/js/enums/logLevelEnum',[],function() {

    // Used to determine if log call should be printed based on log level
    var LOG_LEVEL = ENUM([
        "DEBUG",
        "INFO",
        "WARN",
        "ERROR",
        "FATAL"
    ]);

    return LOG_LEVEL;

});
define('core/js/logging',[
    'core/js/adapt',
    'core/js/enums/logLevelEnum'
], function(Adapt, LOG_LEVEL) {

    var Logging = Backbone.Controller.extend({

        _config: {
            _isEnabled: true,
            _level: LOG_LEVEL.INFO.asLowerCase, // Default log level
            _console: true // Log to console
        },      
        
        initialize: function() {

            Adapt.once('configModel:dataLoaded', this.onLoadConfigData.bind(this));

        },
        
        onLoadConfigData: function() {

            this.loadConfig();

            this.debug('Logging config loaded');

            this.trigger('log:ready');

        },

        loadConfig: function() {

            if (Adapt.config.has('_logging')) {
                this._config = Adapt.config.get('_logging');
            }

            this.checkQueryStringOverride();

        },

        checkQueryStringOverride: function() {

            // Override default log level with level present in query string
            var matches = window.location.search.match(/[?&]loglevel=([a-z]*)/i);
            if (!matches || matches.length < 2) return;

            var override = LOG_LEVEL(matches[1].toUpperCase());
            if (!override) return;

            this._config._level = override.asLowerCase;
            this.debug('Loglevel override in query string:', this._config._level);
            
        },
        
        debug: function() {            
            this._log(LOG_LEVEL.DEBUG, Array.prototype.slice.call(arguments));
        },
        
        info: function() {
            this._log(LOG_LEVEL.INFO, Array.prototype.slice.call(arguments));
        },
        
        warn: function() {
            this._log(LOG_LEVEL.WARN, Array.prototype.slice.call(arguments));
        },
        
        error: function() {
            this._log(LOG_LEVEL.ERROR, Array.prototype.slice.call(arguments));
        },
        
        fatal: function() {
            this._log(LOG_LEVEL.FATAL, Array.prototype.slice.call(arguments));
        },
        
        _log: function(level, data) {

            var isEnabled = (this._config._isEnabled);
            if (!isEnabled) return;

            var configLevel = LOG_LEVEL(this._config._level.toUpperCase());

            var isLogLevelAllowed = (level >= configLevel);
            if (!isLogLevelAllowed) return;

            this._logToConsole(level, data);

            // Allow error reporting plugins to hook and report to logging systems
            this.trigger('log', level, data);
            this.trigger('log:' + level.asLowerCase, level, data);

        },

        _logToConsole: function(level, data) {

            var shouldLogToConsole = (this._config._console);
            if (!shouldLogToConsole) return;

            var log = [level.asUpperCase + ':'];
            data && log.push.apply(log, data);

            // is there a matching console method we can use e.g. console.error()?
            if(console[level.asLowerCase]) {
                console[level.asLowerCase].apply(console, log);
            } else {
                console.log.apply(console, log);
            }
        }

    });

    Adapt.log = new Logging();
});

define('core/js/models/buildModel',[
    'core/js/adapt',
    'core/js/logging'
], function (Adapt) {

    var BuildModel = Backbone.Model.extend({

        defaults: {
            jsonext: 'json'
        },

        initialize: function(attrs, options) {
            this.url = options.url;
            // Fetch data & if successful trigger event to enable plugins to stop course files loading
            // Then check if course files can load
            // 'configModel:loadCourseData' event starts the core content collections and models being fetched
            this.fetch({
                success: _.bind(function() {
                    this.isLoaded = true;
                    Adapt.trigger('buildModel:dataLoaded');
                }, this),
                error: function() {
                    console.log('Unable to load adapt/js/build.js');
                    Adapt.trigger('buildModel:dataLoaded');
                }
            });
        }

    });

    return BuildModel;

});
define('core/js/models/adaptModel',[
    'core/js/adapt',
    'core/js/logging'
], function (Adapt) {

    var AdaptModel = Backbone.Model.extend({

        defaults: {
            _canShowFeedback: true,
            _classes: "",
            _canReset: false,
            _isComplete: false,
            _isInteractionComplete: false,
            _requireCompletionOf: -1,
            _isEnabled: true,
            _isResetOnRevisit: false,
            _isAvailable: true,
            _isOptional: false,
            _isReady: false,
            _isVisible: true,
            _isLocked: false,
            _isHidden: false
        },

        trackable: [
            '_id',
            '_isComplete',
            '_isInteractionComplete'
        ],

        initialize: function () {
            // Wait until data is loaded before setting up model
            this.listenToOnce(Adapt, 'app:dataLoaded', this.setupModel);

        },

        setupModel: function() {
            if (this.get('_type') === 'page') {
                this._children = 'articles';
            }
            if (this._siblings === 'contentObjects' && this.get('_parentId') !== Adapt.course.get('_id')) {
                this._parent = 'contentObjects';
            }
            if (this._children) {
                this.setupChildListeners();
            }

            this.init();

            _.defer(function() {
                if (this._children) {
                    this.checkCompletionStatus();

                    this.checkInteractionCompletionStatus();

                    this.checkLocking();
                }

                this.setupTrackables();

            }.bind(this));

        },

        setupTrackables: function() {

            // Limit state trigger calls and make state change callbacks batched-asynchronous
            var originalTrackableStateFunction = this.triggerTrackableState;
            this.triggerTrackableState = _.compose(
                function() {

                    // Flag that the function is awaiting trigger
                    this.triggerTrackableState.isQueued = true;

                }.bind(this),
                _.debounce(function() {

                    // Trigger original function
                    originalTrackableStateFunction.apply(this);

                    // Unset waiting flag
                    this.triggerTrackableState.isQueued = false;

                }.bind(this), 17)
            );

            // Listen to model changes, trigger trackable state change when appropriate
            this.listenTo(this, "change", function(model, value) {

                // Skip if trigger queued or adapt hasn't started yet
                if (this.triggerTrackableState.isQueued || !Adapt.attributes._isStarted) {
                    return;
                }

                // Check that property is trackable
                var trackablePropertyNames = _.result(this, 'trackable', []);
                var changedPropertyNames = _.keys(model.changed);
                var isTrackable = _.find(changedPropertyNames, function(item, index) {
                    return _.contains(trackablePropertyNames, item);
                }.bind(this));

                if (isTrackable) {
                    // Trigger trackable state change
                    this.triggerTrackableState();
                }
            });
        },

        setupChildListeners: function() {
            var children = this.getChildren();
            if (!children.length) {
                return;
            }

            this.listenTo(children, {
                "change:_isReady": this.checkReadyStatus,
                "change:_isComplete": this.onIsComplete,
                "change:_isInteractionComplete": this.checkInteractionCompletionStatus
            });
        },

        init: function() {},

        getTrackableState: function() {

            var trackable = this.resultExtend("trackable", []);
            var json = this.toJSON();

            var args = trackable;
            args.unshift(json);

            return _.pick.apply(_, args);

        },

        setTrackableState: function(state) {

            var trackable = this.resultExtend("trackable", []);

            var args = trackable;
            args.unshift(state);

            state = _.pick.apply(_, args);

            this.set(state);

            return this;

        },

        triggerTrackableState: function() {

            Adapt.trigger("state:change", this, this.getTrackableState());

        },

        reset: function(type, force) {
            if (!this.get("_canReset") && !force) return;

            type = type || true;

            switch (type) {
            case "hard": case true:
                this.set({
                    _isEnabled: true,
                    _isComplete: false,
                    _isInteractionComplete: false
                });
                break;
            case "soft":
                this.set({
                    _isEnabled: true,
                    _isInteractionComplete: false
                });
                break;
            }
        },

        checkReadyStatus: function () {
            // Filter children based upon whether they are available
            // Check if any return _isReady:false
            // If not - set this model to _isReady: true
            var children = this.getAvailableChildModels();
            if (_.find(children, function(child) { return child.get('_isReady') === false; })) {
                return;
            }

            this.set('_isReady', true);
        },

        setCompletionStatus: function() {
            if (!this.get('_isVisible')) return;

            this.set({
                _isComplete: true,
                _isInteractionComplete: true
            });
        },

        checkCompletionStatus: function () {
            //defer to allow other change:_isComplete handlers to fire before cascading to parent
            Adapt.checkingCompletion();
            _.defer(this.checkCompletionStatusFor.bind(this), '_isComplete');
        },

        checkInteractionCompletionStatus: function () {
            //defer to allow other change:_isInteractionComplete handlers to fire before cascading to parent
            Adapt.checkingCompletion();
            _.defer(this.checkCompletionStatusFor.bind(this), '_isInteractionComplete');
        },

        /**
         * Function for checking whether the supplied completion attribute should be set to true or false.
         * It iterates over our immediate children, checking the same completion attribute on any mandatory child
         * to see if enough/all of them them have been completed. If enough/all have, we set our attribute to true;
         * if not, we set it to false.
         * @param {string} [completionAttribute] Either "_isComplete" or "_isInteractionComplete". Defaults to "_isComplete" if not supplied.
         */
        checkCompletionStatusFor: function(completionAttribute) {
            if (!completionAttribute) completionAttribute = "_isComplete";

            var completed = false;
            var children = this.getAvailableChildModels();
            var requireCompletionOf = this.get("_requireCompletionOf");

            if (requireCompletionOf === -1) { // a value of -1 indicates that ALL mandatory children must be completed
                completed = (_.find(children, function(child) {
                    return !child.get(completionAttribute) && !child.get('_isOptional');
                }) === undefined);
            } else {
                completed = (_.filter(children, function(child) {
                    return child.get(completionAttribute) && !child.get('_isOptional');
                }).length >= requireCompletionOf);
            }

            this.set(completionAttribute, completed);

            Adapt.checkedCompletion();
        },

        /**
         * Searches the model's ancestors to find the first instance of the specified ancestor type
         * @param {string} [ancestorType] Valid values are 'course', 'pages', 'contentObjects', 'articles' or 'blocks'.
         * If left blank, the immediate ancestor (if there is one) is returned
         * @return {object} Reference to the model of the first ancestor of the specified type that's found - or `undefined` if none found
         */
        findAncestor: function (ancestorType) {
            var parent = this.getParent();
            if (!parent) return;

            if (ancestorType === 'pages') {
                ancestorType = 'contentObjects';
            }

            if (!ancestorType || this._parent === ancestorType) {
                return parent;
            }

            return parent.findAncestor(ancestorType);
        },

        /**
         * Returns all the descendant models of a specific type
         * @param {string} descendants Valid values are 'contentObjects', 'pages', 'menus', 'articles', 'blocks' or 'components'
         * @param {object} options an object that defines the search type and the properties/values to search on. Currently only the `where` search type (equivalent to `Backbone.Collection.where()`) is supported.
         * @param {object} options.where
         * @return {array}
         * @example
         * //find all available, non-optional components
         * this.findDescendantModels('components', { where: { _isAvailable: true, _isOptional: false }});
         */
        findDescendantModels: function(descendants, options) {

            var types = [
                descendants.slice(0, -1)
            ];
            if (descendants === 'contentObjects') {
                types.push.apply(types, ['page', 'menu']);
            }

            var allDescendantsModels = this.getAllDescendantModels();
            var returnedDescendants = allDescendantsModels.filter(function(model) {
                return _.contains(types, model.get("_type"));
            });

            if (!options) {
                return returnedDescendants;
            }

            if (options.where) {
                return returnedDescendants.filter(function(descendant) {
                    for (var property in options.where) {
                        var value = options.where[property];
                        if (descendant.get(property) !== value) {
                            return false;
                        }
                    }
                    return true;
                });
            }
        },

        /**
         * Fetches the sub structure of a model as a flattened array
         *
         * Such that the tree:
         *  { a1: { b1: [ c1, c2 ], b2: [ c3, c4 ] }, a2: { b3: [ c5, c6 ] } }
         *
         * will become the array (parent first = false):
         *  [ c1, c2, b1, c3, c4, b2, a1, c5, c6, b3, a2 ]
         *
         * or (parent first = true):
         *  [ a1, b1, c1, c2, b2, c3, c4, a2, b3, c5, c6 ]
         *
         * This is useful when sequential operations are performed on the menu/page/article/block/component hierarchy.
         * @param {boolean} [isParentFirst]
         * @return {array}
         */
        getAllDescendantModels: function(isParentFirst) {

            var descendants = [];

            if (this.get("_type") === "component") {
                descendants.push(this);
                return descendants;
            }

            var children = this.getChildren();

            for (var i = 0, l = children.models.length; i < l; i++) {

                var child = children.models[i];
                if (child.get("_type") === "component") {

                    descendants.push(child);
                    continue;

                }

                var subDescendants = child.getAllDescendantModels(isParentFirst);
                if (isParentFirst === true) {
                    descendants.push(child);
                }

                descendants = descendants.concat(subDescendants);

                if (isParentFirst !== true) {
                    descendants.push(child);
                }

            }

            return descendants;

        },

        /**
         * @deprecated Since v2.2.0 - please use findDescendantModels instead
         */
        findDescendants: function (descendants) {
            Adapt.log.warn("DEPRECATED - Use findDescendantModels() as findDescendants() may be removed in the future");

            // first check if descendant is child and return child
            if (this._children === descendants) {
                return this.getChildren();
            }

            var allDescendants = [];
            var flattenedDescendants;
            var children = this.getChildren();
            var returnedDescendants;

            function searchChildren(children) {
                var models = children.models;
                for (var i = 0, len = models.length; i < len; i++) {
                    var model = models[i];
                    var childrensModels = model.getChildren().models;
                    allDescendants.push(childrensModels);
                    flattenedDescendants = _.flatten(allDescendants);
                }

                returnedDescendants = new Backbone.Collection(flattenedDescendants);

                if (children.models.length === 0 || children.models[0]._children === descendants) {
                    return;
                } else {
                    allDescendants = [];
                    searchChildren(returnedDescendants);
                }
            }

            searchChildren(children);

            // returns a collection of children
            return returnedDescendants;
        },

        /**
         * Returns a relative model from the Adapt hierarchy
         *
         * Such that in the tree:
         *  { a1: { b1: [ c1, c2 ], b2: [ c3, c4 ] }, a2: { b3: [ c5, c6 ] } }
         *
         *  c1.findRelativeModel("@block +1") = b2;
         *  c1.findRelativeModel("@component +4") = c5;
         *
         * @see Adapt.parseRelativeString for a description of relativeStrings
         * @param {string} relativeString
         * @param {object} options Search configuration settings
         * @param {boolean} options.limitParentId
         * @param {function} options.filter
         * @param {boolean} options.loop
         * @return {array}
         */
        findRelativeModel: function(relativeString, options) {

            var types = [ "menu", "page", "article", "block", "component" ];

            options = options || {};

            var modelId = this.get("_id");
            var modelType = this.get("_type");

            // return a model relative to the specified one if opinionated
            var rootModel = Adapt.course;
            if (options.limitParentId) {
                rootModel = Adapt.findById(options.limitParentId);
            }

            var relativeDescriptor = Adapt.parseRelativeString(relativeString);

            var findAncestorType = (_.indexOf(types, modelType) > _.indexOf(types, relativeDescriptor.type));
            var findSiblingType = (modelType === relativeDescriptor.type);

            var searchBackwards = (relativeDescriptor.offset < 0);
            var moveBy = Math.abs(relativeDescriptor.offset);
            var movementCount = 0;

            var findDescendantType = (!findSiblingType && !findAncestorType);

            var pageDescendants;
            if (searchBackwards) {
                // parents first [p1,a1,b1,c1,c2,a2,b2,c3,c4,p2,a3,b3,c6,c7,a4,b4,c8,c9]
                pageDescendants = rootModel.getAllDescendantModels(true);

                // reverse so that we don't need a forward and a backward iterating loop
                // reversed [c9,c8,b4,a4,c7,c6,b3,a3,p2,c4,c3,b2,a2,c2,c1,b1,a1,p1]
                pageDescendants.reverse();

                if (findDescendantType) {
                    // move by one less as ordering allows
                    moveBy-=1;
                }

            } else if (findDescendantType) {
                // parents first [p1,a1,b1,c1,c2,a2,b2,c3,c4,p2,a3,b3,c6,c7,a4,b4,c8,c9]
                pageDescendants = rootModel.getAllDescendantModels(true);
            } else if (findSiblingType || findAncestorType) {
                // children first [c1,c2,b1,a1,c3,c4,b2,a2,p1,c6,c7,b3,a3,c8,c9,b4,a4,p2]
                pageDescendants = rootModel.getAllDescendantModels(false);
            }

            // filter if opinionated
            if (typeof options.filter === "function") {
                pageDescendants = _.filter(pageDescendants, options.filter);
            }

            // find current index in array
            var modelIndex = _.findIndex(pageDescendants, function(pageDescendant) {
                if (pageDescendant.get("_id") === modelId) {
                    return true;
                }
                return false;
            });

            if (options.loop) {

                // normalize offset position to allow for overflow looping
                var typeCounts = {};
                pageDescendants.forEach(function(model) {
                    var type = model.get("_type");
                    typeCounts[type] = typeCounts[type] || 0;
                    typeCounts[type]++;
                });
                moveBy = moveBy % typeCounts[relativeDescriptor.type];

                // double up entries to allow for overflow looping
                pageDescendants = pageDescendants.concat(pageDescendants.slice(0));

            }

            for (var i = modelIndex, l = pageDescendants.length; i < l; i++) {
                var descendant = pageDescendants[i];
                if (descendant.get("_type") === relativeDescriptor.type) {
                    if (movementCount === moveBy) {
                        return Adapt.findById(descendant.get("_id"));
                    }
                    movementCount++;
                }
            }

            return undefined;
        },

        getChildren: function () {
            if (this.get("_children")) return this.get("_children");

            var childrenCollection;

            if (!this._children) {
                childrenCollection = new Backbone.Collection();
            } else {
                var children = Adapt[this._children].where({_parentId: this.get("_id")});
                childrenCollection = new Backbone.Collection(children);
            }

            if (this.get('_type') == 'block' &&
                childrenCollection.length == 2 &&
                childrenCollection.models[0].get('_layout') !== 'left' &&
                this.get('_sortComponents') !== false) {
                // Components may have a 'left' or 'right' _layout,
                // so ensure they appear in the correct order
                // Re-order component models to correct it
                childrenCollection.comparator = '_layout';
                childrenCollection.sort();
            }

            this.set("_children", childrenCollection);

            return childrenCollection;
        },

        getAvailableChildModels: function() {
            return this.getChildren().where({
                _isAvailable: true
            });
        },

        /**
         * @deprecated since v2.2.0 please use getAvailableChildModels instead
         */
        getAvailableChildren: function() {
            Adapt.log.warn("DEPRECATED - Use getAvailableChildModels() as getAvailableChildren() may be removed in the future");

            return new Backbone.Collection(this.getChildren().where({
                _isAvailable: true
            }));
        },

        getParent: function () {
            if (this.get("_parent")) return this.get("_parent");
            if (this._parent === "course") {
                return Adapt.course;
            }
            var parent = Adapt.findById(this.get("_parentId"));
            this.set("_parent", parent);

            // returns a parent model
            return parent;
        },

        getAncestorModels: function(shouldIncludeChild) {
            var parents = [];
            var context = this;

            if (shouldIncludeChild) parents.push(context);

            while (context.has("_parentId")) {
                context = context.getParent();
                parents.push(context);
            }

            return parents.length ? parents : null;
        },

        /**
         * @deprecated since v2.2.0 please use getAncestorModels instead
         */
        getParents: function(shouldIncludeChild) {
            Adapt.log.warn("DEPRECATED - Use getAncestorModels() as getParents() may be removed in the future");

            var parents = [];
            var context = this;

            if (shouldIncludeChild) parents.push(context);

            while (context.has("_parentId")) {
                context = context.getParent();
                parents.push(context);
            }

            return parents.length ? new Backbone.Collection(parents) : null;
        },

        getSiblings: function (passSiblingsAndIncludeSelf) {
            var siblings;
            if (!passSiblingsAndIncludeSelf) {
                // returns a collection of siblings excluding self
                if (this._hasSiblingsAndSelf === false) {
                    return this.get("_siblings");
                }
                siblings = _.reject(Adapt[this._siblings].where({
                    _parentId: this.get('_parentId')
                }), function (model) {
                    return model.get('_id') == this.get('_id');
                }.bind(this));

                this._hasSiblingsAndSelf = false;

            } else {
                // returns a collection of siblings including self
                if (this._hasSiblingsAndSelf) {
                    return this.get("_siblings");
                }

                siblings = Adapt[this._siblings].where({
                    _parentId: this.get("_parentId")
                });
                this._hasSiblingsAndSelf = true;
            }

            var siblingsCollection = new Backbone.Collection(siblings);
            this.set("_siblings", siblingsCollection);
            return siblingsCollection;
        },

        setOnChildren: function (key, value, options) {

            var args = arguments;

            this.set.apply(this, args);

            if (!this._children) return;

            var children = this.getChildren();
            var models = children.models;
            for (var i = 0, len = models.length; i < len; i++) {
                var child = models[i];
                child.setOnChildren.apply(child, args);
            }

        },

        /**
         * @deprecated since v3.2.3 - please use `model.set('_isOptional', value)` instead
         */
        setOptional: function(value) {
            this.set({_isOptional: value});
        },

        checkLocking: function() {
            var lockType = this.get("_lockType");

            if (!lockType) return;

            switch (lockType) {
                case "sequential":
                    this.setSequentialLocking();
                    break;
                case "unlockFirst":
                    this.setUnlockFirstLocking();
                    break;
                case "lockLast":
                    this.setLockLastLocking();
                    break;
                case "custom":
                    this.setCustomLocking();
                    break;
                default:
                    console.warn("AdaptModel.checkLocking: unknown _lockType \"" +
                        lockType + "\" found on " + this.get("_id"));
            }
        },

        setSequentialLocking: function() {
            var children = this.getAvailableChildModels();

            for (var i = 1, j = children.length; i < j; i++) {
                children[i].set("_isLocked", !children[i - 1].get("_isComplete"));
            }
        },

        setUnlockFirstLocking: function() {
            var children = this.getAvailableChildModels();
            var isFirstChildComplete = children[0].get("_isComplete");

            for (var i = 1, j = children.length; i < j; i++) {
                children[i].set("_isLocked", !isFirstChildComplete);
            }
        },

        setLockLastLocking: function() {
            var children = this.getAvailableChildModels();
            var lastIndex = children.length - 1;

            for (var i = lastIndex - 1; i >= 0; i--) {
                if (!children[i].get("_isComplete")) {
                    return children[lastIndex].set("_isLocked", true);
                }
            }

            children[lastIndex].set("_isLocked", false);
        },

        setCustomLocking: function() {
            var children = this.getAvailableChildModels();

            for (var i = 0, j = children.length; i < j; i++) {
                var child = children[i];

                child.set("_isLocked", this.shouldLock(child));
            }
        },

        shouldLock: function(child) {
            var lockedBy = child.get("_lockedBy");

            if (!lockedBy) return false;

            for (var i = lockedBy.length - 1; i >= 0; i--) {
                var id = lockedBy[i];

                try {
                    var model = Adapt.findById(id);

                    if (!model.get("_isAvailable")) continue;
                    if (!model.get("_isComplete")) return true;
                }
                catch (e) {
                    console.warn("AdaptModel.shouldLock: unknown _lockedBy ID \"" + id +
                        "\" found on " + child.get("_id"));
                }
            }

            return false;
        },

        onIsComplete: function() {
            this.checkCompletionStatus();

            this.checkLocking();
        }

    });

    return AdaptModel;

});

define('core/js/models/articleModel',[
    'core/js/models/adaptModel'
], function (AdaptModel) {

    var ArticleModel = AdaptModel.extend({
        _parent:'contentObjects',
    	_siblings:'articles',
        _children: 'blocks'
    });

    return ArticleModel;

});

define('core/js/models/blockModel',[
    'core/js/models/adaptModel'
], function (AdaptModel) {

    var BlockModel = AdaptModel.extend({
        _parent:'articles',
    	_siblings:'blocks',
        _children: 'components',

        defaults: function() {
            return _.extend({
                _sortComponents: true
            }, AdaptModel.prototype.defaults);
        }
    });

    return BlockModel;

});

define('core/js/models/configModel',[
    'core/js/adapt'
], function (Adapt) {

    var ConfigModel = Backbone.Model.extend({

        defaults: {
            screenSize: {
                small: 520,
                medium: 760,
                large: 1024
            },
            _forceRouteLocking: false,
            _canLoadData: true,
            _disableAnimation: false
        },

        initialize: function(attrs, options) {
            this.url = options.url;
            // Fetch data & if successful trigger event to enable plugins to stop course files loading
            // Then check if course files can load
            // 'configModel:loadCourseData' event starts the core content collections and models being fetched
            this.fetch({
                success: function() {
                    Adapt.trigger('offlineStorage:prepare');

                    Adapt.wait.queue(function() {

                        Adapt.trigger('configModel:dataLoaded');

                        if (this.get('_canLoadData')) {
                            Adapt.trigger('configModel:loadCourseData');
                        }

                        if (this.get('_defaultDirection') === 'rtl'){
                            // We're going to use rtl style
                            $('html').addClass('dir-rtl');
                        }

                        // Check if animations should be disabled
                        var disableAnimationArray = this.get('_disableAnimationFor');
                        if (disableAnimationArray && disableAnimationArray.length > 0) {
                            for (var i = 0; i < disableAnimationArray.length; i++) {
                                if ($("html").is(disableAnimationArray[i])) {
                                    this.set('_disableAnimation', true);
                                    console.log('Animation disabled.');
                                }
                            }
                        }
                    }.bind(this));
                }.bind(this),
                error: function() {
                    console.log('Unable to load course/config.json');
                }
            });
        },

        loadData: function() {

        }

    });

   return ConfigModel;

});

define('core/js/models/contentObjectModel',[
    'core/js/models/adaptModel'
], function (AdaptModel) {

    var ContentObjectModel = AdaptModel.extend({
    	_parent:'course',
    	_siblings:'contentObjects',
        _children: 'contentObjects'
    });

    return ContentObjectModel;
});

define('core/js/models/componentModel',[
    'core/js/models/adaptModel'
], function (AdaptModel) {

    var ComponentModel = AdaptModel.extend({
        _parent:'blocks',
        _siblings:'components',

        trackable: AdaptModel.resultExtend("trackable", [
            '_userAnswer'
        ])

    });

    return ComponentModel;

});

define('core/js/models/courseModel',[
    'core/js/adapt',
    'core/js/models/adaptModel'
], function (Adapt, AdaptModel) {

    var CourseModel = AdaptModel.extend({

        initialize: function(attrs, options) {
            AdaptModel.prototype.initialize.apply(this, arguments);
            Adapt.trigger('courseModel:dataLoading');

            this.url = options.url;

            this.on('sync', this.loadedData, this);
            if (this.url) {
                this.fetch({
                    error: _.bind(function(model, xhr, options) {
                        console.error("ERROR: unable to load file " + this.url);
                    }, this)
                });
            }
        },

        loadedData: function() {
            Adapt.trigger('courseModel:dataLoaded');
        },

        _children: "contentObjects"

    });

    return CourseModel;

});

define('core/js/enums/buttonStateEnum',[],function() {

    var BUTTON_STATE = ENUM([
        'SUBMIT',
        'CORRECT',
        'INCORRECT',
        'SHOW_CORRECT_ANSWER',
        'HIDE_CORRECT_ANSWER',
        'SHOW_FEEDBACK',
        'RESET'
    ]);

    return BUTTON_STATE;

});
define('core/js/models/questionModel',[
    'core/js/adapt',
    'core/js/models/componentModel',
    'core/js/enums/buttonStateEnum'
], function(Adapt, ComponentModel, BUTTON_STATE) {

    var QuestionModel = ComponentModel.extend({

        //////
        // Setup question types
        ////

        // Used to set model defaults
        defaults: function() {
            // Extend from the ComponentModel defaults
            return ComponentModel.resultExtend("defaults", {
                _isQuestionType: true,
                _shouldDisplayAttempts: false,
                _canShowModelAnswer: true,
                _canShowFeedback: true,
                _canShowMarking: true,
                _isSubmitted: false,
                _questionWeight: Adapt.config.get("_questionWeight"),
            });
        },

        // Extend from the ComponentModel trackable
        trackable: ComponentModel.resultExtend("trackable", [
            '_isSubmitted',
            '_score',
            '_isCorrect',
            '_attemptsLeft'
        ]),

        init: function() {
            this.setupDefaultSettings();
            this.listenToOnce(Adapt, "adapt:initialize", this.onAdaptInitialize);
        },

        // Calls default methods to setup on questions
        setupDefaultSettings: function() {
            // Not sure this is needed anymore, keeping to maintain API
            this.setupWeightSettings();
            this.setupButtonSettings();
        },

        // Used to setup either global or local button text
        setupButtonSettings: function() {
            var globalButtons = Adapt.course.get("_buttons");

            // Check if  '_buttons' attribute exists and if not use the globally defined buttons.
            if (!this.has("_buttons")) {
                this.set("_buttons", globalButtons);
            } else {
                // Check all the components buttons.
                // If they are empty use the global defaults.
                var componentButtons = this.get("_buttons");

                for (var key in componentButtons) {
                    if (typeof componentButtons[key] === 'object') {
                        // Button text.
                        if (!componentButtons[key].buttonText && globalButtons[key].buttonText) {
                            componentButtons[key].buttonText = globalButtons[key].buttonText;
                        }

                        // ARIA labels.
                        if (!componentButtons[key].ariaLabel && globalButtons[key].ariaLabel) {
                            componentButtons[key].ariaLabel = globalButtons[key].ariaLabel;
                        }
                    }

                    if (!componentButtons[key] && globalButtons[key]) {
                        componentButtons[key] = globalButtons[key];
                    }
                }
            }
        },

        // Used to setup either global or local question weight/score
        setupWeightSettings: function() {
            // Not needed as handled by model defaults, keeping to maintain API
        },

        //////
        // Selection restoration process
        ////


        // Used to add post-load changes to the model
        onAdaptInitialize: function() {
            this.restoreUserAnswers();
        },

        // Used to restore the user answers 
        restoreUserAnswers: function() {},

        
        //////
        // Submit process
        ////

        // Use to check if the user is allowed to submit the question
        // Maybe the user has to select an item?
        canSubmit: function() {},

        // Used to update the amount of attempts the user has left
        updateAttempts: function() {
            if (!this.get('_attemptsLeft')) {
                this.set("_attemptsLeft", this.get('_attempts'));
            }
            this.set("_attemptsLeft", this.get('_attemptsLeft') - 1);
        },

        // Used to set _isEnabled and _isSubmitted on the model
        setQuestionAsSubmitted: function() {
            this.set({
                _isEnabled: false,
                _isSubmitted: true
            });
        },

        // This is important for returning or showing the users answer
        // This should preserve the state of the users answers
        storeUserAnswer: function() {},

        // Sets _isCorrect:true/false based upon isCorrect method below
        markQuestion: function() {

            if (this.isCorrect()) {
                this.set('_isCorrect', true);
            } else {
                this.set('_isCorrect', false);
            }

        },

         // Should return a boolean based upon whether to question is correct or not
        isCorrect: function() {},

        // Used to set the score based upon the _questionWeight
        setScore: function() {},

        // Checks if the question should be set to complete
        // Calls setCompletionStatus and adds complete classes
        checkQuestionCompletion: function() {

            var isComplete = (this.get('_isCorrect') || this.get('_attemptsLeft') === 0);

            if (isComplete) {
                this.setCompletionStatus();
            }

            return isComplete;

        },

        // Updates buttons based upon question state by setting
        // _buttonState on the model which buttonsView listens to
        updateButtons: function() {

            var isInteractionComplete = this.get('_isInteractionComplete');
            var isCorrect = this.get('_isCorrect');
            var isEnabled = this.get('_isEnabled');
            var buttonState = this.get('_buttonState');
            var canShowModelAnswer = this.get('_canShowModelAnswer');

            if (isInteractionComplete) {

                if (isCorrect || !canShowModelAnswer) {
                    // Use correct instead of complete to signify button state
                    this.set('_buttonState', BUTTON_STATE.CORRECT);

                } else {

                    switch (buttonState) {
                        case BUTTON_STATE.SUBMIT:
                        case BUTTON_STATE.HIDE_CORRECT_ANSWER:
                            this.set('_buttonState', BUTTON_STATE.SHOW_CORRECT_ANSWER);
                            break;
                        default:
                            this.set('_buttonState', BUTTON_STATE.HIDE_CORRECT_ANSWER);
                    }

                }

            } else {

                if (isEnabled) {
                    this.set('_buttonState', BUTTON_STATE.SUBMIT);
                } else {
                    this.set('_buttonState', BUTTON_STATE.RESET);
                }
            }

        },

        // Used to setup the correct, incorrect and partly correct feedback
        setupFeedback: function() {
            if (!this.has('_feedback')) return;

            if (this.get('_isCorrect')) {
                this.setupCorrectFeedback();
            } else if (this.isPartlyCorrect()) {
                this.setupPartlyCorrectFeedback();
            } else {
                this.setupIncorrectFeedback();
            }
        },

        // Used by the question to determine if the question is incorrect or partly correct
        // Should return a boolean
        isPartlyCorrect: function() {},

        setupCorrectFeedback: function() {
            this.set({
                feedbackTitle: this.getFeedbackTitle(),
                feedbackMessage: this.get('_feedback').correct
            });
        },

        setupPartlyCorrectFeedback: function() {
            var feedback = this.get('_feedback')._partlyCorrect;

            if (feedback && feedback.final) {
                this.setAttemptSpecificFeedback(feedback);
            } else {
                this.setupIncorrectFeedback();
            }
        },

        setupIncorrectFeedback: function() {
            this.setAttemptSpecificFeedback(this.get('_feedback')._incorrect);
        },

        setAttemptSpecificFeedback: function(feedback) {
            var body = this.get('_attemptsLeft') && feedback.notFinal || feedback.final;

            this.set({
                feedbackTitle: this.getFeedbackTitle(),
                feedbackMessage: body
            });
        },
        
        getFeedbackTitle: function() {
            return this.get('_feedback').title || this.get('displayTitle') ||  this.get('title') || "";
        },

        // Reset the model to let the user have another go (not the same as attempts)
        reset: function(type, force) {
            if (!this.get("_canReset") && !force) return;

            type = type || true; //hard reset by default, can be "soft", "hard"/true

            ComponentModel.prototype.reset.call(this, type, force);

            var attempts = this.get('_attempts');
            this.set({
                _attemptsLeft: attempts,
                _isCorrect: undefined,
                _isSubmitted: false,
                _buttonState: BUTTON_STATE.SUBMIT
            });
        },

        // Reset question for subsequent attempts
        setQuestionAsReset: function() {
            this.set({
                _isEnabled: true,
                _isSubmitted: false
            });
        },

        // Used by the question view to reset the stored user answer
        resetUserAnswer: function() {},
        
        refresh: function() {
            this.trigger('question:refresh');
        },

        getButtonState: function() {
            if (this.get('_isCorrect')) {
                return BUTTON_STATE.CORRECT;
            }

            if (this.get('_attemptsLeft') === 0) {
                 return this.get('_canShowModelAnswer') ? BUTTON_STATE.SHOW_CORRECT_ANSWER : BUTTON_STATE.INCORRECT;
            }

            return this.get('_isSubmitted') ? BUTTON_STATE.RESET : BUTTON_STATE.SUBMIT;
        },

        // Returns an object specific to the question type, e.g. if the question
        // is a 'choice' this should contain an object with:
        // - correctResponsesPattern[]
        // - choices[]
        getInteractionObject: function() {
            return {};
        },

        // Returns a string detailing how the user answered the question.
        getResponse: function() {},

        // Returns a string describing the type of interaction: "choice" and "matching" supported (see scorm wrapper)
        getResponseType: function() {}

    });

    return QuestionModel;

});

define('core/js/views/accessibilityView',[
    'core/js/adapt'
], function(Adapt) {

    var AccessibilityView = Backbone.View.extend({

        el: '#accessibility-toggle',

        initialize: function() {
            this.render();
        },

        events: {
            'click' : 'toggleAccessibility'
        },

        render: function() {
            var hasAccessibility = Adapt.config.has('_accessibility')
                && Adapt.config.get('_accessibility')._isEnabled;

            if (!hasAccessibility) {
                return;
            } else {
                var isActive = Adapt.config.get('_accessibility')._isActive;
                var offLabel = Adapt.course.get('_globals') && (Adapt.course.get('_globals')._accessibility.accessibilityToggleTextOff || Adapt.course.get('_globals')._accessibility._accessibilityToggleTextOff);
                var onLabel = Adapt.course.get('_globals') && (Adapt.course.get('_globals')._accessibility.accessibilityToggleTextOn || Adapt.course.get('_globals')._accessibility._accessibilityToggleTextOn);

                var toggleText = isActive ? offLabel : onLabel;

                this.$el.attr('aria-label', Adapt.course.get("title") + ". "
                    + Adapt.course.get('_globals')._accessibility._ariaLabels.accessibilityToggleButton + ". "
                    + $.a11y_normalize(toggleText));
            }
        },

        toggleAccessibility: function(event) {
            event.preventDefault();

            var hasAccessibility = Adapt.config.get('_accessibility')._isActive;

            var toggleAccessibility = (hasAccessibility) ? false : true;

            Adapt.config.get('_accessibility')._isActive = toggleAccessibility;

            Adapt.trigger('accessibility:toggle');

            this.render();

            Backbone.history.navigate(window.location.hash || "#/", {trigger: true});
        }

    });

    return AccessibilityView;

});

define('core/js/views/navigationView',[
    'core/js/adapt',
    'core/js/views/accessibilityView'
], function(Adapt, AccessibilityView) {

    var NavigationView = Backbone.View.extend({

        className: "navigation",

        initialize: function() {
            this.listenToOnce(Adapt, {
                'courseModel:dataLoading': this.remove,
                'accessibility:toggle': this.onA11yToggle
            });
            this.listenTo(Adapt, 'router:menu router:page', this.hideNavigationButton);
            this.template = "navigation";
            this.preRender();
        },

        events: {
            'click [data-event]':'triggerEvent'
        },

        preRender: function() {
            Adapt.trigger('navigationView:preRender', this);
            this.render();
        },

        render: function() {
            var template = Handlebars.templates[this.template];
            this.$el.html(template(
                {
                    _globals: Adapt.course.get("_globals"),
                    _accessibility: Adapt.config.get("_accessibility")
                }
            )).insertBefore('#wrapper');

            _.defer(_.bind(function() {
                Adapt.trigger('navigationView:postRender', this);
            }, this));

            this.setupA11yButton();

            if (Adapt.accessibility.isActive()) {
                this.setupUsageInstructions();
            }

            return this;
        },

        triggerEvent: function(event) {
            event.preventDefault();
            var currentEvent = $(event.currentTarget).attr('data-event');
            Adapt.trigger('navigation:' + currentEvent);
        },

        hideNavigationButton: function(model) {
            if (model.get('_type') === "course") {
                $('.navigation-back-button, .navigation-home-button').addClass('display-none');
            } else {
                this.showNavigationButton();
            }
        },

        showNavigationButton: function() {
            $('.navigation-back-button, .navigation-home-button').removeClass('display-none');
        },

        setupA11yButton: function() {
            new AccessibilityView();
        },

        setupUsageInstructions: function() {
            var config = Adapt.course.get("_globals")._accessibility;

            if (!config || !config._accessibilityInstructions) {
                this.$('#accessibility-instructions').remove();
                return;
            }

            var instructionsList = config._accessibilityInstructions;

            var usageInstructions;
            if (instructionsList[Adapt.device.browser]) {
                usageInstructions = instructionsList[Adapt.device.browser];
            } else if (Modernizr.touch) {
                usageInstructions = instructionsList.touch || "";
            } else {
                usageInstructions = instructionsList.notouch || "";
            }

           this.$('#accessibility-instructions').html( usageInstructions );
        },

        onA11yToggle:function() {
            // listen once because if a11y active on launch instructions will already be setup
            
            if (Adapt.accessibility.isActive()) {
                this.setupUsageInstructions();
            }
        }

    });

    return NavigationView;

});

define('core/js/accessibility',[
    'core/js/adapt',
    'a11y'
], function(Adapt) {

    var defaultAriaLevels = {
        "_menu": 1,
        "_menuItem": 2,
        "_page": 1,
        "_article": 2,
        "_block": 3,
        "_component": 4,
        "_componentItem": 5
    };

    var Accessibility = Backbone.Controller.extend({

        $html: $('html'),

        _hasUsageInstructionRead: false,
        _isLoaded: false,
        _hasCourseLoaded: false,

        reset: function() {
            _.extend(this, {
                _hasUsageInstructionRead: false
            });
        },

        initialize: function() {
            //RUN ONCE
            if (this._isLoaded) return;

            this.removeLegacyElements();

            //TRIGGER SETUP ON DATA LOADED AND TOGGLE BUTTON
            Adapt.once('app:dataLoaded', function() {
                //check if accessibility mode should be restored
                this._hasCourseLoaded = true;
                Adapt.config.get("_accessibility")._isActive = Adapt.offlineStorage.get("a11y") || false;
                this.setupAccessibility();

            }, this);

            Adapt.on('accessibility:toggle', this.setupAccessibility, this);

            //SETUP RENDERING HELPERS
            Adapt.once('app:dataLoaded', this.setupHelpers, this);

            //SETUP NO SELECT PARAMETERS ON DEVICE CHANGE
            Adapt.on("device:changed", this.setupNoSelect);

            //Configure the accessibility library
            this.listenToOnce(Adapt, "app:dataReady", this.configureA11yLibrary);

            //CAPTURE ROUTING/NEW DOCUMENT LOADING START AND END
            this.listenTo(Adapt, {
                'router:location': this.onNavigationStart,
                'pageView:ready menuView:ready router:plugin': this.onNavigationEnd
            });
        },

        removeLegacyElements: function() {
            var $legacyElements = $("body").children("#accessibility-toggle, #accessibility-instructions");

            if (!$legacyElements.length) return;

            Adapt.log.warn("DEPRECATED - #accessibility-toggle and #accessibility-instructions have been moved to the navigation bar. Please remove them from all of your .html files.");
            $legacyElements.remove();
        },

        setupAccessibility: function() {
            //CALLED ON BUTTON CLICK AND ON DATA LOAD
            if (!this.isEnabled()) return;

            //save accessibility state
            Adapt.offlineStorage.set("a11y", Adapt.config.get("_accessibility")._isActive);

            this.reset();

            this.configureA11yLibrary();

            // Check if accessibility is active
            if (this.isActive()) {
                this.setupDocument();
                this.setupPopupListeners();
                this.setupLogging();

            } else {

                this.revertDocument();
                this.revertPopupListeners();
                this.removeUsageInstructionListener();
                this.revertLogging();
            }
        },

        setupHelpers: function() {

            //MAKE $.a11y_text and $.a11y_normalize IN GLOBAL HANDLEBARS HELPERS a11y_text and a11y_normalize
            var config = Adapt.config.has('_accessibility')
                ? Adapt.config.get("_accessibility")
                : false;

            var helpers = {

                a11y_text: function(text) {
                    //ALLOW ENABLE/DISABLE OF a11y_text HELPER
                    if (config && config._isTextProcessorEnabled === false) {
                        return text;
                    } else {
                        return $.a11y_text(text);
                    }
                },

                a11y_normalize: function(text) {
                    return $.a11y_normalize(text);
                },

                a11y_remove_breaks: function(text) {
                    return $.a11y_remove_breaks(text);
                },

                a11y_aria_label: function(text) {
                    return new Handlebars.SafeString('<div class="aria-label prevent-default'+getIgnoreClass()+'" '+getTabIndex()+' role="region">'+text+'</div>');
                },

                a11y_aria_label_relative: function(text) {
                    return new Handlebars.SafeString('<div class="aria-label relative prevent-default'+getIgnoreClass()+'" '+getTabIndex()+' role="region">'+text+'</div>');
                },

                a11y_wrap_focus: function(text) {
                    return new Handlebars.SafeString('<a class="a11y-focusguard a11y-ignore a11y-ignore-focus" '+getTabIndex()+' role="button">&nbsp;</a>');
                },

                a11y_attrs_heading: function(levelOrType) {
                    // get the global configuration from config.json
                    var cfg = Adapt.config.get('_accessibility');
                    // default level to use if nothing overrides it
                    var level = 1;

                    // first check to see if the Handlebars context has an override
                    if (this._ariaLevel) {
                        levelOrType = this._ariaLevel;
                    }

                    if (isNaN(levelOrType) === false) {
                        // if a number is passed just use this
                        level = levelOrType;
                    }
                    else if (_.isString(levelOrType)) {
                        // if a string is passed check if it is defined in global configuration
                        cfg._ariaLevels = cfg._ariaLevels || defaultAriaLevels;
                        if (cfg._ariaLevels && cfg._ariaLevels["_"+levelOrType] !== undefined) {
                            level = cfg._ariaLevels["_"+levelOrType];
                        }
                    }

                    return new Handlebars.SafeString(' role="heading" aria-level="'+level+'" '+getTabIndex()+' ');
                },

                a11y_attrs_tabbable: function() {
                    return new Handlebars.SafeString(' role="region" '+getTabIndex()+' ');
                }

            };

            for (var name in helpers) {
                if (helpers.hasOwnProperty(name)) {
                     Handlebars.registerHelper(name, helpers[name]);
                }
            }

            var getTabIndex = function() {
                return this.isActive() ? 'tabindex="0"' : 'tabindex="-1"';
            }.bind(this);

            var getIgnoreClass = function() {
                return $.a11y.options.isTabbableTextEnabled ? '' : ' a11y-ignore';
            }.bind(this);

        },

        setupNoSelect: function() {
            if (!Adapt.config.get('_accessibility') || !Adapt.config.get('_accessibility')._disableTextSelectOnClasses) return;

            var classes = Adapt.config.get('_accessibility')._disableTextSelectOnClasses.split(" ");

            var isMatch = false;
            for (var i = 0, item; item = classes[i++];) {
                if ($('html').is(item)) {
                    isMatch = true;
                    break;
                }
            }

            if (isMatch) {
                $('html').addClass("no-select");
            } else  {
                $('html').removeClass("no-select");
            }

        },

        configureA11yLibrary: function() {

            var topOffset = $('.navigation').height();
            var bottomoffset = 0;
            $.a11y.options.focusOffsetTop = topOffset;
            $.a11y.options.focusOffsetBottom = bottomoffset;
            $.a11y.options.OS = Adapt.device.OS.toLowerCase();
            $.a11y.options.isTouchDevice = Adapt.device.touch;

            if (this.isActive()) {
                _.extend($.a11y.options, {
                    isTabbableTextEnabled: true,
                    isUserInputControlEnabled: true,
                    isFocusControlEnabled: true,
                    isFocusLimited: true,
                    isRemoveNotAccessiblesEnabled: true,
                    isAriaLabelFixEnabled: true,
                    isScrollDisableEnabled: true,
                    isScrollDisabledOnPopupEnabled: false,
                    isSelectedAlertsEnabled: true,
                    isAlertsEnabled: true
                });
            } else {
                _.extend($.a11y.options, {
                    isTabbableTextEnabled: false,
                    isUserInputControlEnabled: true,
                    isFocusControlEnabled: true,
                    isFocusLimited: false,
                    isRemoveNotAccessiblesEnabled: true,
                    isAriaLabelFixEnabled: true,
                    isScrollDisableEnabled: true,
                    isScrollDisabledOnPopupEnabled: false,
                    isSelectedAlertsEnabled: false,
                    isAlertsEnabled: false
                });
            }

            this.setupNoSelect();

            $.a11y.ready();
        },

        onNavigationStart: function() {
            this._isLoaded = false;
            //STOP DOCUMENT READING, MOVE FOCUS TO APPROPRIATE LOCATION
            $("#a11y-focuser").a11y_focus(true);
            _.defer(function() {
                $.a11y_on(false, '.page');
                $.a11y_on(false, '.menu');
            });
        },

        onNavigationEnd: function(view) {
            //prevent sub-menu items provoking behaviour
            if (view && view.model) {
                if (view.model.get("_id") != Adapt.location._currentId) return;
            }

            //always use detached aria labels for divs and spans
            _.defer(function() {
                $('body').a11y_aria_label(true);
            });

            this._isLoaded = true;

            $.a11y_on(false, '.page');
            $.a11y_on(false, '.menu');

            this.configureA11yLibrary();
            $.a11y_update();
            this.setNavigationBar();

            $('#accessibility-toggle').focus();

            //MAKE FOCUS RIGHT
            _.delay(_.bind(function() {
                this.focusInitial();
            }, this), 500);

        },

        setNavigationBar: function() {
            var $navArias = $(".navigation").find(".aria-label").not('#accessibility-instructions');

            if (this.isActive()) {
                $navArias.attr("tabindex", 0).removeAttr("aria-hidden").removeClass("a11y-ignore");
            } else {
                $navArias.attr("tabindex", -1).attr("aria-hidden", "true");
            }
        },

        isActive: function() {
            return Adapt.config.has('_accessibility')
                && Adapt.config.get('_accessibility')._isEnabled
                && Adapt.config.get('_accessibility')._isActive;
        },

        isEnabled: function() {
            return Adapt.config.has('_accessibility')
                && Adapt.config.get('_accessibility')._isEnabled;
        },

        setupDocument: function() {
            this.$html.addClass('accessibility');

            if (Adapt.config.get('_accessibility')._isTextProcessorEnabled) {
                this.$html.addClass('text-to-speech');
            }

            $('.skip-nav-link').removeClass('a11y-ignore a11y-ignore-focus');

            $.a11y(true)
            $.a11y_on(true, "#accessibility-instructions");
        },

        setupPopupListeners: function() {
            this.listenTo(Adapt, 'popup:opened popup:closed', this.onPop);
        },

        setupLogging: function() {
            if (!Adapt.config.get("_accessibility") || !Adapt.config.get("_accessibility")._logReading) return;

            $(document).on("reading", this.onRead);
        },

        revertDocument: function() {
            this.$html.removeClass('accessibility text-to-speech');
            $('.skip-nav-link').addClass('a11y-ignore a11y-ignore-focus');
            $.a11y(false);
            $.a11y_on(false, "#accessibility-instructions");
            $.a11y_on(true, "#accessibility-toggle");
        },

        revertPopupListeners: function() {
            this.stopListening(Adapt, 'popup:opened popup:closed', this.onPop);
        },

        removeUsageInstructionListener:function() {
            $('#accessibility-instructions').off("blur", this.onFocusInstructions);
        },

        revertLogging: function() {
            if (Adapt.course.has("_globals") && (!Adapt.course.get("_globals")._accessibility || !Adapt.course.get("_globals")._accessibility._logReading)) return;

            $($.a11y).off("reading", this.onRead);
        },


        focusInitial: function() {
            if (!this.isActive()) return;

            var debouncedInitial = _.debounce(_.bind(function() {
                //ENABLED DOCUMENT READING

                if (!this._hasUsageInstructionRead) {

                    this._hasUsageInstructionRead = true;

                    $.a11y_on(true, '.page');
                    $.a11y_on(true, '.menu');

                    $('#accessibility-instructions').one("blur", this.onFocusInstructions);

                    _.delay(function(){
                        $('#accessibility-instructions').focusNoScroll();
                    }, 250);

                } else {

                    if (Adapt.location._currentId && $.a11y.options.OS!="mac") {
                        //required to stop JAWS from auto reading content in IE
                        var currentModel = Adapt.findById(Adapt.location._currentId);
                        var alertText = " ";

                        switch (currentModel.get("_type")) {
                            case "page":
                                if (Adapt.course.get("_globals") && Adapt.course.get("_globals")._accessibility && Adapt.course.get("_globals")._accessibility._ariaLabels && Adapt.course.get("_globals")._accessibility._ariaLabels.pageLoaded) {
                                    alertText = Adapt.course.get("_globals")._accessibility._ariaLabels.pageLoaded;
                                }
                                break;

                            case "menu":
                            /* falls through */
                            default:
                                if (Adapt.course.get("_globals") && Adapt.course.get("_globals")._accessibility && Adapt.course.get("_globals")._accessibility._ariaLabels && Adapt.course.get("_globals")._accessibility._ariaLabels.menuLoaded) {
                                    alertText = Adapt.course.get("_globals")._accessibility._ariaLabels.menuLoaded;
                                }
                                break;
                        }

                        $.a11y_alert(alertText);
                    }

                     _.delay(_.bind(function() {
                        var windowScrollTop = $(window).scrollTop();
                        var documentScrollTop = $(document).scrollTop();

                        $.a11y_on(true, '.page');
                        $.a11y_on(true, '.menu');

                        //prevent auto scrolling to top when scroll has been initiated
                        if (windowScrollTop > 0 || documentScrollTop > 0) return;

                        _.delay(function(){
                            $.a11y_focus();
                        }, 500);

                    }, this), 500);

                }

            }, this), 100);
            debouncedInitial();

        },

        onRead: function(event, text) {
            //OUTPUT READ TEXT TO CONSOLE
            console.log("READING: " + text);
        },

        onPop: function() {
            //MAKE SURE POPUP IS CONFIGURED CORRECTLY WITH ARIA LABELS, TABINDEXES ETC
            if (this.isActive()) {
                $.a11y_update();
            }
        },

        onFocusInstructions: function(event) {
            //HIDE INSTRUCTIONS FROM TAB WRAP AROUND AFTER LEAVING INSTRUCTIONS
            if (!Adapt.accessibility._isLoaded) return;
            $('#accessibility-instructions')
                .addClass("a11y-ignore-focus")
                .off("blur", Adapt.accessibility.onFocusInstructions);
        }

    });

    Adapt.accessibility = new Accessibility();

    return Adapt.accessibility;

});

define('core/js/offlineStorage',[
    'core/js/adapt'
], function(Adapt) {

    //Basic API for setting and getting name+value pairs
    //Allows registration of a single handler.

    var OfflineStorage = Backbone.Controller.extend({

        /**
         * set to true initially so that if there are no offlineStorage handlers (i.e. if contrib-spoor is not installed)
         * this can still be accessed OK
         */
        ready: true,
        _handler: undefined,

        /**
         * set .ready to false if an offlineStorage handler is being attached - we'll need to wait until the handler lets us know
         * it's ready before we can safely use offlineStorage
         */
        initialize: function(handler) {
            if (!handler) {
                return;
            }

            this.ready = false;
            this._handler = handler;
        },

        /**
         * Flag to indicate if an offlineStorage handler has been defined.
         * @returns {boolean} true if an offlineStorage handler has been defined, false otherwise
         */
        hasHandler: function() {
            return this._handler !== undefined;
        },

        set: function(name, value) {
            if (this._handler && this._handler.set) {
                return this._handler.set.apply(this._handler, arguments);
            }
            // if no handler has been defined, just store the data locally
            this[name] = value;
        },

        get: function(name) {
            if (this._handler && this._handler.get) {
                return this._handler.get.apply(this._handler, arguments);
            }
            // if no handler has been defined, check local data store
            return this[name];
        },

        /**
         * Some forms of offlineStorage could take time to initialise, this allows us to let plugins know when it's ready to be used
         */
        setReadyStatus: function() {
            this.ready = true;
            Adapt.trigger("offlineStorage:ready");
        }

    });

    Adapt.offlineStorage = new OfflineStorage();

    return Adapt.offlineStorage;

});

define('core/js/enums/completionStateEnum',[],function() {
  
      var COMPLETION_STATE = ENUM([
          'INCOMPLETE',
          'COMPLETED',
          'PASSED',
          'FAILED'
      ]);
  
      return COMPLETION_STATE;
  
  });
define('core/js/tracking',[
    'core/js/adapt',
    'core/js/enums/completionStateEnum'
], function(Adapt, COMPLETION_STATE) {

    var Tracking = Backbone.Controller.extend({

        _config: {
            _requireContentCompleted: true,
            _requireAssessmentCompleted: false
        },

        _assessmentState: null,

        initialize: function() {
            Adapt.once('configModel:dataLoaded', this.loadConfig.bind(this));
            Adapt.on('app:dataReady', this.setupEventListeners.bind(this));
        },

        setupEventListeners: function() {
            // Check if completion requires passing an assessment. 
            if (this._config._requireAssessmentCompleted) {
                this.listenTo(Adapt, {
                    'assessment:complete': this.onAssessmentComplete,
                    'assessment:restored': this.onAssessmentRestored
                });
            }

            // Check if completion requires completing all content.
            if (this._config._requireContentCompleted) {
                this.listenTo(Adapt.course, 'change:_isComplete', this.checkCompletion);
            }
        },

        /**
         * Store the assessment state.
         * @param {object} assessmentState - The object returned by Adapt.assessment.getState()
         */
        onAssessmentComplete: function(assessmentState) {
            this._assessmentState = assessmentState;

            this.checkCompletion();
        },

        /**
         * Restores the _assessmentState object when an assessment is registered.
         * @param {object} assessmentState - An object representing the overall assessment state
         */
        onAssessmentRestored: function(assessmentState) {
            this._assessmentState = assessmentState;
        },

        /**
         * Evaluate the course and assessment completion.
         */
        checkCompletion: function() {
            var completionData = this.getCompletionData();

            if (completionData.status === COMPLETION_STATE.INCOMPLETE) {
                return;
            }

            Adapt.trigger('tracking:complete', completionData);
            Adapt.log.debug('tracking:complete', completionData);
        },

        /**
         * The return value of this function should be passed to the trigger of 'tracking:complete'.
         * @returns An object representing the user's course completion.
         */
        getCompletionData: function() {
            var completionData = {
                status: COMPLETION_STATE.INCOMPLETE,
                assessment: null
            };

            // Course complete is required.
            if (this._config._requireContentCompleted && !Adapt.course.get('_isComplete')) {
                // INCOMPLETE: course not complete.
                return completionData;
            }

            // Assessment completed required.
            if (this._config._requireAssessmentCompleted) {
                if (!this._assessmentState) {
                    // INCOMPLETE: assessment is not complete.
                    return completionData;
                }

                // PASSED/FAILED: assessment completed.
                completionData.status = this._assessmentState.isPass ? COMPLETION_STATE.PASSED : COMPLETION_STATE.FAILED;
                completionData.assessment = this._assessmentState;

                return completionData;
            }

            // COMPLETED: criteria met, no assessment requirements.
            completionData.status = COMPLETION_STATE.COMPLETED;

            return completionData;
        },

        /**
         * Set the _config object to the values retrieved from config.json.
         */
        loadConfig: function() {
            if (Adapt.config.has('_completionCriteria')) {
                this._config = Adapt.config.get('_completionCriteria');
            }
        }

    });

    Adapt.tracking = new Tracking();

    return Adapt.tracking;
});

define('core/js/device',[
    'core/js/adapt',
    'bowser'
], function(Adapt, Bowser) {

    var $html = $('html');
    var $window = $(window);

    Adapt.device = {
        touch: Modernizr.touchevents,
        screenWidth: getScreenWidth(),
        screenHeight: getScreenHeight(),
        browser: (Bowser.name || '').toLowerCase(),
        version: (Bowser.version || '').toLowerCase(),
        OS: getOperatingSystem().toLowerCase(),
        osVersion: Bowser.osversion || '',
        renderingEngine: getRenderingEngine()
    };

    // Define 'orientation' and 'aspectRatio' here once 'screenWidth' and 'screenHeight' have been set,
    // as both these functions are getters, essentially.
    Object.defineProperties(Adapt.device, {
        "orientation": {
            get: function () {
                return (this.screenWidth >= this.screenHeight) ? 'landscape' : 'portrait';
            }
        },
        "aspectRatio": {
            get: function () {
                return this.screenWidth / this.screenHeight;
            }
        }
    });

    Adapt.once('app:dataReady', function() {
        Adapt.device.screenSize = checkScreenSize();

        $html.addClass('size-' + Adapt.device.screenSize);
        
        if (Adapt.device.orientation) {
            $html.addClass('orientation-' + Adapt.device.orientation);
        }

        // As Adapt.config is available it's ok to bind the 'resize'.
        $window.on('resize orientationchange', onWindowResize);
    });

    /**
     * Compares the calculated screen width to the breakpoints defined in config.json.
     * 
     * @returns {string} 'large', 'medium' or 'small'
     */
    function checkScreenSize() {
        var screenSizeConfig = Adapt.config.get('screenSize');
        var screenSize;

        if (Adapt.device.screenWidth > screenSizeConfig.medium) {
            screenSize = 'large';
        } else if (Adapt.device.screenWidth > screenSizeConfig.small) {
            screenSize = 'medium';
        } else {
            screenSize = 'small';
        }

        return screenSize;
    }

    function getScreenWidth() {
        return isAppleDevice()
            ? getAppleScreenWidth()
            : window.innerWidth || $window.width();
    }

    function getScreenHeight() {
        return isAppleDevice()
            ? getAppleScreenHeight()
            : window.innerHeight || $window.height();
    }

    function getOperatingSystem() {
        var os = '';
        var flags = ['windows', 'mac', 'linux', 'windowsphone', 'chromeos', 'android',
            'ios', 'blackberry', 'firefoxos', 'webos', 'bada', 'tizen', 'sailfish'];

        for (var i = 0; i < flags.length; i++) {
            if (Bowser[flags[i]]) {
                os = flags[i];
                break;
            }
        }

        if (os === '') {
            // Fall back to using navigator.platform in case Bowser can't detect the OS.
            var platform = navigator.platform;
            var platforms = ['Win', 'Mac', 'Linux'];
            os = 'PlatformUnknown';

            for (var i = 0; i < platforms.length; i++) {
                if (platform.indexOf(platforms[i]) != -1) {
                    os = platforms[i].toLowerCase();
                    break;
                }
            }

            // Set consistency with the Bowser flags.
            if (os == 'win') {
                os = 'windows';
            }
        }

        return os;
    }

    function getRenderingEngine() {
        var engine = '';
        var flags = ['webkit', 'blink', 'gecko', 'msie', 'msedge'];

        for (var i = 0; i < flags.length; i++) {
            if (Bowser[flags[i]]) {
                engine = flags[i];
                break;
            }
        }

        return engine;
    }

    var onWindowResize = _.debounce(function onScreenSizeChanged() {
        // Calculate the screen properties.
        var previousWidth = Adapt.device.screenWidth;
        var previousHeight = Adapt.device.screenHeight;

        Adapt.device.screenWidth = getScreenWidth();
        Adapt.device.screenHeight = getScreenHeight();

        if (previousWidth === Adapt.device.screenWidth && previousHeight === Adapt.device.screenHeight) {
            // Do not trigger a change if the viewport hasn't actually changed.  Scrolling on iOS will trigger a resize.
            return;
        }

        var newScreenSize = checkScreenSize();

        if (newScreenSize !== Adapt.device.screenSize) {
            Adapt.device.screenSize = newScreenSize;

            $html.removeClass('size-small size-medium size-large').addClass('size-' + Adapt.device.screenSize);

            if (Adapt.device.orientation) {
                $html.removeClass('orientation-landscape orientation-portrait').addClass('orientation-' + Adapt.device.orientation);
            }

            Adapt.trigger('device:changed', Adapt.device.screenSize);
        }

        Adapt.trigger('device:preResize device:resize device:postResize', Adapt.device.screenWidth);

    }, 100);

    function isAppleDevice() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    }

    function getAppleScreenWidth() {
        return (Math.abs(window.orientation) === 90) ? screen.height : screen.width;
    }

    function getAppleScreenHeight() {
        return (Math.abs(window.orientation) === 90) ? screen.width : screen.height;
    }

    function getAppleDeviceType() {
        var type = '';

        var flags = ['iphone', 'ipad', 'ipod'];

        for (var i = 0; i < flags.length; i++) {
            if (Bowser[flags[i]]) {
                type = flags[i];
                break;
            }
        }

        return type;
    }

    function pixelDensity() {
        var pixelDensity = (window.devicePixelRatio || 1);

        if (pixelDensity >= 3) {
            return 'ultra-high';
        } else if (pixelDensity >= 2) {
            return 'high';
        } else if (pixelDensity >= 1.5) {
            return 'medium';
        } else {
            return 'low';
        }
    }

    var browser = Adapt.device.browser.toLowerCase();
    // Convert 'msie' and 'internet explorer' to 'ie'.
    var browserString = browser.replace(/msie|internet explorer/, 'ie');
    browserString = browserString + ' version-' + Adapt.device.version + ' OS-' + Adapt.device.OS + ' ' + getAppleDeviceType();
    browserString += browserString.replace('.', '-').toLowerCase();

    $html.addClass(browserString + ' pixel-density-' + pixelDensity());
});

define('core/js/views/drawerView',[
    'core/js/adapt'
], function(Adapt) {

    var DrawerView = Backbone.View.extend({

        className: 'drawer display-none',
        disableAnimation: false,
        escapeKeyAttached: false,

        initialize: function() {
            this.disableAnimation = Adapt.config.has('_disableAnimation') ? Adapt.config.get('_disableAnimation') : false;
            this._isVisible = false;
            this.drawerDir = 'right';
            if(Adapt.config.get('_defaultDirection')=='rtl'){//on RTL drawer on the left
                this.drawerDir = 'left';
            }
            this.setupEventListeners();
            this.render();
            this.drawerDuration = Adapt.config.get('_drawer')._duration;
            this.drawerDuration = (this.drawerDuration) ? this.drawerDuration : 400;
            // Setup cached selectors
            this.$wrapper = $('#wrapper');
        },

        setupEventListeners: function() {
            this.listenTo(Adapt, {
                'navigation:toggleDrawer': this.toggleDrawer,
                'drawer:triggerCustomView': this.openCustomView,
                'drawer:closeDrawer': this.onCloseDrawer,
                'remove': this.onCloseDrawer,
                'drawer:remove': this.remove,
                'accessibility:toggle': this.onAccessibilityToggle
            });

            this._onKeyUp = _.bind(this.onKeyUp, this);
            this.setupEscapeKey();
        },

        setupEscapeKey: function() {
            var hasAccessibility = Adapt.config.has('_accessibility') && Adapt.config.get('_accessibility')._isActive;

            if (!hasAccessibility && ! this.escapeKeyAttached) {
                $(window).on("keyup", this._onKeyUp);
                this.escapeKeyAttached = true;
            } else {
                $(window).off("keyup", this._onKeyUp);
                this.escapeKeyAttached = false;
            }
        },

        onAccessibilityToggle: function() {
            this.setupEscapeKey();
        },

        onKeyUp: function(event) {
            if (event.which != 27) return;
            event.preventDefault();

            this.onCloseDrawer();
        },

        events: {
            'click .drawer-back': 'onBackButtonClicked',
            'click .drawer-close':'onCloseDrawer'
        },

        render: function() {
            var template = Handlebars.templates['drawer']
            $(this.el).html(template({_globals: Adapt.course.get("_globals")})).prependTo('body');
            var shadowTemplate = Handlebars.templates['shadow'];
            $(shadowTemplate()).prependTo('body');
            // Set defer on post render
            _.defer(_.bind(function() {
                this.postRender();
            }, this));
            return this;
        },

        // Set tabindex for select elements
        postRender: function() {
            this.$('a, button, input, select, textarea').attr('tabindex', -1);

            this.checkIfDrawerIsAvailable();
        },

        openCustomView: function(view, hasBackButton) {
            // Set whether back button should display
            this._hasBackButton = hasBackButton;
            this._isCustomViewVisible = true;
            Adapt.trigger('drawer:empty');
            this.showDrawer();
            this.$('.drawer-holder').html(view);
        },

        checkIfDrawerIsAvailable: function() {
            if (this.collection.length == 0) {
                $('.navigation-drawer-toggle-button').addClass('display-none');
                Adapt.trigger('drawer:noItems');
            } else {
                $('.navigation-drawer-toggle-button').removeClass('display-none');
            }
        },

        onBackButtonClicked: function(event) {
            event.preventDefault();
            this.showDrawer(true);
        },

        onCloseDrawer: function(event) {
            if (event) {
                event.preventDefault();
            }
            this.hideDrawer();
        },

        toggleDrawer: function() {
            if (this._isVisible && this._isCustomViewVisible === false) {
                this.hideDrawer();
            } else {
                this.showDrawer(true);
            }
        },

        showDrawer: function(emptyDrawer) {
            this.$el.removeClass('display-none');
            //only trigger popup:opened if drawer is visible, pass popup manager drawer element
            if (!this._isVisible) {
                Adapt.trigger('popup:opened', this.$el);
                $('body').scrollDisable();
                this._isVisible = true;
            }

            var drawerWidth = this.$el.width();
            // Sets tab index to 0 for all tabbable elements in Drawer
            this.$('a, button, input, select, textarea').attr('tabindex', 0);

            if (emptyDrawer) {
                this.$('.drawer-back').addClass('display-none');
                this._isCustomViewVisible = false;
                this.emptyDrawer();
                if (this.collection.models.length === 1) {
                    // This callback triggers openCustomView() and sets
                    // _isCustomViewVisible to true, causing toggleDrawer()
                    // to re-render the drawer on every toggle button press
                    Adapt.trigger(this.collection.models[0].get('eventCallback'));
                    // Set _isCustomViewVisible to false to prevent re-rendering
                    // the drawer and fix the toggle functionality on toggle button press
                    this._isCustomViewVisible = false;
                } else {
                    this.renderItems();
                    Adapt.trigger('drawer:openedItemView');
                }
            } else {
                if (this._hasBackButton && this.collection.models.length > 1) {
                    this.$('.drawer-back').removeClass('display-none');
                } else {
                    this.$('.drawer-back').addClass('display-none');
                }
                Adapt.trigger('drawer:openedCustomView');
            }

            //delay drawer animation until after background fadeout animation is complete
            if (this.disableAnimation) {
                $('#shadow').removeClass("display-none");

                var direction={};
                direction[this.drawerDir]=0;
                this.$el.css(direction);
                complete.call(this);
                
            } else {

                $('#shadow').velocity({opacity:1},{duration:this.drawerDuration, begin: _.bind(function() {
                    $("#shadow").removeClass("display-none");
                    complete.call(this);
                }, this)});

                var showEasingAnimation = Adapt.config.get('_drawer')._showEasing;
                var easing = (showEasingAnimation) ? showEasingAnimation : 'easeOutQuart';
                var direction={};
                direction[this.drawerDir]=0;
                this.$el.velocity(direction, this.drawerDuration, easing);

            }

            function complete() {
                this.addShadowEvent();
                Adapt.trigger('drawer:opened');
                
                //focus on first tabbable element in drawer
                this.$el.a11y_focus();
	    }

        },

        emptyDrawer: function() {
            this.$('.drawer-holder').empty();
        },

        renderItems: function() {
            Adapt.trigger('drawer:empty');
            this.emptyDrawer();
            var models = this.collection.models;
            for (var i = 0, len = models.length; i < len; i++) {
                var item = models[i];
                new DrawerItemView({model: item});
            }
        },

        hideDrawer: function() {
            //only trigger popup:closed if drawer is visible
            if (this._isVisible) {
                Adapt.trigger('popup:closed');
                this._isVisible = false;
                $('body').scrollEnable();
            } else {
                return;
            }

            if (this.disableAnimation) {

                var direction={};
                direction[this.drawerDir]=-this.$el.width();
                this.$el.css(direction).addClass('display-none');

                $('#shadow').addClass("display-none");

                Adapt.trigger('drawer:closed');

            } else {

                var showEasingAnimation = Adapt.config.get('_drawer')._hideEasing;
                var easing = (showEasingAnimation) ? showEasingAnimation : 'easeOutQuart';

                var direction={};
                direction[this.drawerDir]=-this.$el.width();
                this.$el.velocity(direction, this.drawerDuration, easing, _.bind(function() {
                    this.$el.addClass('display-none');
                    Adapt.trigger('drawer:closed');
                }, this));

                $('#shadow').velocity({opacity:0}, {duration:this.drawerDuration, complete:function() {
                    $('#shadow').addClass("display-none");
                }});

            }

            this._isCustomViewVisible = false;
            this.removeShadowEvent();


        },

        addShadowEvent: function() {
            $('#shadow').one('click touchstart', _.bind(function() {
                this.onCloseDrawer();
            }, this));
        },

        removeShadowEvent: function() {
            $('#shadow').off('click touchstart');
        },

        remove: function() {
            Backbone.View.prototype.remove.apply(this, arguments);
            $(window).off("keyup", this._onKeyUp);

            Adapt.trigger('drawer:empty');
            this.collection.reset();
            $('#shadow').remove();
        }

    });

    var DrawerItemView = Backbone.View.extend({

        className: 'drawer-item',

        initialize: function() {
            this.listenTo(Adapt, 'drawer:empty', this.remove);
            this.render();
        },

        events: {
            'click .drawer-item-open': 'onDrawerItemClicked'
        },

        render: function() {
            var data = this.model.toJSON();
            var template = Handlebars.templates['drawerItem']
            $(this.el).html(template(data)).appendTo('.drawer-holder');
            return this;
        },

        onDrawerItemClicked: function(event) {
            event.preventDefault();
            var eventCallback = this.model.get('eventCallback');
            Adapt.trigger(eventCallback);
        }
    });

    return DrawerView;
});

define('core/js/drawer',[
    'core/js/adapt',
    'core/js/views/drawerView'
], function(Adapt, DrawerView) {

    var DrawerCollection = new Backbone.Collection(null, { comparator: 'drawerOrder' });
    var Drawer = {};

    Drawer.addItem = function(drawerObject, eventCallback) {
        drawerObject.eventCallback = eventCallback;
        DrawerCollection.add(drawerObject);
    };

    Drawer.triggerCustomView = function(view, hasBackButton) {
        if (hasBackButton !== false) {
            hasBackButton = true;
        }
        Adapt.trigger('drawer:triggerCustomView', view, hasBackButton);
    };

    Adapt.on({
        'adapt:start': function() {
            new DrawerView({ collection: DrawerCollection });
        },
        'app:languageChanged': function() {
            Adapt.trigger('drawer:remove');
        }
    });

    Adapt.drawer = Drawer;

});

define('core/js/views/notifyView',[
    'core/js/adapt'
], function(Adapt) {

    var NotifyView = Backbone.View.extend({

        className: function() {
            var classes = 'notify ';
            classes += (this.model.get('_classes') || '');
            return classes;
        },

        disableAnimation: false,

        escapeKeyAttached: false,

        isOpen: false,

        initialize: function() {
            this.disableAnimation = Adapt.config.has('_disableAnimation') ? Adapt.config.get('_disableAnimation') : false;

            this.setupEventListeners();

            //include accessibility globals in notify model
            this.model.set('_globals', Adapt.course.get('_globals'));
            this.render();
        },

        setupEventListeners: function() {
            this.listenTo(Adapt, {
                'remove page:scrollTo': this.closeNotify,
                'notify:resize': this.resetNotifySize,
                'notify:cancel': this.cancelNotify,
                'notify:close': this.closeNotify,
                'device:resize': this.resetNotifySize,
                'accessibility:toggle': this.onAccessibilityToggle
            });

            this._onKeyUp = _.bind(this.onKeyUp, this);
            this.setupEscapeKey();
        },

        setupEscapeKey: function() {
            var hasAccessibility = Adapt.config.has('_accessibility') && Adapt.config.get('_accessibility')._isActive;

            if (!hasAccessibility && ! this.escapeKeyAttached) {
                $(window).on('keyup', this._onKeyUp);
                this.escapeKeyAttached = true;
            } else {
                $(window).off('keyup', this._onKeyUp);
                this.escapeKeyAttached = false;
            }
        },

        onAccessibilityToggle: function() {
            this.setupEscapeKey();
        },

        onKeyUp: function(event) {
            if (event.which != 27) return;
            event.preventDefault();

            this.cancelNotify();
        },

        events: {
            'click .notify-popup-alert-button':'onAlertButtonClicked',
            'click .notify-popup-prompt-button': 'onPromptButtonClicked',
            'click .notify-popup-done': 'onCloseButtonClicked',
            'click .notify-shadow': 'onShadowClicked'
        },

        render: function() {
            var data = this.model.toJSON();
            var template = Handlebars.templates['notify'];

            //hide notify container
            this.$el.css('visibility', 'hidden');
            //attach popup + shadow
            this.$el.html(template(data)).prependTo('body');
            //hide popup
            this.$('.notify-popup').css('visibility', 'hidden');
            //show notify container
            this.$el.css('visibility', 'visible');

            this.showNotify();
            return this;
        },

        onAlertButtonClicked: function(event) {
            event.preventDefault();
            //tab index preservation, notify must close before subsequent callback is triggered
            this.closeNotify();
            Adapt.trigger(this.model.get('_callbackEvent'), this);
        },

        onPromptButtonClicked: function(event) {
            event.preventDefault();
            //tab index preservation, notify must close before subsequent callback is triggered
            this.closeNotify();
            Adapt.trigger($(event.currentTarget).attr('data-event'), this);
        },

        onCloseButtonClicked: function(event) {
            event.preventDefault();
            //tab index preservation, notify must close before subsequent callback is triggered
            this.cancelNotify();
        },

        onShadowClicked: function(event) {
            event.preventDefault();
            if (this.model.get("_closeOnShadowClick") === false) return;
            this.cancelNotify();
        },

        cancelNotify: function() {
            if (this.model.get("_isCancellable") === false) return;
            //tab index preservation, notify must close before subsequent callback is triggered
            this.closeNotify();
            Adapt.trigger('notify:cancelled', this);
        },

        resetNotifySize: function() {
            $('.notify-popup').removeAttr('style');

            this.resizeNotify();
        },

        resizeNotify: function() {
            var windowHeight = $(window).height();
            var notifyHeight = this.$('.notify-popup').outerHeight();

            if (notifyHeight > windowHeight) {
                this.$('.notify-popup').css({
                    'height':'100%',
                    'top':0,
                    'overflow-y': 'scroll',
                    '-webkit-overflow-scrolling': 'touch'
                });
            } else {
                this.$('.notify-popup').css({
                    'margin-top': -(notifyHeight/2)
                });
            }
        },

        showNotify: function() {
            this.isOpen = true;
            this.addSubView();

            Adapt.trigger('notify:opened', this);

            this.$el.imageready( _.bind(loaded, this));

            function loaded() {
                if (this.disableAnimation) {
                    this.$('.notify-shadow').css('display', 'block');
                } else {

                    this.$('.notify-shadow').velocity({ opacity: 0 }, {duration:0}).velocity({ opacity: 1 }, {duration:400, begin: _.bind(function() {
                        this.$('.notify-shadow').css('display', 'block');
                    }, this)});

                }

                this.resizeNotify();

                if (this.disableAnimation) {

                    this.$('.notify-popup').css('visibility', 'visible');
                    complete.call(this);

                } else {

                    this.$('.notify-popup').velocity({ opacity: 0 }, {duration:0}).velocity({ opacity: 1 }, { duration:400, begin: _.bind(function() {
                        this.$('.notify-popup').css('visibility', 'visible');
                        complete.call(this);
                    }, this) });

                }

                function complete() {
                    /*ALLOWS POPUP MANAGER TO CONTROL FOCUS*/
                    Adapt.trigger('popup:opened', this.$('.notify-popup'));
                    $('body').scrollDisable();
                    $('html').addClass('notify');

                    //set focus to first accessible element
                    this.$('.notify-popup').a11y_focus();
                }
            }

        },

        addSubView: function() {

            this.subView = this.model.get("_view");
            if (!this.subView) return;

            this.$(".notify-popup-content-inner").append(this.subView.$el);

        },

        closeNotify: function (event) {
            //prevent from being invoked multiple times - see https://github.com/adaptlearning/adapt_framework/issues/1659
            if (!this.isOpen) return;
            this.isOpen = false;

            if (this.disableAnimation) {

                this.$('.notify-popup').css('visibility', 'hidden');
                this.$el.css('visibility', 'hidden');

                this.remove();

            } else {

                this.$('.notify-popup').velocity({ opacity: 0 }, {duration:400, complete: _.bind(function() {
                    this.$('.notify-popup').css('visibility', 'hidden');
                }, this)});

                this.$('.notify-shadow').velocity({ opacity: 0 }, {duration:400, complete:_.bind(function() {
                    this.$el.css('visibility', 'hidden');
                    this.remove();
                }, this)});
            }

            $('body').scrollEnable();
            $('html').removeClass('notify');

            Adapt.trigger('popup:closed');
            Adapt.trigger('notify:closed', this);
        },

        remove: function() {
            this.removeSubView();
            Backbone.View.prototype.remove.apply(this, arguments);
        },

        removeSubView: function() {

            if (!this.subView) return;
            this.subView.remove();
            this.subView = null;

        }

    });

    return NotifyView;

});

define('core/js/views/notifyPushView',[
    'core/js/adapt'
], function (Adapt) {

    var NotifyPushView = Backbone.View.extend({

        className: function () {
            return 'notify-push ' + this.model.get('_classes');
        },

        initialize: function () {
            this.listenTo(Adapt, 'notify:pushShown notify:pushRemoved', this.updateIndexPosition);
            this.listenTo(this.model.collection, 'remove', this.updateIndexPosition);
            this.listenTo(this.model.collection, 'change:_index', this.updatePushPosition);
            this.listenTo(Adapt, 'remove', this.remove);

            // Include accessibility globals in notify model.
            this.model.set('_globals', Adapt.course.get('_globals'));

            this.preRender();
            this.render();
        },

        events: {
            'click .notify-push-close': 'closePush',
            'click .notify-push-inner': 'triggerEvent'
        },

        preRender: function () {
            this.hasBeenRemoved = false;
        },

        render: function () {
            var data = this.model.toJSON();
            var template = Handlebars.templates['notifyPush'];
            this.$el.html(template(data)).appendTo('#wrapper');

            _.defer(_.bind(function () {
                this.postRender();
            }, this));

            return this;
        },

        postRender: function () {
            this.$el.addClass('show');

            _.delay(_.bind(function () {
                this.closePush();
            }, this), this.model.get('_timeout'));

            Adapt.trigger('notify:pushShown');
        },

        closePush: function (event) {
            if (event) {
                event.preventDefault();
            }

            // Check whether this view has been removed as the delay can cause it to be fired twice
            if (this.hasBeenRemoved === false) {

                this.hasBeenRemoved = true;

                this.$el.removeClass('show');

                _.delay(_.bind(function () {
                    this.model.collection.remove(this.model);
                    Adapt.trigger('notify:pushRemoved', this);
                    this.remove();
                }, this), 600);
            }
        },

        triggerEvent: function (event) {
            Adapt.trigger(this.model.get('_callbackEvent'));
            this.closePush();
        },

        updateIndexPosition: function () {
            if (!this.hasBeenRemoved) {
                var models = this.model.collection.models;
                for (var i = 0, len = models.length; i < len; i++) {
                    var index = i;
                    var model = models[i];
                    if (model.get('_isActive') === true) {
                        model.set('_index', index);
                        this.updatePushPosition();
                    }
                }
            }
        },

        updatePushPosition: function () {
            if (this.hasBeenRemoved) {
                return;
            }

            if (this.model.get('_index') != undefined) {
                var elementHeight = this.$el.height();
                var offset = 20;
                var navigationHeight = $('.navigation').height();
                var currentIndex = this.model.get('_index');
                var flippedIndex = (currentIndex == 0) ? 1 : 0;

                if (this.model.collection.where({ _isActive: true }).length === 1) {
                    flippedIndex = 0;
                }

                var positionLowerPush = (elementHeight + offset) * flippedIndex + navigationHeight + offset;
                this.$el.css('top', positionLowerPush);
            }
        }
    });

    return NotifyPushView;

});

define('core/js/models/notifyModel',[],function() {

    var NotifyModel = Backbone.Model.extend({
        defaults: {
        	_isActive:false,
        	_showIcon:false,
        	_timeout:3000
        }
    });

    return NotifyModel;

});

define('core/js/notify',[
	'core/js/adapt',
	'core/js/views/notifyView',
	'core/js/views/notifyPushView',
	'core/js/models/notifyModel'
], function(Adapt, NotifyView, NotifyPushView, NotifyModel) {

	// Build a collection to store push notifications
	var NotifyPushCollection = Backbone.Collection.extend({

		model: NotifyModel,

		initialize: function() {
			this.listenTo(this, 'add', this.onPushAdded);
			this.listenTo(Adapt, 'notify:pushRemoved', this.onRemovePush);
		},

		onPushAdded: function(model) {
			this.checkPushCanShow(model);
		},

		checkPushCanShow: function(model) {
			if (this.canShowPush()) {
				model.set('_isActive', true);
				this.showPush(model);
			}
		},

		canShowPush: function() {
			var availablePushNotifications = this.where({_isActive:true});
			if (availablePushNotifications.length >= 2) {
				return false;
			}
			return true;
		},

		showPush: function(model) {
			new NotifyPushView({
				model: model
			});
		},

		onRemovePush: function(view) {
			var inactivePushNotifications = this.where({_isActive:false});
			if (inactivePushNotifications.length > 0) {
				this.checkPushCanShow(inactivePushNotifications[0]);
			}
		}

	});

	var NotifyPushes = new NotifyPushCollection();

	Adapt.on('notify:alert', function(notifyObject) {
		addNotifyView('alert', notifyObject);
	});

	Adapt.on('notify:prompt', function(notifyObject) {
		addNotifyView('prompt', notifyObject);
	});

	Adapt.on('notify:popup', function(notifyObject) {
		addNotifyView('popup', notifyObject);
	});

	Adapt.on('notify:push', function(notifyObject) {
		addNotifyView('push', notifyObject);
	});

	function addNotifyView(type, notifyObject) {
		// set default values 
		notifyObject._isCancellable = (notifyObject._isCancellable === undefined) 
			? true : notifyObject._isCancellable;
		
		notifyObject._showCloseButton = (notifyObject._showCloseButton === undefined) 
			? true : notifyObject._showCloseButton;

		notifyObject._closeOnShadowClick = (notifyObject._closeOnShadowClick === undefined) 
			? true : notifyObject._closeOnShadowClick;

		notifyObject._type = type;

		if (type === 'push') {

			NotifyPushes.push(notifyObject);

			return;

		}

		var notify = new NotifyView({
			model: new NotifyModel(notifyObject)
		});

	}

});

define('core/js/popupManager',[
    'core/js/adapt'
], function(Adapt) {

    Adapt.on('popup:opened', function($element) {

		//capture currently active element or element specified
        var $activeElement = $element || $(document.activeElement);

        //save tab indexes
        $activeElement.a11y_popup();
    });

    Adapt.on('popup:closed', function() {

        //restore tab indexes
        $.a11y_popdown();

    });

});

define('core/js/models/routerModel',[
    'core/js/adapt'
], function (Adapt) {

 	var RouterModel = Backbone.Model.extend({

 		defaults: {
 			_canNavigate: true
 		},

 		lockedAttributes: {
 			_canNavigate: false
 		}
 		
 	});

 	return RouterModel;

 });

define('core/js/views/adaptView',[
    'core/js/adapt'
], function(Adapt) {

    var AdaptView = Backbone.View.extend({

        attributes: function() {
            return {
                "data-adapt-id": this.model.get('_id')
            };
        },

        initialize: function() {
            this.listenTo(Adapt, 'remove', this.remove);
            this.listenTo(this.model, {
                'change:_isVisible': this.toggleVisibility,
                'change:_isHidden': this.toggleHidden,
                'change:_isComplete': this.onIsCompleteChange
            });
            this.model.set( {
                '_globals': Adapt.course.get('_globals'),
                '_isReady': false
            });
            this._isRemoved = false;
            this.preRender();
            this.render();
            this.setupOnScreenHandler();
        },

        preRender: function() {},

        postRender: function() {
            this.addChildren();
        },

        render: function() {
            Adapt.trigger(this.constructor.type + 'View:preRender', this);

            var data = this.model.toJSON();
            data.view = this;
            var template = Handlebars.templates[this.constructor.template];
            this.$el.html(template(data));

            _.defer(function() {
                // don't call postRender after remove
                if(this._isRemoved) return;

                this.postRender();
                Adapt.trigger(this.constructor.type + 'View:postRender', this);
            }.bind(this));

            return this;
        },

        setupOnScreenHandler: function() {
            var onscreen = this.model.get('_onScreen');

            if (!onscreen || !onscreen._isEnabled) return;

            this.$el.on('onscreen.adaptView', function (e, m) {

                if (!m.onscreen) return;

                var minVerticalInview = onscreen._percentInviewVertical || 33;

                if (m.percentInviewVertical < minVerticalInview) return;

                this.$el.addClass( onscreen._classes || 'onscreen' ).off('onscreen.adaptView');

            }.bind(this));
        },

        addChildren: function() {
            var nthChild = 0;
            var children = this.model.getChildren();
            var models = children.models;
            for (var i = 0, len = models.length; i < len; i++) {
                var model = models[i];
                if (model.get('_isAvailable')) {
                    nthChild ++;

                    var ChildView;
                    var ViewModelObject = this.constructor.childView || Adapt.componentStore[model.get("_component")];

                    //use view+model object
                    if (ViewModelObject.view) ChildView = ViewModelObject.view;
                    //use view only object
                    else ChildView = ViewModelObject;

                    if (ChildView) {
                        var $parentContainer = this.$(this.constructor.childContainer);
                        model.set("_nthChild", nthChild);
                        if (Adapt.config.get("_defaultDirection") == 'rtl' && model.get("_type") == 'component') {
                            $parentContainer.prepend(new ChildView({model:model}).$el);
                        } else {
                            $parentContainer.append(new ChildView({model:model}).$el);
                        }
                    } else {
                        throw 'The component \'' + models[i].attributes._id + '\'' +
                              ' (\'' + models[i].attributes._component + '\')' +
                              ' has not been installed, and so is not available in your project.';
                    }
                }
            }
        },

        setReadyStatus: function() {
            this.model.set('_isReady', true);
        },

        setCompletionStatus: function() {
            if (this.model.get('_isVisible')) {
                this.model.set({
                    '_isComplete': true,
                    '_isInteractionComplete': true
                });
            }
        },

        resetCompletionStatus: function(type) {
            if (!this.model.get("_canReset")) return;

            var descendantComponents = this.model.findDescendantModels('components');
            if (descendantComponents.length === 0) {
                this.model.reset(type);
            } else {
                _.each(descendantComponents, function(model) {
                    model.reset(type);
                });
            }
        },

        preRemove: function() {},

        remove: function() {

            this.preRemove();
            this._isRemoved = true;

            Adapt.wait.for(function(end) {

                this.$el.off('onscreen.adaptView');
                this.model.setOnChildren('_isReady', false);
                this.model.set('_isReady', false);
                Backbone.View.prototype.remove.call(this);

                end();
            }.bind(this));

            return this;
        },

        setVisibility: function() {
            var visible = "visibility-hidden";
            if (this.model.get('_isVisible')) {
                visible = "";
            }
            return visible;
        },

        toggleVisibility: function() {
            if (this.model.get('_isVisible')) {
                return this.$el.removeClass('visibility-hidden');
            }
            this.$el.addClass('visibility-hidden');
        },

        setHidden: function() {
            var hidden = "";
            if (this.model.get('_isHidden')) {
                hidden = "display-none";
            }
            return hidden;
        },

        toggleHidden: function() {
            if (!this.model.get('_isHidden')) {
                return this.$el.removeClass('display-none');
            }
            this.$el.addClass('display-none');
        },
        
        onIsCompleteChange:function(model, isComplete){
            this.$el.toggleClass('completed', isComplete);
        }
    });

    return AdaptView;

});

define('core/js/views/blockView',[
    'core/js/views/adaptView'
], function(AdaptView) {

    var BlockView = AdaptView.extend({

        className: function() {
            return "block " + 
            this.model.get('_id') +
            " " + this.model.get('_classes') + 
            " " + this.setVisibility() +
            " " + this.setHidden() +
            " nth-child-" +
            this.model.get("_nthChild") +
            " " + (this.model.get('_isComplete') ? 'completed' : '');
        }

    }, {
        childContainer: '.component-container',
        type: 'block',
        template: 'block'
    });

    return BlockView;

});

define('core/js/views/articleView',[
    'core/js/views/adaptView',
    'core/js/views/blockView'
], function(AdaptView, BlockView) {

    var ArticleView = AdaptView.extend({
        
        className: function() {
            return "article " +
            this.model.get('_id') +
            " " + this.model.get('_classes') +
            " " + this.setVisibility() +
            " " + this.setHidden() +
            " nth-child-" +
            this.model.get("_nthChild") +
            " " + (this.model.get('_isComplete') ? 'completed' : '');
        }

    }, {
        childContainer: '.block-container',
        childView: BlockView,
        type: 'article',
        template: 'article'
    });

    return ArticleView;

});

define('core/js/views/pageView',[
    'core/js/adapt',
    'core/js/views/adaptView',
    'core/js/views/articleView'
], function(Adapt, AdaptView, ArticleView) {

    var PageView = AdaptView.extend({
        
        className: function() {
            return "page " + 
            this.model.get('_id') + 
            " " + this.model.get('_classes') + 
            " " + this.setVisibility() +
            " " + (this.model.get('_isComplete') ? 'completed' : '');
        },

        preRender: function() {
            this.disableAnimation = Adapt.config.has('_disableAnimation') ? Adapt.config.get('_disableAnimation') : false;
            this.$el.css('opacity', 0);
            this.listenTo(this.model, 'change:_isReady', this.isReady);

            var accessibility = Adapt.config.get('_accessibility');
            if (!accessibility._isEnabled && !accessibility._isEnabledOnTouchDevices) {
                return;
            }
            // create aria-label outside of #wrapper
            this.$pageLabel = $('<div/>', {
                'class': 'aria-label relative a11y-ignore-focus prevent-default',
                tabindex: 0,
                role: 'region',
                text: Adapt.course.get('_globals')._accessibility._ariaLabels.pageEnd
            }).appendTo('body');
        },

        isReady: function() {
            if (this.model.get('_isReady')) {
                _.defer(_.bind(function() {
                    $('.loading').hide();
                    $(window).scrollTop(0);
                    Adapt.trigger('pageView:ready', this);
                    var styleOptions = { opacity: 1 };
                    if (this.disableAnimation) {
                        this.$el.css(styleOptions);
                        $.inview();
                    } else {
                        this.$el.velocity(styleOptions, {
                            duration: 'fast',
                            complete: function() {
                                $.inview();
                            }
                        });
                    }
                    $(window).scroll();
                }, this));
            }
        },

        remove: function() {
            if (this.$pageLabel) {
                this.$pageLabel.remove();
            }
            AdaptView.prototype.remove.call(this);
        }

    }, {
        childContainer: '.article-container',
        childView: ArticleView,
        type: 'page',
        template: 'page'
    });

    return PageView;

});

define('core/js/router',[
    'core/js/adapt',
    'core/js/models/routerModel',
    'core/js/views/pageView',
    'core/js/startController'
], function(Adapt, RouterModel, PageView) {

    Adapt.router = new RouterModel(null, { reset: true });

    var Router = Backbone.Router.extend({

        // Flag to indicate if the router has tried to redirect to the current location.
        _isCircularNavigationInProgress: false,

        initialize: function() {
            this.showLoading();

            // Store #wrapper element and html to cache for later use.
            this.$wrapper = $('#wrapper');
            this.$html = $('html');

            Adapt.once('app:dataReady', function() {
                document.title = Adapt.course.get('title');
            });

            this.listenTo(Adapt, {
                'navigation:backButton': this.navigateToPreviousRoute,
                'navigation:homeButton': this.navigateToHomeRoute,
                'navigation:skipNavigation': this.skipNavigation,
                'navigation:parentButton': this.navigateToParent,
                'router:navigateTo': this.navigateToArguments
            });
        },

        routes: {
            '': 'handleRoute',
            'id/:id': 'handleRoute',
            ':pluginName(/*location)(/*action)': 'handleRoute'
        },

        pruneArguments: function(args) {
            var prunedArgs = _.toArray(args);

            if (prunedArgs.length !== 0) {
                // Remove any null arguments.
                prunedArgs = _.without(args, null);
            }

            return prunedArgs;
        },

        handleRoute: function() {
            var args = this.pruneArguments(arguments);
            
            if (Adapt.router.get('_canNavigate')) {
                // Reset _isCircularNavigationInProgress protection as code is allowed to navigate away.
                this._isCircularNavigationInProgress = false;
            }

            // Check if the current page is in the process of navigating to itself.
            // It will redirect to itself if the URL was changed and _canNavigate is false.
            if (this._isCircularNavigationInProgress === false) {
                // Trigger an event pre 'router:location' to allow extensions to stop routing.
                Adapt.trigger('router:navigate', args);
            }

            // Re-check as _canNavigate can be set to false on 'router:navigate' event.
            if (Adapt.router.get('_canNavigate')) {
                // Disable navigation whilst rendering.
                Adapt.router.set('_canNavigate', false, { pluginName: 'adapt' });

                switch (args.length) {
                    case 1:
                        // If only one parameter assume it's the ID.
                        return this.handleId.apply(this, args);
                    case 2:
                        // If there are two parameters assume it's a plugin.
                        return this.handlePluginRouter.apply(this, args);
                    default:
                        // Route to course home page.
                        return this.handleCourse();
                }
            }

            if (this._isCircularNavigationInProgress) {
                // Navigation correction finished.
                // Router has successfully re-navigated to the current _id as the URL was changed 
                // while _canNavigate: false
                this._isCircularNavigationInProgress = false;
                return;
            }

            // Cancel navigation to stay at the current location.
            this._isCircularNavigationInProgress = true;
            Adapt.trigger('router:navigationCancelled', args);

            // Reset URL to the current one.
            this.navigateToCurrentRoute(true);
        },

        handlePluginRouter: function(pluginName, location, action) {
            var pluginLocation = pluginName;

            if (location) {
                pluginLocation = pluginLocation + '-' +location;

                if (action) {
                    pluginLocation = pluginLocation + '-' + action;
                }
            }

            this.updateLocation(pluginLocation, null, null, function() {
                Adapt.trigger('router:plugin:' + pluginName, pluginName, location, action);
                Adapt.trigger('router:plugin', pluginName, location, action);

                Adapt.router.set('_canNavigate', true, { pluginName: 'adapt' });
            });
        },

        handleCourse: function() {
            if (Adapt.course.has('_start')) {
                // Do not allow access to the menu when the start controller is enabled.
                var startController = Adapt.course.get('_start');

                if (startController._isEnabled == true && startController._isMenuDisabled == true) {
                    return;
                }
            }

            this.showLoading();

            this.removeViews(_.bind(function() {
                Adapt.course.set('_isReady', false);

                this.setContentObjectToVisited(Adapt.course);
                
                this.updateLocation('course', null, null, _.bind(function() {
                    Adapt.once('menuView:ready', function() {
                        // Allow navigation.
                        Adapt.router.set('_canNavigate', true, { pluginName: 'adapt' });
                    });

                    Adapt.trigger('router:menu', Adapt.course);
                }, this));
            }, this));
        },

        handleId: function(id) {
            var currentModel = Adapt.findById(id);
            var type = '';

            if (!currentModel) {
                Adapt.router.set('_canNavigate', true, { pluginName: 'adapt' });
                return;
            }

            type = currentModel.get('_type');

            switch (type) {
                case 'page':
                case 'menu':
                    if (currentModel.get('_isLocked') && Adapt.config.get('_forceRouteLocking')) {
                        Adapt.log.warn('Unable to navigate to locked id: ' + id);
                        Adapt.router.set('_canNavigate', true, {pluginName: 'adapt'});
                        if (Adapt.location._previousId === undefined) {
                            return this.navigate('#/', { trigger: true, replace: true });
                        } else {
                            return Backbone.history.history.back();
                        }
                    } else {
                        this.showLoading();
                        this.removeViews(_.bind(function() {

                            this.setContentObjectToVisited(currentModel);

                            if (type == 'page') {
                                var location = 'page-' + id;
                                this.updateLocation(location, 'page', id, _.bind(function() {
                                    Adapt.once('pageView:ready', function() {
                                        // Allow navigation.
                                        Adapt.router.set('_canNavigate', true, { pluginName: 'adapt' });
                                    });
                                    Adapt.trigger('router:page', currentModel);
                                    this.$wrapper.append(new PageView({ model: currentModel }).$el);
                                }, this));
                            } else {
                                var location = 'menu-' + id;
                                this.updateLocation(location, 'menu', id, _.bind(function() {
                                    Adapt.once('menuView:ready', function() {
                                        // Allow navigation.
                                        Adapt.router.set('_canNavigate', true, { pluginName: 'adapt' });
                                    });
                                    Adapt.trigger('router:menu', currentModel);
                                }, this));
                            }
                        }, this));
                    }
                    break;
                default:
                    // Allow navigation.
                    Adapt.router.set('_canNavigate', true, { pluginName: 'adapt' });
                    Adapt.navigateToElement('.' + id, { replace: true });
            }
        },

        removeViews: function(onComplete) {
            Adapt.remove();

            Adapt.wait.queue(onComplete);
        },

        showLoading: function() {
            $('.loading').show();
        },

        navigateToArguments: function(args) {
            args = this.pruneArguments(args);

            var options = { trigger: false, replace: false };

            switch (args.length) {
                case 0:
                    this.navigate('#/', options);
                    break;
                case 1:
                    if (Adapt.findById(args[0])) {
                        this.navigate('#/id/' + args[0], options);
                    } else {
                        this.navigate('#/' + args[0], options);
                    }
                    break;
                case 2:
                case 3:
                    this.navigate('#/' + args.join('/'), options);
                    break;
                default:
                    Adapt.log.warn('DEPRECATED - use Backbone.history.navigate or ' +
                        'window.location.href instead of Adapt.trigger("router:navigateTo")');
                    this.handleRoute.apply(this, args);
            }
        },

        skipNavigation: function() {
             $('.' + Adapt.location._contentType).a11y_focus();
        },

        navigateToPreviousRoute: function(force) {
            // Sometimes a plugin might want to stop the default navigation.
            // Check whether default navigation has changed.
            if (Adapt.router.get('_canNavigate') || force) {
                if (!Adapt.location._currentId) {
                    return Backbone.history.history.back();
                }
                if (Adapt.location._previousContentType === 'page' && Adapt.location._contentType === 'menu') {
                    return this.navigateToParent();
                }
                if (Adapt.location._previousContentType === 'page') {
                    return Backbone.history.history.back();
                }
                if (Adapt.location._currentLocation === 'course') {
                    return;
                }
                this.navigateToParent();
            }
        },

        navigateToHomeRoute: function(force) {
            if (Adapt.router.get('_canNavigate') || force ) {
                this.navigate('#/', { trigger: true });
            }
        },

        navigateToCurrentRoute: function(force) {
            if (Adapt.router.get('_canNavigate') || force) {
                if (!Adapt.location._currentId) {
                    return;
                }
                var currentId = Adapt.location._currentId;
                var route = (currentId === Adapt.course.get('_id')) ? '#/' : '#/id/' + currentId;
                this.navigate(route, { trigger: true, replace: true });
            }
        },

        navigateToParent: function(force) {
            if (Adapt.router.get('_canNavigate') || force) {
                var parentId = Adapt.contentObjects.findWhere({ _id: Adapt.location._currentId }).get('_parentId');
                var route = (parentId === Adapt.course.get('_id')) ? '#/' : '#/id/' + parentId;
                this.navigate(route, { trigger: true });
            }
        },

        setContentObjectToVisited: function(model) {
            model.set('_isVisited', true);
        },

        updateLocation: function(currentLocation, type, id, onComplete) {
            // Handles updating the location.
            Adapt.location._previousId = Adapt.location._currentId;
            Adapt.location._previousContentType = Adapt.location._contentType;

            if (currentLocation === 'course') {
                Adapt.location._currentId = Adapt.course.get('_id');
                Adapt.location._contentType = 'menu';
                Adapt.location._lastVisitedMenu = currentLocation;
            } else if (!type) {
                Adapt.location._currentId = null;
                Adapt.location._contentType = null;
            } else if (_.isString(id)) {
                Adapt.location._currentId = id;
                Adapt.location._contentType = type;

                if (type === 'menu') {
                    Adapt.location._lastVisitedType = 'menu';
                    Adapt.location._lastVisitedMenu = id;
                } else if (type === 'page') {
                    Adapt.location._lastVisitedType = 'page';
                    Adapt.location._lastVisitedPage = id;
                }
            }

            Adapt.location._currentLocation = currentLocation;

            var classes = (Adapt.location._currentId) ? 'location-'
                    + Adapt.location._contentType
                    + ' location-id-'
                    + Adapt.location._currentId :
                    'location-' + Adapt.location._currentLocation;

            var previousClasses = Adapt.location._previousClasses;
            if (previousClasses) {
                this.$html.removeClass(previousClasses);
            }
            Adapt.location._previousClasses = classes;

            this.$html
                .addClass(classes)
                .attr('data-location', Adapt.location._currentLocation);
                
            this.$wrapper
                .removeClass()
                .addClass(classes)
                .attr('data-location', Adapt.location._currentLocation);

            this.setDocumentTitle();

            // Trigger event when location changes.
            Adapt.trigger('router:location', Adapt.location);

            Adapt.wait.queue(onComplete);
        },

        setDocumentTitle: function() {
            if (!Adapt.location._currentId) return;

            var currentModel = Adapt.findById(Adapt.location._currentId);
            var pageTitle = '';

            if (currentModel && currentModel.get('_type') !== 'course') {
                var currentTitle = currentModel.get('title');
                
                if (currentTitle) {
                    pageTitle = ' | ' + currentTitle;
                }
            }

            var courseTitle = Adapt.course.get('title');
            var documentTitle = $('<div>' + courseTitle + pageTitle + '</div>').text();

            Adapt.once('pageView:ready menuView:ready', function() {
                document.title = documentTitle;
            });
        }
    });

    return new Router({ model: new Backbone.Model() });

});

define('core/js/helpers',[
    'handlebars',
    'core/js/adapt'
], function(Handlebars, Adapt){

    var helpers = {

        lowercase: function(text) {
            return text.toLowerCase();
        },

        capitalise:  function(text) {
            return text.charAt(0).toUpperCase() + text.slice(1);
        },

        inc: function(index) {
            return index+1;
        },

        dec: function(index) {
            return index-1;
        },

        odd: function (index) {
            return (index +1) % 2 === 0  ? 'even' : 'odd';
        },

        equals: function(value, text, block) {
            return helpers.compare.call(this, value, "==", text, block);
        },

        compare: function(value, operator, text, block) {
            // Comparison operators
            switch (operator) {
            case "===":
                if (value === text) return block.fn(this);
                break;
            case "=": case "==":
                if (value == text) return block.fn(this);
                break;
            case ">=":
                if (value >= text) return block.fn(this);
                break;
            case "<=":
                if (value <= text) return block.fn(this);
                break;
            case ">":
                if (value > text) return block.fn(this);
                break;
            case "<":
                if (value < text) return block.fn(this);
                break;
            }
            return block.inverse(this);
        },

        math: function(lvalue, operator, rvalue, options) {
            // Mathematical operators
            lvalue = parseFloat(lvalue);
            rvalue = parseFloat(rvalue);
            switch (operator) {
            case "+": return lvalue + rvalue;
            case "-": return lvalue - rvalue;
            case "*": return lvalue * rvalue;
            case "/": return lvalue / rvalue;
            case "%": return lvalue % rvalue;
            }
        },
        
        /**
         * Equivalent to:
         *  if (conditionA || conditionB)
         * @example
         * {{#any displayTitle body instruction}}
         * <div class="component__header {{_component}}__header"></div>
         * {{/any}}
         */
        any: function() {
            var args = Array.prototype.slice.call(arguments, 0, -1);
            var block = Array.prototype.slice.call(arguments, -1)[0];

            return _.any(args) ? block.fn(this) : block.inverse(this);
        },

        /**
         * Equivalent to:
         *  if (conditionA && conditionB)
         * @example
         * {{#all displayTitle body instruction}}
         * <div class="component__header {{_component}}__header"></div>
         * {{/all}}
         */
        all: function() {
            var args = Array.prototype.slice.call(arguments, 0, -1);
            var block = Array.prototype.slice.call(arguments, -1)[0];

            return _.all(args) ? block.fn(this) : block.inverse(this);
        },

        /**
         * Allow JSON to be a template i.e. you can use handlebars {{expressions}} within your JSON
         */
        compile: function(template, context) {
            if (!template) return "";
            if (template instanceof Object) template = template.toString();
            var data = this;
            if (context) {
                // choose between a passed argument context or the default handlebars helper context
                data = (!context.data || !context.data.root ? context : context.data.root);
            }
            return Handlebars.compile(template)(data);
        },

        /**
         * Allow JSON to be a template and accessible text
         */
        compile_a11y_text: function(template, context) {
            if (!template) return "";
            if (template instanceof Object) template = template.toString();
            return Handlebars.helpers.a11y_text.call(this, helpers.compile.call(this, template, context));
        },

        /**
         * Allow JSON to be a template and normalized text
         */
        compile_a11y_normalize: function(template, context) {
            if (!template) return "";
            if (template instanceof Object) template = template.toString();
            return Handlebars.helpers.a11y_normalize.call(this, helpers.compile.call(this, template, context));
        },

        /**
         * Remove all html tags except styling tags
         */
        compile_a11y_remove_breaks: function(template, context) {
            if (!template) return "";
            return Handlebars.helpers.a11y_remove_breaks.call(this, helpers.compile.call(this, template, context));
        },

        /**
         * makes the _globals object in course.json available to a template
         */
        import_globals: function(context) {
            if (context.data.root._globals) return "";
            context.data.root._globals = Adapt.course.get('_globals');
            return "";
        },

        /**
         * makes the Adapt module data available to a template
         */
        import_adapt: function(context) {

            if (context.data.root.Adapt) return;
            var adapt = context.data.root.Adapt = {};

            var i, l, name;

            var directImport = ['config','course'];
            for (i = 0, l = directImport.length; i < l; i++) {
                name = directImport[i];
                // convert the model to a json object and add to the current context
                adapt[name] = Adapt[name].toJSON();
            }

            var indexedImport = ['contentObjects','articles','blocks','components'];
            for (i = 0, l = indexedImport.length; i < l; i++) {
                name = indexedImport[i];
                // convert the collection of models to an array of json objects
                var importArray = Adapt[name].toJSON();
                // convert the array of json models to an object indexed by id
                var importIndex = {};
                for (var i1 = 0, l1 = importArray.length; i1 < l1; i1++) {
                    var item = importArray[i1];
                    importIndex[item._id] = item;
                }
                // add the indexed object to the current context
                adapt[name] = importIndex;
            }

            return "";

        }

    };

    // Compatibility references
    helpers['if_value_equals'] = helpers['equals'];
    helpers['numbers'] = helpers['inc'];
    helpers['lowerCase'] = helpers['lowercase'];

    for (var name in helpers) {
        if (helpers.hasOwnProperty(name)) {
             Handlebars.registerHelper(name, helpers[name]);
        }
    }

    return helpers;

});

define('core/js/views/componentView',[
    'core/js/adapt',
    'core/js/views/adaptView'
], function(Adapt, AdaptView) {

    var ComponentView = AdaptView.extend({

        className: function() {
            return [
                'component',
                this.model.get('_component') +'-component',
                this.model.get('_id'),
                this.model.get('_classes'),
                this.setVisibility(),
                this.setHidden(),
                'component-' + this.model.get('_layout'),
                'nth-child-' + this.model.get('_nthChild'),
                (this.model.get('_isComplete') ? 'completed' : '')
            ].join(' ');
        },

        initialize: function(){
			//standard initialization + renderState function
            AdaptView.prototype.initialize.apply(this, arguments);
            this.renderState();
        },

        /**
         * Allows components that want to use inview for completion to set that up
         * @param {string} [inviewElementSelector] Allows to you to specify (via a selector) which DOM element to use for inview.
         * Defaults to `'.component-inner'` if not supplied.
         * @param {function} [callback] Allows you to specify what function is called when the component has been viewed, should
         * you want to perform additional checks before setting the component to completed - see adapt-contrib-assessmentResults
         * for an example. Defaults to `view.setCompletionStatus` if not specified.
         */
        setupInviewCompletion: function(inviewElementSelector, callback) {
            this.$inviewElement = this.$(inviewElementSelector || '.component-inner');
            this.inviewCallback = (callback || this.setCompletionStatus);

            this.$inviewElement.on('inview.componentView', this.onInview.bind(this));
        },

        removeInviewListener: function() {
            if (!this.$inviewElement) return;
            this.$inviewElement.off('inview.componentView');
            this.$inviewElement = null;
        },

        onInview: function(event, visible, visiblePartX, visiblePartY) {
            if (!visible) return;

            switch (visiblePartY) {
                case 'top':
                    this.hasSeenTop = true;
                    break;
                case 'bottom':
                    this.hasSeenBottom = true;
                    break;
                case 'both':
                    this.hasSeenTop = this.hasSeenBottom = true;
            }

            if (!this.hasSeenTop || !this.hasSeenBottom) return;

            this.inviewCallback();

            if (this.model.get('_isComplete')) {
                this.removeInviewListener();
            }
        },

        renderState: function() {
            if (!Handlebars.partials['state']) return;

            // the preferred way to indicate that a state is not required
            if (this.model.get('_disableAccessibilityState')) return;
            // do not perform if component has .not-accessible class
            if (this.$el.is('.not-accessible')) return;
			// do not perform if component has .no-state class
            if (this.$el.is('.no-state')) return;

            var $previousState = this.$('.accessibility-state');
            var isStateRendered = $previousState.length;

            var data = _.extend(this.model.toJSON(), {a11yConfig: Adapt.config.get('_accessibility')});
            var element = Handlebars.partials['state'](data);

            if (isStateRendered) {
                $previousState.html(element);
            } else {
                this.$el.append(element);
            }

            this.listenToOnce(this.model, 'change:_isComplete', this.renderState);
        },

        postRender: function() {},

        remove: function() {
            this.removeInviewListener();

            AdaptView.prototype.remove.call(this);
        }

    }, {
        type:'component'
    });

    return ComponentView;

});

define('core/js/views/buttonsView',[
    'core/js/adapt',
    'core/js/enums/buttonStateEnum'
], function(Adapt, BUTTON_STATE) {

    //convert BUTTON_STATE to property name
    var textPropertyName = {
        "SUBMIT": "submit",
        "CORRECT": "correct",
        "INCORRECT": "incorrect",
        "SHOW_CORRECT_ANSWER": "showCorrectAnswer",
        "HIDE_CORRECT_ANSWER": "hideCorrectAnswer",
        "SHOW_FEEDBACK": "showFeedback",
        "RESET": "reset"
    };

    var ButtonsView = Backbone.View.extend({

        initialize: function(options) {
            this.parent = options.parent;

            this.listenTo(Adapt, 'remove', this.remove);
            this.listenTo(this.model, 'change:_buttonState', this.onButtonStateChanged);
            this.listenTo(this.model, 'change:feedbackMessage', this.onFeedbackMessageChanged);
            this.listenTo(this.model, 'change:_attemptsLeft', this.onAttemptsChanged);
            this.render();
        },

        events: {
            'click .buttons-action': 'onActionClicked',
            'click .buttons-feedback': 'onFeedbackClicked'
        },

        render: function() {
            var data = this.model.toJSON();
            var template = Handlebars.templates['buttons'];
            _.defer(_.bind(function() {
                this.postRender();
                Adapt.trigger('buttonsView:postRender', this);
            }, this));
            this.$el.html(template(data));
        },

        postRender: function() {
            this.refresh();
        },

        checkResetSubmittedState: function() {
            var isSubmitted = this.model.get('_isSubmitted');

            if (!isSubmitted) {

                var $icon = this.$('.buttons-marking-icon');
                $icon.removeClass('icon-cross');
                $icon.removeClass('icon-tick');
                $icon.addClass('display-none');
                this.$el.removeClass("submitted");
                this.model.set('feedbackMessage', undefined);
                this.$('.buttons-feedback').a11y_cntrl_enabled(false);

            } else {

                this.$el.addClass("submitted");

            }
        },

        onActionClicked: function() {
            var buttonState = this.model.get('_buttonState');
            this.trigger('buttons:stateUpdate', BUTTON_STATE(buttonState));
            this.checkResetSubmittedState();
        },

        onFeedbackClicked: function() {
            this.trigger('buttons:stateUpdate', BUTTON_STATE.SHOW_FEEDBACK);
        },

        onFeedbackMessageChanged: function(model, changedAttribute) {
            if (changedAttribute && this.model.get('_canShowFeedback')) {
                //enable feedback button
                this.$('.buttons-feedback').a11y_cntrl_enabled(true);
            } else {
                //disable feedback button
                this.$('.buttons-feedback').a11y_cntrl_enabled(false);
            }
        },

        onButtonStateChanged: function(model, changedAttribute) {
            // Use 'correct' instead of 'complete' to signify button state
            var buttonState = BUTTON_STATE(changedAttribute);
            if (changedAttribute === BUTTON_STATE.CORRECT || changedAttribute === BUTTON_STATE.INCORRECT) {
                // Both 'correct' and 'incorrect' states have no model answer, so disable the submit button
                this.$('.buttons-action').a11y_cntrl_enabled(false);

                if (!this.model.get("_canShowFeedback")) {
                    if (!this.$el.is(".no-state")) {
                        //if no feedback, complete correct and has state, force focus to component state
                        _.defer(_.bind(function() {
                            $("." + this.model.get("_id") + " .accessibility-state [tabindex]").focusNoScroll();
                        }, this));
                    }
                }
              
            } else {

                var propertyName = textPropertyName[buttonState.asString];
                var ariaLabel = this.model.get('_buttons')["_" + propertyName].ariaLabel;
                var buttonText = this.model.get('_buttons')["_" + propertyName].buttonText;

                // Enable the button, make accessible and update aria labels and text
                this.$('.buttons-action').a11y_cntrl_enabled(true).html(buttonText).attr('aria-label', ariaLabel);

                // Make model answer button inaccessible (but still enabled) for visual users due to
                // the inability to represent selected incorrect/correct answers to a screen reader, may need revisiting
                switch (changedAttribute) {
                    case BUTTON_STATE.SHOW_CORRECT_ANSWER:
                    case BUTTON_STATE.HIDE_CORRECT_ANSWER:
                        this.$('.buttons-action').a11y_cntrl(false);
                }

            }

            this.updateAttemptsCount();
        },

        checkFeedbackState: function(){
            var canShowFeedback = this.model.get('_canShowFeedback');

            this.$('.buttons-action').toggleClass('buttons-action-fullwidth buttons-action-enlarge', !canShowFeedback);
            this.$('.buttons-feedback').toggleClass('no-feedback', !canShowFeedback);
            this.$('.buttons-marking-icon').toggleClass('no-feedback', !canShowFeedback);
        },

        updateAttemptsCount: function(model, changedAttribute) {
            var isInteractionComplete = this.model.get('_isInteractionComplete');
            var attemptsLeft = (this.model.get('_attemptsLeft')) ? this.model.get('_attemptsLeft') : this.model.get('_attempts');
            var isCorrect = this.model.get('_isCorrect');
            var shouldDisplayAttempts = this.model.get('_shouldDisplayAttempts');
            var attemptsString;

            this.checkResetSubmittedState();

            if (!isInteractionComplete && attemptsLeft != 0) {
                attemptsString = attemptsLeft + " ";
                if (attemptsLeft > 1) {
                    attemptsString += this.model.get('_buttons').remainingAttemptsText;
                } else if (attemptsLeft === 1){
                    attemptsString += this.model.get('_buttons').remainingAttemptText;
                }

            } else {
                this.$('.buttons-display-inner').addClass('visibility-hidden');
                this.showMarking();
            }

            if (shouldDisplayAttempts) {
                this.$('.buttons-display-inner').a11y_text(attemptsString);
            }

        },

        showMarking: function() {
            if (!this.model.get('_canShowMarking')) return;

            this.$('.buttons-marking-icon')
                .removeClass('display-none')
                .addClass(this.model.get('_isCorrect') ? 'icon-tick' : 'icon-cross');
        },

        refresh: function() {
            this.updateAttemptsCount();
            this.checkResetSubmittedState();
            this.checkFeedbackState();
            this.onButtonStateChanged(null, this.model.get('_buttonState'));
            this.onFeedbackMessageChanged(null, this.model.get('feedbackMessage'));
        }

    });

    return ButtonsView;

});

define('core/js/views/questionView',[
    'core/js/adapt',
    'core/js/views/componentView',
    'core/js/views/buttonsView',
    'core/js/models/questionModel',
    'core/js/enums/buttonStateEnum'
], function(Adapt, ComponentView, ButtonsView, QuestionModel, BUTTON_STATE) {

    var useQuestionModelOnly = false;

    var QuestionView = ComponentView.extend({

        className: function() {
            return "component "
            + "question-component "
            + this.model.get('_component')
            + "-component " + this.model.get('_id')
            + " " + this.model.get('_classes')
            + " " + this.setVisibility()
            + " component-" + this.model.get('_layout')
            + " nth-child-" + this.model.get("_nthChild")
            + (this.model.get('_isComplete') ? ' completed' : '');
        },

        //////
        // Setup question types
        ////

        preRender: function() {
            // Setup listener for _isEnabled
            this.listenTo(this.model, 'change:_isEnabled', this.onEnabledChanged);

            this.listenTo(this.model, 'question:refresh', this.refresh);

            // Checks to see if the question should be reset on revisit
            this.checkIfResetOnRevisit();
            // This method helps setup default settings on the model
            this._runModelCompatibleFunction("setupDefaultSettings");
            // Blank method for setting up questions before rendering
            this.setupQuestion();

        },

        // Used in the question view to disabled the question when _isEnabled has been set to false
        onEnabledChanged: function(model, changedAttribute) {

            // If isEnabled == false add disabled class
            // else remove disabled class
            if (!changedAttribute) {
                this.$('.component-widget').addClass('disabled');
                this.disableQuestion();
            } else {
                this.$('.component-widget').removeClass('disabled');
                this.enableQuestion();
            }

        },

        // Used by the question to disable the question during submit and complete stages
        disableQuestion: function() {},

        // Used by the question to enable the question during interactions
        enableQuestion: function() {},

        // Used to check if the question should reset on revisit
        checkIfResetOnRevisit: function() {

            var isResetOnRevisit = this.model.get('_isResetOnRevisit');

            // If reset is enabled set defaults
            // Call blank method for question to handle
            if (isResetOnRevisit) {

                this.model.reset(isResetOnRevisit, true);

                 // Defer is added to allow the component to render
                _.defer(_.bind(function() {
                   this.resetQuestionOnRevisit(isResetOnRevisit);
                }, this));

            } else {

                // If complete - display users answer
                // or reset the question if not complete
                var isInteractionComplete = this.model.get('_isInteractionComplete');

                if (isInteractionComplete) {
                    this.model.set('_buttonState', BUTTON_STATE.HIDE_CORRECT_ANSWER);
                    // Defer is added to allow the component to render
                    _.defer(_.bind(function() {
                        this.onHideCorrectAnswerClicked();
                    }, this));

                } else {
                    this.model.set('_buttonState', BUTTON_STATE.SUBMIT);
                    // Defer is added to allow the component to render
                    _.defer(_.bind(function() {
                        this.onResetClicked();
                    }, this));
                }

            }

        },

        // Used by the question to reset the question when revisiting the component
        resetQuestionOnRevisit: function(type) {},

        // Left blank for question setup - should be used instead of preRender
        setupQuestion: function() {},

        // Calls default methods to setup after the question is rendered
        postRender: function() {
            this.addButtonsView();
            this.onQuestionRendered();
        },

        // Used to setup buttonsView and sets up the internal events for the question
        addButtonsView: function() {
            this.buttonsView = new ButtonsView({model: this.model, el: this.$('.buttons')});

            this.listenTo(this.buttonsView, 'buttons:stateUpdate', this.onButtonStateUpdate);

        },

        onButtonStateUpdate: function(button_state) {

            switch (button_state) {
                case BUTTON_STATE.SUBMIT:
                    this.onSubmitClicked();
                    break;
                case BUTTON_STATE.RESET:
                    this.onResetClicked();
                    break;
                case BUTTON_STATE.SHOW_CORRECT_ANSWER:
                    this.onShowCorrectAnswerClicked();
                    break;
                case BUTTON_STATE.HIDE_CORRECT_ANSWER:
                    this.onHideCorrectAnswerClicked();
                    break;
                case BUTTON_STATE.SHOW_FEEDBACK:
                    this.showFeedback();
                    break;
            }

        },

        // Blank method used just like postRender is for presentational components
        onQuestionRendered: function() {},

        //////
        // Submit process
        ////

        // Triggered when the submit button is clicked
        onSubmitClicked: function() {
            // canSubmit is setup in questions and should return a boolean
            // If the question stops the user form submitting - show instruction error
            // and give a blank method, onCannotSubmit to the question
            var canSubmit = this._runModelCompatibleFunction("canSubmit");

            if(!canSubmit) {
                this.showInstructionError();
                this.onCannotSubmit();
                return;
            }

            // Used to update the amount of attempts the question has
            this._runModelCompatibleFunction("updateAttempts");

            // Used to set attributes on the model after being submitted
            // Also adds a class of submitted
            this._runModelCompatibleFunction("setQuestionAsSubmitted");

            // Used to remove instruction error that is set when
            // the user has interacted in the wrong way
            this.removeInstructionError();

            // Used to store the users answer for later
            // This is a blank method given to the question
            this._runModelCompatibleFunction("storeUserAnswer");

            // Used to set question as correct:true/false
            // Calls isCorrect which is blank for the question
            // to fill out and return a boolean
            this._runModelCompatibleFunction("markQuestion", "isCorrect");

            // Used by the question to set the score on the model
            this._runModelCompatibleFunction("setScore");

            // Used by the question to display markings on the component
            this.showMarking();

            // Used to check if the question is complete
            // Triggers setCompletionStatus and adds class to widget
            this._runModelCompatibleFunction("checkQuestionCompletion");

            this.recordInteraction();

            // Used to setup the feedback by checking against
            // question isCorrect or isPartlyCorrect
            this._runModelCompatibleFunction("setupFeedback");

            // Used to update buttonsView based upon question state
            // Update buttons happens before showFeedback to preserve tabindexes and after setupFeedback to allow buttons to use feedback attribute
            this._runModelCompatibleFunction("updateButtons");

            // Used to trigger an event so plugins can display feedback
            this.showFeedback();

            this.onSubmitted();
        },

        // Adds a validation error class when the canSubmit returns false
        showInstructionError: function() {
            this.$(".component-instruction-inner").addClass("validation-error");
            this.$el.a11y_focus();
        },

        // Blank method for question to fill out when the question cannot be submitted
        onCannotSubmit: function() {},

        // Blank method for question to fill out when the question was successfully submitted
        onSubmitted: function() {},

        // Used to set _isEnabled and _isSubmitted on the model
        // Also adds a 'submitted' class to the widget
        setQuestionAsSubmitted: function() {
            this.model.setQuestionAsSubmitted();
            this.$(".component-widget").addClass("submitted");
        },

        // Removes validation error class when the user canSubmit
        removeInstructionError: function() {
            this.$(".component-instruction-inner").removeClass("validation-error");
        },

        // This is important and should give the user feedback on how they answered the question
        // Normally done through ticks and crosses by adding classes
        showMarking: function() {},

        // Checks if the question should be set to complete
        // Calls setCompletionStatus and adds complete classes
        checkQuestionCompletion: function() {

            var isComplete = this.model.checkQuestionCompletion();

            if (isComplete) {
                this.$('.component-widget').addClass('complete show-user-answer');
            }

        },

        recordInteraction:function() {
            if (this.model.get('_recordInteraction') === true || !this.model.has('_recordInteraction')) {
                Adapt.trigger('questionView:recordInteraction', this);
            }
        },

        // Used to show feedback based upon whether _canShowFeedback is true
        showFeedback: function() {

            if (this.model.get('_canShowFeedback')) {
                Adapt.trigger('questionView:showFeedback', this);
            } else {
                Adapt.trigger('questionView:disabledFeedback', this);
            }

        },

        onResetClicked: function() {
            this.setQuestionAsReset();

            this._runModelCompatibleFunction("updateButtons");

            this._runModelCompatibleFunction("resetUserAnswer");

            this.resetQuestion();
            if (this.model.get("_isReady")) {
                //if the model is already rendered, focus on the first tabbable element
                //onResetClicked is called as part of the checkIfResetOnRevisit function and as a button click
                _.defer(_.bind(function(){
                    this.$el.a11y_focus();
                }, this));
            }
        },

        setQuestionAsReset: function() {
            this.model.setQuestionAsReset();
            this.$(".component-widget").removeClass("submitted");

            // Attempt to get the current page location
            var currentModel = Adapt.findById(Adapt.location._currentId);
            if (currentModel && currentModel.get("_isReady")) {
                //if the page is ready, focus on the first tabbable item
                //otherwise will try to set focus as page loads and components are rendered
                this.$el.a11y_focus();
            }
        },

        // Used by the question view to reset the look and feel of the component.
        // This could also include resetting item data
        // This is triggered when the reset button is clicked so it shouldn't
        // be a full reset
        resetQuestion: function() {},

        refresh: function() {
            this.renderState();
            
            this.model.set('_buttonState', this.model.getButtonState());

            if (this.model.get('_canShowMarking') && this.model.get('_isInteractionComplete') && this.model.get('_isSubmitted')) {
                this.showMarking();
            }

            if (this.buttonsView) {
                _.defer(_.bind(this.buttonsView.refresh, this.buttonsView));
            }
        },

        onShowCorrectAnswerClicked: function() {
            this.setQuestionAsShowCorrect();

            this._runModelCompatibleFunction("updateButtons");

            this.showCorrectAnswer();
        },

        setQuestionAsShowCorrect: function() {
            this.$(".component-widget")
                .addClass("submitted show-correct-answer")
                .removeClass("show-user-answer");
        },

        // Used by the question to display the correct answer to the user
        showCorrectAnswer: function() {},

        onHideCorrectAnswerClicked: function() {
            this.setQuestionAsHideCorrect();

            this._runModelCompatibleFunction("updateButtons");

            this.hideCorrectAnswer();
        },

        setQuestionAsHideCorrect: function() {
            this.$(".component-widget")
                .addClass("submitted show-user-answer")
                .removeClass("show-correct-answer");
        },

        // Used by the question to display the users answer and
        // hide the correct answer
        // Should use the values stored in storeUserAnswer
        hideCorrectAnswer: function() {},

        // Time elapsed between the time the interaction was made available to the learner for response and the time of the first response
        getLatency:function() {
            return null;
        },

        // This function is overridden if useQuestionModeOnly: false. see below.
        _runModelCompatibleFunction: function(name, lookForViewOnlyFunction) {
            return this.model[name](); //questionModel Only
        }

    }, {
        _isQuestionType: true
    });


    //allows us to turn on and off the questionView style and use the separated questionModel+questionView style only
    if (useQuestionModelOnly) return QuestionView;

    /*BACKWARDS COMPATIBILITY SECTION
    * This section below is only for compatibility between the separated questionView+questionModel and the old questionView
    * Remove this section in when all components use questionModel and there is no need to have model behaviour in the questionView
    */

    var viewOnlyCompatibleQuestionView = {

        /* All of these functions have been moved to the questionModel.js file.
         * On the rare occasion that they have not been overridden by the component and
                that they call the view only questionView version,
                these functions are included as redirects to the new Question Model.
                It is very unlikely that these are needed but they are included to ensure compatibility.
         * If you need to override these in your component you should now make and register a component model.
         * Please remove them from your question component's view.
        */

            // Returns an object specific to the question type.
            getInteractionObject: function() {
                return this.model.getInteractionObject();
            },

            // Retturns a string detailing how the user answered the question.
            getResponse: function() {
                return this.model.getResponse();
            },

            // Returns a string describing the type of interaction: "choice" and "matching" supported (see scorm wrapper)
            getResponseType: function() {
                return this.model.getResponseType();
            },
            
            // Calls default methods to setup on questions
            setupDefaultSettings: function() {
                return this.model.setupDefaultSettings();
            },

            // Used to setup either global or local button text
            setupButtonSettings: function() {
                return this.model.setupButtonSettings();
            },

            // Used to setup either global or local question weight/score
            setupWeightSettings: function() {
                return this.model.setupWeightSettings();
            },

            // Use to check if the user is allowed to submit the question
            // Maybe the user has to select an item?
            canSubmit: function() {
                return this.model.canSubmit();
            },

            // Used to update the amount of attempts the user has left
            updateAttempts: function() {
                return this.model.updateAttempts();
            },

            // This is important for returning or showing the users answer
            // This should preserve the state of the users answers
            storeUserAnswer: function() {
                return this.model.storeUserAnswer();
            },

            // Used by the question view to reset the stored user answer
            resetUserAnswer: function() {
                return this.model.resetUserAnswer();
            },

            // Sets _isCorrect:true/false based upon isCorrect method below
            markQuestion: function() {

                if (this._isInViewOnlyCompatibleMode("isCorrect")) {

                    if (this.isCorrect()) {
                        this.model.set('_isCorrect', true);
                    } else {
                        this.model.set('_isCorrect', false);
                    }

                } else {
                    return this.model.markQuestion();
                }
            },

            // Should return a boolean based upon whether to question is correct or not
            isCorrect: function() {
                return this.model.isCorrect();
            },

            // Used to set the score based upon the _questionWeight
            setScore: function() {
                return this.model.setScore();
            },

            // Updates buttons based upon question state by setting
            // _buttonState on the model which buttonsView listens to
            updateButtons: function() {
                return this.model.updateButtons();
            },

            // Used to setup the correct, incorrect and partly correct feedback
            setupFeedback: function() {

                if (this._isInViewOnlyCompatibleMode("isPartlyCorrect")) {

                    // Use view based feedback where necessary
                    if (this.model.get('_isCorrect')) {
                        this._runModelCompatibleFunction("setupCorrectFeedback");
                    } else if (this.isPartlyCorrect()) {
                        this._runModelCompatibleFunction("setupPartlyCorrectFeedback");
                    } else {
                        this._runModelCompatibleFunction("setupIncorrectFeedback");
                    }

                } else {
                    // Use model based feedback
                    this.model.setupFeedback();
                }

            },

            // Used by the question to determine if the question is incorrect or partly correct
            // Should return a boolean
            isPartlyCorrect: function() {
                return this.model.isPartlyCorrect();
            },

            setupCorrectFeedback: function() {
                return this.model.setupCorrectFeedback();
            },

            setupPartlyCorrectFeedback: function() {
                return this.model.setupPartlyCorrectFeedback();
            },

            setupIncorrectFeedback: function() {
                return this.model.setupIncorrectFeedback();
            },


        //Helper functions for compatibility layer
        _runModelCompatibleFunction: function(name, lookForViewOnlyFunction) {
            if (this._isInViewOnlyCompatibleMode(name, lookForViewOnlyFunction)) {
                return this[name](); //questionView
            } else {
                return this.model[name](); //questionModel
            }
        },

        _isInViewOnlyCompatibleMode: function(name, lookForViewOnlyFunction) {
            //return false uses the model function questionModel
            //return true uses the view only function questionView

            var checkForFunction = (lookForViewOnlyFunction || name);

            //if the function does NOT exist on the view at all, use the model only
            if (!this.constructor.prototype[checkForFunction]) return false; //questionModel

            //if the function DOES exist on the view and MATCHES the compatibility function above, use the model only
            if (this.constructor.prototype[checkForFunction] === viewOnlyCompatibleQuestionView[checkForFunction])  {
                switch (checkForFunction) {
                    case "setupFeedback":
                    case "markQuestion": 
                        return true; //questionView
                }
                return false; //questionModel
            }

            //if the function DOES exist on the view and does NOT match the compatibility function above, use the view function
            return true; //questionView
        }

    };

    //return question view class extended with the compatibility layer
    return QuestionView.extend(viewOnlyCompatibleQuestionView, {
        _isQuestionType: true
    });

    /*END OF BACKWARDS COMPATIBILITY SECTION*/

});

define('components/adapt-contrib-mcq/js/mcqView',[
    'core/js/views/questionView'
], function(QuestionView) {

    var McqView = QuestionView.extend({

        events: {
            'focus .mcq-item input':'onItemFocus',
            'blur .mcq-item input':'onItemBlur',
            'change .mcq-item input':'onItemSelected',
            'keyup .mcq-item input':'onKeyPress'
        },

        resetQuestionOnRevisit: function() {
            this.setAllItemsEnabled(true);
            this.resetQuestion();
        },

        setupQuestion: function() {
            this.model.setupRandomisation();
        },

        disableQuestion: function() {
            this.setAllItemsEnabled(false);
        },

        enableQuestion: function() {
            this.setAllItemsEnabled(true);
        },

        setAllItemsEnabled: function(isEnabled) {
            _.each(this.model.get('_items'), function(item, index){
                var $itemLabel = this.$('label').eq(index);
                var $itemInput = this.$('input').eq(index);

                if (isEnabled) {
                    $itemLabel.removeClass('disabled');
                    $itemInput.prop('disabled', false);
                } else {
                    $itemLabel.addClass('disabled');
                    $itemInput.prop('disabled', true);
                }
            }, this);
        },

        onQuestionRendered: function() {
            this.setReadyStatus();
            if (!this.model.get("_isSubmitted")) return;
            this.showMarking();
        },

        onKeyPress: function(event) {
            if (event.which === 13) { //<ENTER> keypress
                this.onItemSelected(event);
            }
        },

        onItemFocus: function(event) {
            if(this.model.get('_isEnabled') && !this.model.get('_isSubmitted')){
                $("label[for='"+$(event.currentTarget).attr('id')+"']").addClass('highlighted');
            }
        },
        
        onItemBlur: function(event) {
            $("label[for='"+$(event.currentTarget).attr('id')+"']").removeClass('highlighted');
        },

        onItemSelected: function(event) {
            if(this.model.get('_isEnabled') && !this.model.get('_isSubmitted')){
                var selectedItemObject = this.model.get('_items')[$(event.currentTarget).parent('.component-item').index()];
                this.toggleItemSelected(selectedItemObject, event);
            }
        },

        toggleItemSelected:function(item, clickEvent) {
            var selectedItems = this.model.get('_selectedItems');
            var itemIndex = _.indexOf(this.model.get('_items'), item),
                $itemLabel = this.$('label').eq(itemIndex),
                $itemInput = this.$('input').eq(itemIndex),
                selected = !$itemLabel.hasClass('selected');
            
                if(selected) {
                    if(this.model.get('_selectable') === 1){
                        this.$('label').removeClass('selected');
                        this.$('input').prop('checked', false);
                        this.deselectAllItems();
                        selectedItems[0] = item;
                    } else if(selectedItems.length < this.model.get('_selectable')) {
                     selectedItems.push(item);
                 } else {
                    clickEvent.preventDefault();
                    return;
                }
                $itemLabel.addClass('selected');
            } else {
                selectedItems.splice(_.indexOf(selectedItems, item), 1);
                $itemLabel.removeClass('selected');
            }
            $itemInput.prop('checked', selected);
            item._isSelected = selected;
            this.model.set('_selectedItems', selectedItems);
        },

        // Blank method to add functionality for when the user cannot submit
        // Could be used for a popup or explanation dialog/hint
        onCannotSubmit: function() {},

        // This is important and should give the user feedback on how they answered the question
        // Normally done through ticks and crosses by adding classes
        showMarking: function() {
            if (!this.model.get('_canShowMarking')) return;

            _.each(this.model.get('_items'), function(item, i) {
                var $item = this.$('.component-item').eq(i);
                $item.removeClass('correct incorrect').addClass(item._isCorrect ? 'correct' : 'incorrect');
            }, this);
        },

        // Used by the question view to reset the look and feel of the component.
        resetQuestion: function() {
            this.deselectAllItems();
            this.resetItems();
        },

        deselectAllItems: function() {
            this.model.deselectAllItems();
        },

        resetItems: function() {
            this.$('.component-item label').removeClass('selected');
            this.$('.component-item').removeClass('correct incorrect');
            this.$('input').prop('checked', false);
            this.model.resetItems();
        },

        showCorrectAnswer: function() {
            _.each(this.model.get('_items'), function(item, index) {
                this.setOptionSelected(index, item._shouldBeSelected);
            }, this);
        },

        setOptionSelected:function(index, selected) {
            var $itemLabel = this.$('label').eq(index);
            var $itemInput = this.$('input').eq(index);
            if (selected) {
                $itemLabel.addClass('selected');
                $itemInput.prop('checked', true);
            } else {
                $itemLabel.removeClass('selected');
                $itemInput.prop('checked', false);
            }
        },

        hideCorrectAnswer: function() {
            _.each(this.model.get('_items'), function(item, index) {
                this.setOptionSelected(index, this.model.get('_userAnswer')[item._index]);
            }, this);
        }
    });

    return McqView;

});

define('components/adapt-contrib-mcq/js/mcqModel',[
    'core/js/models/questionModel'
], function(QuestionModel) {
    
    var McqModel = QuestionModel.extend({

        init: function() {
            QuestionModel.prototype.init.call(this);

            this.set("_isRadio", (this.get("_selectable") == 1) );
            
            this.set('_selectedItems', []);

            this.setupQuestionItemIndexes();
        },

        setupQuestionItemIndexes: function() {
            var items = this.get("_items");
            if (items && items.length > 0) {
                for (var i = 0, l = items.length; i < l; i++) {
                    if (items[i]._index === undefined) items[i]._index = i;
                }
            }
        },

        restoreUserAnswers: function() {
            if (!this.get("_isSubmitted")) return;

            var selectedItems = [];
            var items = this.get("_items");
            var userAnswer = this.get("_userAnswer");
            _.each(items, function(item, index) {
                item._isSelected = userAnswer[item._index];
                if (item._isSelected) {
                    selectedItems.push(item);
                }
            });

            this.set("_selectedItems", selectedItems);

            this.setQuestionAsSubmitted();
            this.markQuestion();
            this.setScore();
            //this.showMarking();
            this.setupFeedback();
        },

        setupRandomisation: function() {
            if (this.get('_isRandom') && this.get('_isEnabled')) {
                this.set("_items", _.shuffle(this.get("_items")));
            }
        },

        // check if the user is allowed to submit the question
        canSubmit: function() {
            var count = 0;

            _.each(this.get('_items'), function(item) {
                if (item._isSelected) {
                    count++;
                }
            }, this);

            return (count > 0) ? true : false;

        },

        // This is important for returning or showing the users answer
        // This should preserve the state of the users answers
        storeUserAnswer: function() {
            var userAnswer = [];

            var items = this.get('_items').slice(0);
            items.sort(function(a, b) {
                return a._index - b._index;
            });

            _.each(items, function(item, index) {
                userAnswer.push(item._isSelected);
            }, this);
            this.set('_userAnswer', userAnswer);
        },

        isCorrect: function() {

            var numberOfRequiredAnswers = 0;
            var numberOfCorrectAnswers = 0;
            var numberOfIncorrectAnswers = 0;

            _.each(this.get('_items'), function(item, index) {

                var itemSelected = (item._isSelected || false);

                if (item._shouldBeSelected) {
                    numberOfRequiredAnswers ++;

                    if (itemSelected) {
                        numberOfCorrectAnswers ++;
                        
                        item._isCorrect = true;

                        this.set('_isAtLeastOneCorrectSelection', true);
                    }

                } else if (!item._shouldBeSelected && itemSelected) {
                    numberOfIncorrectAnswers ++;
                }

            }, this);

            this.set('_numberOfCorrectAnswers', numberOfCorrectAnswers);
            this.set('_numberOfRequiredAnswers', numberOfRequiredAnswers);

            // Check if correct answers matches correct items and there are no incorrect selections
            var answeredCorrectly = (numberOfCorrectAnswers === numberOfRequiredAnswers) && (numberOfIncorrectAnswers === 0);
            return answeredCorrectly;
        },

        // Sets the score based upon the questionWeight
        // Can be overwritten if the question needs to set the score in a different way
        setScore: function() {
            var questionWeight = this.get("_questionWeight");
            var answeredCorrectly = this.get('_isCorrect');
            var score = answeredCorrectly ? questionWeight : 0;
            this.set('_score', score);
        },

        setupFeedback: function() {

            if (this.get('_isCorrect')) {
                this.setupCorrectFeedback();
            } else if (this.isPartlyCorrect()) {
                this.setupPartlyCorrectFeedback();
            } else {
                // apply individual item feedback
                if((this.get('_selectable') === 1) && this.get('_selectedItems')[0].feedback) {
                    this.setupIndividualFeedback(this.get('_selectedItems')[0]);
                    return;
                } else {
                    this.setupIncorrectFeedback();
                }
            }
        },

        setupIndividualFeedback: function(selectedItem) {
            // for compatibility with framework v2
            var title = this.getFeedbackTitle ?
                this.getFeedbackTitle(this.get('_feedback')) :
                this.get('title');

            this.set({
                feedbackTitle: title,
                feedbackMessage: selectedItem.feedback
            });
        },

        isPartlyCorrect: function() {
            return this.get('_isAtLeastOneCorrectSelection');
        },

        resetUserAnswer: function() {
            this.set({_userAnswer: []});
        },

        deselectAllItems: function() {
            _.each(this.get('_items'), function(item) {
                item._isSelected = false;
            }, this);
        },

        resetItems: function() {
            this.set({
                _selectedItems: [],
                _isAtLeastOneCorrectSelection: false
            });
        },

        getInteractionObject: function() {
            var interactions = {
                correctResponsesPattern: [],
                choices: []
            };

            interactions.choices = this.get('_items').map(function(item) {
                return {
                    id: (item._index + 1).toString(),
                    description: item.text
                };
            });

            var correctItems = _.filter(this.get('_items'), function(item) {
                return item._shouldBeSelected;
            });

            interactions.correctResponsesPattern = [
                _.pluck(correctItems, '_index')
                    .map(function(index) {
                        return (index + 1).toString();
                    })
                    .join('[,]')
            ];

            return interactions;
        },

        /**
        * used by adapt-contrib-spoor to get the user's answers in the format required by the cmi.interactions.n.student_response data field
        * returns the user's answers as a string in the format "1,5,2"
        */
        getResponse: function() {
            var selected = _.where(this.get('_items'), {_isSelected: true});
            var selectedIndexes = _.pluck(selected, '_index');
            // indexes are 0-based, we need them to be 1-based for cmi.interactions
            for (var i = 0, count = selectedIndexes.length; i < count; i++) {
                selectedIndexes[i]++;
            }
            return selectedIndexes.join(',');
        },

        /**
        * used by adapt-contrib-spoor to get the type of this question in the format required by the cmi.interactions.n.type data field
        */
        getResponseType: function() {
            return 'choice';
        }

    });

    return McqModel;

});

define('components/adapt-contrib-mcq/js/adapt-contrib-mcq',[
    'core/js/adapt',
    './mcqView',
    './mcqModel'
], function(Adapt, McqView, McqModel) {

    return Adapt.register("mcq", {
        view: McqView,
        model: McqModel
    });

});

define('components/adapt-contrib-gmcq/js/adapt-contrib-gmcq',[
    'coreJS/adapt',
    'components/adapt-contrib-mcq/js/adapt-contrib-mcq'
], function(Adapt, Mcq) {

    var Gmcq = Mcq.view.extend({

        events: {
            'focus .gmcq-item input': 'onItemFocus',
            'blur .gmcq-item input': 'onItemBlur',
            'change .gmcq-item input': 'onItemSelected',
            'keyup .gmcq-item input': 'onKeyPress'
        },

        onItemSelected: function(event) {

            var selectedItemObject = this.model.get('_items')[$(event.currentTarget).parent('.gmcq-item').index()];

            if (this.model.get('_isEnabled') && !this.model.get('_isSubmitted')) {
                this.toggleItemSelected(selectedItemObject, event);
            }

        },

        setupQuestion: function() {
            Mcq.view.prototype.setupQuestion.call(this);

            this.listenTo(Adapt, {
                'device:changed': this.resizeImage,
                'device:resize': this.onDeviceResize
            });

        },

        onQuestionRendered: function() {

            this.resizeImage(Adapt.device.screenSize);
            this.setUpColumns();

            this.$('label').imageready(_.bind(function() {
                this.setReadyStatus();
            }, this));

        },
        
        onDeviceResize: function() {
            this.setUpColumns();
        },

        resizeImage: function(width) {

            var imageWidth = width === 'medium' ? 'small' : width;

            this.$('label').each(function(index) {
                var src = $(this).find('img').attr('data-' + imageWidth);
                $(this).find('img').attr('src', src);
            });

        },

        setUpColumns: function() {
            var columns = this.model.get('_columns');

            if (!columns) return;

            if (Adapt.device.screenSize === 'large') {
                this.$el.addClass('gmcq-column-layout');
                this.$('.gmcq-item').css('width', (100 / columns) + '%');
            } else {
                this.$el.removeClass('gmcq-column-layout');
                this.$('.gmcq-item').css('width', '');
            }
        }

    }, {
        template: 'gmcq'
    });

    return Adapt.register("gmcq", {
        view: Gmcq,
        model: Mcq.model.extend({})
    });

});

define('components/adapt-contrib-hiddenHotspots/js/adapt-contrib-hiddenHotspotsItem.js',['require','backbone','coreJS/adapt'],function(require) {

    var Backbone = require('backbone');
    var Adapt = require('coreJS/adapt');

    var HiddenHotspotsItem = Backbone.View.extend({

        tagName: 'button',

        className: 'hidden-hotspots-pin',

        events: {
            'click': 'onItemClicked'
        },

        onItemClicked: function(event) {
            event.preventDefault();
            event.stopPropagation();
            if (this.componentModel.get("_isEnabled")) {
                this.model.set({
                    _hasBeenUsed: false,
                    _currentTop: 0,
                    _currentLeft: 0
                });
            }
        },

        initialize: function(options) {
            this.parentView = options.parentView;
            this.componentModel = options.componentModel;
            this.index = options.index;
            this.listenTo(Adapt, 'remove', this.remove);
            this.listenTo(this.model, 'change:_hasBeenUsed', this.onHasBeenUsed);
            this.listenTo(this.model, 'showMarking', this.onShowMarking);
            this.listenTo(this.model, 'hideMarking', this.onHideMarking);
            this.cleanUpModel();
            this.preRender()
            this.render();
        },

        cleanUpModel: function() {
            delete this.model.attributes._top;
            delete this.model.attributes._left;
            delete this.model.attributes._width;
            delete this.model.attributes._height;
        },

        preRender: function() {
            if (this.componentModel.get('_isSubmitted')) {
                this.onShowMarking();
            }
        },

        render: function() {
            var template = Handlebars.templates[this.constructor.template];
            this.$el.html(template(this.data));
            _.defer(_.bind(function() {
                this.postRender();
            }, this));
        },

        postRender: function() {
            this.showOrHideItem();
            this.listenTo(Adapt, 'device:resize', this.showOrHideItem);
        },

        onHasBeenUsed: function() {
            this.showOrHideItem();
        },

        showOrHideItem: function() {
            this.$graphic = this.parentView.$('.hidden-hotspots-graphic-container');
            
            if (this.model.get('_hasBeenUsed')) {
                // This component uses a mapping system based upon original image
                // widths and heights. The view layer positioning is faked based upon
                // the original positions on the images actual size
                var currentLeft = this.model.get('_currentLeft');
                var currentTop = this.model.get('_currentTop');

                var graphicWidth = this.$graphic.width();
                var graphicHeight = this.$graphic.height();

                var ratio = (1024/graphicWidth) * graphicHeight;

                var positionLeft = ((graphicWidth / 1024) * currentLeft) - 25;
                var positionTop = ((graphicHeight / ratio) * currentTop) - 25;

                this.$el.removeClass('display-none').css({
                    left: positionLeft,
                    top: positionTop
                });
            } else {
                this.$el.addClass('display-none');
            }

        },

        onShowMarking: function() {
            if (this.model.get('_isCorrect')) {
                this.$el.addClass('correct');
            } else {
                this.$el.addClass('incorrect');
            }
        },

        onHideMarking: function() {
            this.$el.removeClass('correct incorrect');
        }

    }, {
        template: 'hiddenHotspotsItem'
    });

    return HiddenHotspotsItem;

});
define('components/adapt-contrib-hiddenHotspots/js/adapt-contrib-hiddenHotspotsItemModel.js',['require','backbone'],function(require) {
    var Backbone = require('backbone');

    HiddenHotspotsItemModel = Backbone.Model.extend({

        defaults: {
            _hasBeenUsed: false
        }

    });

    return HiddenHotspotsItemModel;

});
define('components/adapt-contrib-hiddenHotspots/js/adapt-contrib-hiddenHotspotsZone.js',['require','backbone','coreJS/adapt'],function(require) {

    var Backbone = require('backbone');
    var Adapt = require('coreJS/adapt');

    var HiddenHotspotsZone = Backbone.View.extend({

        className: 'hidden-hotspots-zone',

        initialize: function(options) {
            this.parentView = options.parentView;
            this.listenTo(this.model, 'hideCorrectAnswer', this.onHideCorrectAnswer);
            this.preRender();
            this.render();
        },

        onHideCorrectAnswer: function() {
            this.remove();
        },

        preRender: function() {
            this.$graphic = this.parentView.$('.hidden-hotspots-graphic-container');
            this.setPosition();
        },

        render: function() {
            var template = Handlebars.templates[this.constructor.template];
            this.$el.html(template(this.data));
            _.defer(_.bind(function() {
                this.postRender();
            }, this));
        },

        postRender: function() {
            this.listenTo(Adapt, 'device:resize', this.setPosition);
        },
        
        setPosition: function() {
            var top = this.model.get('_top');
            var left = this.model.get('_left');
            var width = this.model.get('_width');
            var height = this.model.get('_height');

            var graphicWidth = this.$graphic.width();
            var graphicHeight = this.$graphic.height();

            var ratio = (1024/graphicWidth) * graphicHeight;

            var positionLeft = ((graphicWidth / 1024) * left);
            var positionTop = ((graphicHeight / ratio) * top);

            var ratioWidth = (graphicWidth/1024 * width);
            var ratioHeight = (graphicHeight/ratio * height);

            this.$el.css({
                left: positionLeft,
                top: positionTop,
                width: ratioWidth,
                height: ratioHeight
            });

        }

    }, {
        template: 'hiddenHotspotsZone'
    });

    return HiddenHotspotsZone;

});
define('components/adapt-contrib-hiddenHotspots/js/adapt-contrib-hiddenHotspots',['require','coreViews/questionView','coreJS/adapt','./adapt-contrib-hiddenHotspotsItem.js','./adapt-contrib-hiddenHotspotsItemModel.js','./adapt-contrib-hiddenHotspotsZone.js'],function(require) {

    var QuestionView = require('coreViews/questionView');
    var Adapt = require('coreJS/adapt');
    var HiddenHotspotsItem = require('./adapt-contrib-hiddenHotspotsItem.js');
    var HiddenHotspotsItemModel = require('./adapt-contrib-hiddenHotspotsItemModel.js');
    var HiddenHotspotsZone = require('./adapt-contrib-hiddenHotspotsZone.js');

    var HiddenHotspots = QuestionView.extend({

        events: {
            'click .hidden-hotspots-graphic-container': 'onGraphicClicked',
            'click .hidden-hotspots-mobile-navigation-left': 'onNavigationLeftClicked',
            'click .hidden-hotspots-mobile-navigation-right': 'onNavigationRightClicked'
        },
        // Interaction code
        onGraphicClicked: function(event) {
            event.preventDefault();
            event.stopPropagation();
            if (!this.model.get('_isEnabled')) {
                return;
            }

            var unusedItemModel = this.getAvailableItem();
            if (unusedItemModel) {
                // This component uses a mapping system based upon original image
                // widths and heights. The view layer positioning is faked based upon
                // the original positions on the images actual size
                var currentLeft = event.offsetX;
                var currentTop = event.offsetY;

                var graphicWidth = this.$graphic.width();
                var graphicHeight = this.$graphic.height();

                var ratio = (1024 / graphicWidth) * graphicHeight;

                var positionLeft = ((1024 / graphicWidth) * currentLeft);
                var positionTop = ((ratio / graphicHeight) * currentTop);
                unusedItemModel.set({
                    _hasBeenUsed: true,
                    _currentLeft: positionLeft,
                    _currentTop: positionTop
                });
            }
        },

        onNavigationLeftClicked: function(event) {
            event.preventDefault();
            var left = parseInt(this.$graphic.css('left'));
            var width = this.$widget.width();
            var availableSpace = 860 - width;

            if (left + (width - 40) > 0) {
                this.$graphic.animate({"left": "0"});
            } else {
                this.$graphic.animate({"left": "+=" + (width - 40)});
            }
        },

        onNavigationRightClicked: function(event) {
            event.preventDefault();
            var left = parseInt(this.$graphic.css('left'));
            var width = this.$widget.width();
            var availableSpace = 860 - width;

            if (-availableSpace + (width - 40) < left) {
                this.$graphic.animate({"left": "-=" + (width - 40)});
            } else {
                this.$graphic.animate({"left": -availableSpace});
            }

        },

        renderZones: function() {
            this.zones.each(function(itemModel, index) {
                this.$graphic.append(new HiddenHotspotsZone({
                    model: itemModel,
                    index: index,
                    parentView: this
                }).$el)
            }, this);
        },

        getAvailableItem: function() {
            return this.collection.findWhere({_hasBeenUsed: false});
        },

        // Left blank for question setup - should be used instead of preRender
        setupQuestion: function() {
            var items = this.model.get('_items');
            this.zones = new Backbone.Collection(items);
            this.collection = new Backbone.Collection(items, { model: HiddenHotspotsItemModel });

            this.listenTo(this.collection, 'change:_hasBeenUsed', this.renderItemsCounter);

            this.restoreUserAnswers();
        },

        // Blank method used just like postRender is for presentational components
        onQuestionRendered: function() {
            this.$graphic = this.$('.hidden-hotspots-graphic-container');
            this.$widget = this.$('.hidden-hotspots-widget');
            this.listenTo(Adapt, 'device:resize', this.onDeviceResized);
            this.renderItems();
            this.renderItemsCounter();
            this.setReadyStatus();
            this.addMobileInstructionText();
        },

        addMobileInstructionText: function() {
          var mobileInstructionDiv = document.createElement('div');
          mobileInstructionDiv.setAttribute('class', 'hiddenHotspots-instruction-inner-mobile');
          mobileInstructionDiv.innerHTML = this.model.get('mobileInstruction');
          this.$el.find('.hiddenHotspots-instruction').append(mobileInstructionDiv);
        },

        onDeviceResized: function() {
            this.$graphic.css('left', 0)
        },

        renderItems: function() {
            this.collection.each(function(itemModel, index) {
                this.$graphic.append(new HiddenHotspotsItem({
                    componentModel: this.model,
                    model: itemModel,
                    index: index,
                    parentView: this
                }).$el)
            }, this);
        },

        renderItemsCounter: function() {
            var remainingItems = this.collection.where({_hasBeenUsed: false}).length;
            var counterString = remainingItems + ' ' + this.model.get('itemsRemainingSuffix');
            this.$('.hidden-hotspots-item-counter').html(counterString);
        },

        restoreUserAnswers: function() {
            if (!this.model.get("_isSubmitted")) return;

            _.each(this.model.get("_userAnswer"), function(itemAnswer, i) {
                if (!itemAnswer) {
                    return;
                }

                var item = this.collection.at(i);
                var itemData = item.toJSON();

                item.set({
                    _currentLeft: itemData._left + (itemData._width / 2),
                    _currentTop: itemData._top + (itemData._height / 2),
                    _hasBeenUsed: true
                });
            }, this);

            this.setQuestionAsSubmitted();
            this.isCorrect();
            this.showMarking();
        },
        //////
        // Submit process
        ////

        // Triggered when the submit button is clicked
        onSubmitClicked: function() {

            // canSubmit is setup in questions and should return a boolean
            // If the question stops the user form submitting - show instruction error
            // and give a blank method, onCannotSubmit to the question
            if (!this.canSubmit()) {
                this.showInstructionError();
                this.onCannotSubmit();
                return;
            }

            // Used to update the amount of attempts the question has
            this.updateAttempts();

            // Used to set attributes on the model after being submitted
            // Also adds a class of submitted
            this.setQuestionAsSubmitted();

            // Used to remove instruction error that is set when
            // the user has interacted in the wrong way
            this.removeInstructionError();

            // Used to set question as correct:true/false
            // Calls isCorrect which is blank for the question
            // to fill out and return a boolean
            this.markQuestion();

            // Used to store the users answer for later
            // This is a blank method given to the question
            this.storeUserAnswer();

            // Used by the question to set the score on the model
            this.setScore();

            // Used by the question to display markings on the component
            this.showMarking();

            // Used to check if the question is complete
            // Triggers setCompletionStatus and adds class to widget
            this.checkQuestionCompletion();

            this.recordInteraction();

            // Used to setup the feedback by checking against
            // question isCorrect or isPartlyCorrect
            this.setupFeedback();

            // Used to update buttonsView based upon question state
            // Update buttons happens before showFeedback to preserve tabindexes and after setupFeedback to allow buttons to use feedback attribute
            this.updateButtons();
            // Used to trigger an event so plugins can display feedback
            this.showFeedback();

        },

        // Use to check if the user is allowed to submit the question
        // Maybe the user has to select an item?
        canSubmit: function() {
            return this.collection.findWhere({_hasBeenUsed: true});
        },

        // Blank method for question to fill out when the question cannot be submitted
        onCannotSubmit: function() {
        },

        // This is important for returning or showing the users answer
        // This should preserve the state of the users answers
        storeUserAnswer: function() {
            var userAnswer = this.zones.map(function(zone) {
                return zone.get('_isCorrect') ? 1 : 0;
            });

            this.model.set("_userAnswer", userAnswer);
        },

        // Should return a boolean based upon whether to question is correct or not
        isCorrect: function() {
            this.zones.each(function(zone) {
                var zoneTopMax = zone.attributes._top + zone.attributes._height;
                var zoneTopMin = zone.attributes._top;
                var zoneLeftMax = zone.attributes._left + zone.attributes._width;
                var zoneLeftMin = zone.attributes._left;
                this.collection.each(function(item) {

                    if (zone.get('_hasBeenUsed')) {
                        return;
                    }

                    if (item.get('_hasBeenUsed')) {

                        var itemTop = item.attributes._currentTop;
                        var itemLeft = item.attributes._currentLeft;
                        var isInLeftArea = false;
                        var isInTopArea = false;

                        if (itemTop >= zoneTopMin && itemTop <= zoneTopMax) {
                            isInTopArea = true;
                        }

                        if (itemLeft >= zoneLeftMin && itemLeft <= zoneLeftMax) {
                            isInLeftArea = true;
                        }

                        if (isInLeftArea && isInTopArea) {
                            this.model.set('_isAtLeastOneCorrectSelection', true);
                            item.set({_isCorrect: true});
                            zone.set({
                                '_hasBeenUsed': true,
                                '_isCorrect': true
                            });
                        }
                    }

                }, this)
            }, this);

            var correctLength = this.zones.where({_isCorrect: true}).length;
            var itemLength = this.model.get('_items').length;

            if (correctLength === itemLength) {
                return true;
            } else {
                return false;
            }

        },

        // Used to set the score based upon the _questionWeight
        setScore: function() {
            var questionWeight = this.model.get("_questionWeight");
            var answeredCorrectly = this.model.get('_isCorrect');
            var score = answeredCorrectly ? questionWeight : 0;
            this.model.set('_score', score);
        },

        // This is important and should give the user feedback on how they answered the question
        // Normally done through ticks and crosses by adding classes
        showMarking: function() {
            this.collection.each(function(itemModel, index) {
                itemModel.trigger('showMarking');
            }, this);
        },

        // Used by the question to determine if the question is incorrect or partly correct
        // Should return a boolean
        isPartlyCorrect: function() {
            return this.model.get('_isAtLeastOneCorrectSelection');
        },

        // Used by the question view to reset the stored user answer
        resetUserAnswer: function() {
            this.collection.each(function(itemModel, index) {
                itemModel.trigger('hideMarking');
            }, this);
        },

        // Used by the question view to reset the look and feel of the component.
        // This could also include resetting item data
        // This is triggered when the reset button is clicked so it shouldn't
        // be a full reset
        resetQuestion: function() {
            this.collection.each(function(itemModel, index) {
                itemModel.set({
                    _hasBeenUsed: false,
                    _currentTop: 0,
                    _currentLeft: 0,
                    _isCorrect: false
                });
            }, this);
            this.zones.each(function(zone) {
                zone.set({
                    _hasBeenUsed: false,
                    _isCorrect: false
                })
            }, this)
        },

        // Used by the question to display the correct answer to the user
        showCorrectAnswer: function() {
            this.renderZones();
        },

        // Used by the question to display the users answer and
        // hide the correct answer
        // Should use the values stored in storeUserAnswer
        hideCorrectAnswer: function() {
            this.zones.each(function(itemModel, index) {
                itemModel.trigger('hideCorrectAnswer');
            }, this);
        },

        /**
         * used by adapt-contrib-spoor to get the user's answers in the format required by the cmi.interactions.n.student_response data field
         */
        getResponse: function() {
            var correct = [];
            this.collection.each(function(item, key) {
                if (item.get('_isCorrect')) {
                    correct.push(++key);
                }
            }, this);
            return correct.join(',');
        },

        /**
         * used by adapt-contrib-spoor to get the type of this question in the format required by the cmi.interactions.n.type data field
         */
        getResponseType: function() {
            return 'choice';
        },

        getInteractionObject: function() {
            var interactionObj = {
                choices: [],
                correctResponsesPattern: []
            };

            return _.reduce(this.model.get('_items'), function(currentObj, item, i) {
                return {
                    choices: currentObj.choices.concat({
                        id: (i + 1).toString(),
                        description: ''
                    }),
                    correctResponsesPattern: [
                        currentObj.correctResponsesPattern.concat(i + 1).join("[,]")
                    ]
                };
            }, interactionObj, this);
        }

    });

    Adapt.register('hiddenHotspots', HiddenHotspots);

    return HiddenHotspots;

});

define('components/adapt-contrib-narrative/js/narrativeView',[
    'core/js/adapt',
    'core/js/views/componentView'
], function(Adapt, ComponentView) {
    'use strict';

    var NarrativeView = ComponentView.extend({

        _isInitial: true,

        events: {
            'click .narrative-strapline-title': 'openPopup',
            'click .narrative-controls': 'onNavigationClicked',
            'click .narrative-indicators .narrative-progress': 'onProgressClicked'
        },

        preRender: function() {
            this.listenTo(Adapt, {
                'device:changed': this.reRender,
                'device:resize': this.resizeControl,
                'notify:closed': this.closeNotify
            });
            this.setDeviceSize();

            this.listenTo(this.model.get('_children'), {
                'change:_isActive': this.onItemsActiveChange,
                'change:_isVisited': this.onItemsVisitedChange
            });

            this.checkIfResetOnRevisit();
            this.calculateWidths();
        },

        onItemsActiveChange: function(item, _isActive) {
            if (_isActive === true) {
                this.setStage(item);
            }
        },

        onItemsVisitedChange: function(item, isVisited) {
            if (!isVisited) return;
            this.$('[data-index="' + item.get('_index') + '"]').addClass('visited');
        },

        setDeviceSize: function() {
            this.model.set('_isDesktop', Adapt.device.screenSize === 'large');
        },

        postRender: function() {
            this.renderState();
            this.$('.narrative-slider').imageready(this.setReadyStatus.bind(this));
            this.setupNarrative();

            if (Adapt.config.get('_disableAnimation')) {
                this.$el.addClass('disable-animation');
            }
        },

        checkIfResetOnRevisit: function() {
            var isResetOnRevisit = this.model.get('_isResetOnRevisit');
            // If reset is enabled set defaults
            if (isResetOnRevisit) {
                this.model.reset(isResetOnRevisit);
            }
        },

        setupNarrative: function() {
            this.setDeviceSize();
            var items = this.model.get('_children');
            if (!items || !items.length) return;

            var activeItem = this.model.getActiveItem();
            if (!activeItem) {
                activeItem = this.model.getItem(0);
                activeItem.toggleActive(true);
            } else {
                // manually trigger change as it is not fired on reentry
                items.trigger('change:_isActive', activeItem, true);
            }

            this.calculateWidths();

            if (Adapt.device.screenSize !== 'large' && !this.model.get('_wasHotgraphic')) {
                this.replaceInstructions();
            }
            this.setupEventListeners();
            this._isInitial = false;
        },

        calculateWidths: function() {
            var itemCount = this.model.get('_children').length;
            this.model.set({
                '_totalWidth': 100 * itemCount,
                '_itemWidth': 100 / itemCount
            });
        },

        resizeControl: function() {
            var wasDesktop = this.model.get('_isDesktop');
            this.setDeviceSize();
            if (wasDesktop != this.model.get('_isDesktop')) this.replaceInstructions();
            this.evaluateNavigation();
            var activeItem = this.model.getActiveItem();
            if (activeItem) this.setStage(activeItem);
        },

        reRender: function() {
            if (this.model.get('_wasHotgraphic') && Adapt.device.screenSize === 'large') {
                this.replaceWithHotgraphic();
            } else {
                this.resizeControl();
            }
        },

        closeNotify: function() {
            this.evaluateCompletion();
        },

        replaceInstructions: function() {
            if (Adapt.device.screenSize === 'large') {
                this.$('.narrative-instruction-inner').html(this.model.get('instruction')).a11y_text();
            } else if (this.model.get('mobileInstruction') && !this.model.get('_wasHotgraphic')) {
                this.$('.narrative-instruction-inner').html(this.model.get('mobileInstruction')).a11y_text();
            }
        },

        replaceWithHotgraphic: function() {
            if (!Adapt.componentStore.hotgraphic) throw "Hotgraphic not included in build";
            var HotgraphicView = Adapt.componentStore.hotgraphic.view;

            var model = this.prepareHotgraphicModel();
            var newHotgraphic = new HotgraphicView({ model: model });
            var $container = $(".component-container", $("." + this.model.get("_parentId")));

            $container.append(newHotgraphic.$el);
            this.remove();
            $.a11y_update();
            _.defer(function() {
                Adapt.trigger('device:resize');
            });
        },

        prepareHotgraphicModel: function() {
            var model = this.model;
            model.resetActiveItems();
            model.set({
                '_isPopupOpen': false,
                '_component': 'hotgraphic',
                'body': model.get('originalBody'),
                'instruction': model.get('originalInstruction')
            });

            return model;
        },

        moveSliderToIndex: function(itemIndex, shouldAnimate) {
            var offset = this.model.get('_itemWidth') * itemIndex;
            if (Adapt.config.get('_defaultDirection') === 'ltr') {
                offset *= -1;
            }
            var cssValue = 'translateX('+offset+'%)';
            var $sliderElm = this.$('.narrative-slider');
            var $straplineHeaderElm = this.$('.narrative-strapline-header-inner');

            $sliderElm.css('transform', cssValue);
            $straplineHeaderElm.css('transform', cssValue);

            if (Adapt.config.get('_disableAnimation') || this._isInitial) {
                this.onTransitionEnd();
            } else {
                $sliderElm.one('transitionend', this.onTransitionEnd.bind(this));
            }
        },

        onTransitionEnd: function() {
            if (this._isInitial) return;

            var index = this.model.getActiveItem().get('_index');
            if (this.model.get('_isDesktop')) {
                this.$('.narrative-content-item[data-index="'+index+'"]').a11y_focus();
            } else {
                this.$('.narrative-strapline-title').a11y_focus();
            }
        },

        setStage: function(item) {
            var index = item.get('_index');
            if (this.model.get('_isDesktop')) {
                // Set the visited attribute for large screen devices
                item.toggleVisited(true);
            }

            var $slideGraphics = this.$('.narrative-slider-graphic');
            this.$('.narrative-progress:visible').removeClass('selected').filter('[data-index="'+index+'"]').addClass('selected');
            $slideGraphics.children('.controls').a11y_cntrl_enabled(false);
            $slideGraphics.filter('[data-index="'+index+'"]').children('.controls').a11y_cntrl_enabled(true);
            this.$('.narrative-content-item').addClass('narrative-hidden').a11y_on(false).filter('[data-index="'+index+'"]').removeClass('narrative-hidden').a11y_on(true);
            this.$('.narrative-strapline-title').a11y_cntrl_enabled(false).filter('[data-index="'+index+'"]').a11y_cntrl_enabled(true);

            this.evaluateNavigation();
            this.evaluateCompletion();
            this.moveSliderToIndex(index, !this._isInitial);
        },

        evaluateNavigation: function() {
            var active = this.model.getActiveItem();
            if (!active) return;

            var currentStage = active.get('_index');
            var itemCount = this.model.get('_children').length;

            var isAtStart = currentStage === 0;
            var isAtEnd = currentStage === itemCount - 1;

            this.$('.narrative-control-left').toggleClass('narrative-hidden', isAtStart);
            this.$('.narrative-control-right').toggleClass('narrative-hidden', isAtEnd);
        },

        evaluateCompletion: function() {
            if (this.model.areAllItemsCompleted()) {
                this.trigger('allItems');
            }
        },

        openPopup: function(event) {
            event && event.preventDefault();

            var currentItem = this.model.getActiveItem();

            // Set the visited attribute for small and medium screen devices
            currentItem.toggleVisited(true);

            Adapt.trigger('notify:popup', {
                title: currentItem.get('title'),
                body: currentItem.get('body')
            });
        },

        onNavigationClicked: function(event) {
            var stage = this.model.getActiveItem().get('_index');
            var numberOfItems = this.model.get('_children').length;

            if ($(event.currentTarget).hasClass('narrative-control-right')) {
                ++stage;
            } else if ($(event.currentTarget).hasClass('narrative-control-left')) {
                --stage;
            }

            if (stage < 0 || stage >= numberOfItems) return;

            this.model.setActiveItem(stage);
        },

        onProgressClicked: function(event) {
            event && event.preventDefault();
            var clickedIndex = $(event.target).data('index');
            this.model.setActiveItem(clickedIndex);
        },

        inview: function(event, visible, visiblePartX, visiblePartY) {
            if (!visible) return;

            if (visiblePartY === 'top') {
                this._isVisibleTop = true;
            } else if (visiblePartY === 'bottom') {
                this._isVisibleBottom = true;
            } else {
                this._isVisibleTop = true;
                this._isVisibleBottom = true;
            }

            var wasAllInview = (this._isVisibleTop && this._isVisibleBottom);
            if (!wasAllInview) return;

            this.$('.component-inner').off('inview');
            this.setCompletionStatus();
        },

        setupEventListeners: function() {
            if (this.model.get('_setCompletionOn') === 'inview') {
                this.$('.component-widget').on('inview', this.inview.bind(this));
            }
        },

        remove: function() {
            if (this.model.get('_setCompletionOn') === 'inview') {
                this.$('.component-widget').off('inview');
            }
            ComponentView.prototype.remove.apply(this, arguments);
        }

    });

    return NarrativeView;

});

define('core/js/models/itemModel',[],function() {

    var ItemModel = Backbone.Model.extend({

        defaults: {
            _isActive: false,
            _isVisited: false
        },

        reset: function() {
            this.set({ _isActive: false, _isVisited: false });
        },

        toggleActive: function(isActive) {
            if (isActive === undefined) {
                isActive = !this.get('_isActive');
            }

            this.set('_isActive', isActive);
        },

        toggleVisited: function(isVisited) {
            if (isVisited === undefined) {
                isVisited = !this.get('_isVisited');
            }

            this.set('_isVisited', isVisited);
        }

    });

    return ItemModel;

});

define('core/js/models/itemsComponentModel',[
    'core/js/models/componentModel',
    'core/js/models/itemModel'
], function(ComponentModel, ItemModel) {

    var ItemsComponentModel = ComponentModel.extend({

        toJSON: function() {
            var json = _.clone(this.attributes);
            json._items = this.get('_children').toJSON();

            return json;
        },

        init: function() {
            this.setUpItems();

            this.listenTo(this.get('_children'), {
                'change:_isVisited': this.checkCompletionStatus
            });
        },

        setUpItems: function() {
            var items = this.get('_items') || []; // see https://github.com/adaptlearning/adapt_framework/issues/2480
            items.forEach(function(item, index) {
                item._index = index;
            });

            this.set('_children', new Backbone.Collection(items, { model: ItemModel }));
        },

        getItem: function(index) {
            return this.get('_children').findWhere({ _index: index });
        },

        getVisitedItems: function() {
            return this.get('_children').where({ _isVisited: true });
        },

        getActiveItems: function() {
            return this.get('_children').where({ _isActive: true });
        },

        getActiveItem: function() {
            return this.get('_children').findWhere({ _isActive: true });
        },

        areAllItemsCompleted: function() {
            return this.getVisitedItems().length === this.get('_children').length;
        },

        checkCompletionStatus: function() {
            if (this.areAllItemsCompleted()) {
                this.setCompletionStatus();
            }
        },

        reset: function(type, force) {
            this.get('_children').each(function(item) { item.reset(); });

            ComponentModel.prototype.reset.call(this, type, force);
        },

        resetActiveItems: function() {
            this.get('_children').each(function(item) { item.toggleActive(false); });
        },

        setActiveItem: function(index) {
            var activeItem = this.getActiveItem();
            if (activeItem) activeItem.toggleActive(false);
            this.getItem(index).toggleActive(true);
        }

    });

    return ItemsComponentModel;

});

define('components/adapt-contrib-narrative/js/adapt-contrib-narrative',[
    'core/js/adapt',
    './narrativeView',
    'core/js/models/itemsComponentModel'
], function(Adapt, NarrativeView, ItemsComponentModel) {

    return Adapt.register('narrative', {
        model: ItemsComponentModel,
        view: NarrativeView
    });

});

/*
 * adapt-contrib-openTextInput
 * License - http://github.com/adaptlearning/adapt_framework/LICENSE
 * Maintainers
 * Brian Quinn <brian@learningpool.com>
 * Barry McKay <barry@learningpool.com>
 */

define('components/adapt-contrib-openTextInput/js/adapt-contrib-openTextInput',[
  'core/js/adapt',
  'core/js/views/questionView',
  'core/js/enums/buttonStateEnum'
], function(Adapt, QuestionView, BUTTON_STATE) {

  var OpenTextInput = QuestionView.extend({

    events: {
      'keyup textarea': 'onKeyUpTextarea'
    },

    formatPlaceholder: function() {
      // Replace quote marks in placholder.
      var placeholder = this.model.get('placeholder') || '';

      placeholder = placeholder.replace(/"/g, '\'');

      this.model.set('placeholder', placeholder);
    },

    setupQuestion: function() {
      this.listenTo(this.model, 'change:_isComplete', this.onCompleteChanged);

      // Open Text Input cannot show feedback, but may have been set in older courses
      this.model.set('_canShowFeedback', false);
      this.model.set('_feedback', {});

      this.formatPlaceholder();

      if (!this.model.get('_userAnswer')) {
        var userAnswer = this.getUserAnswer();
        if (userAnswer) {
          this.model.set('_userAnswer', userAnswer);
        }
      }

      var modelAnswer = this.model.get('modelAnswer');

      modelAnswer = modelAnswer ? modelAnswer.replace(/\\n|&#10;/g, '\n') : '';

      this.model.set('modelAnswer', modelAnswer);

      if (this.model.get('_isComplete')) {
        if (this.model.get('_canShowModelAnswer')) {
          this.model.set('_buttonState', BUTTON_STATE.SHOW_CORRECT_ANSWER);
        } else {
          this.model.set('_buttonState', BUTTON_STATE.CORRECT);
        }
      } else {
        this.model.set('_buttonState', BUTTON_STATE.SUBMIT);
      }

      // Some shim code to handle old/missing JSON.
      var buttons = this.model.get('_buttons');

      if (buttons['_hideCorrectAnswer'] == undefined) {
        buttons._hideCorrectAnswer = buttons._showUserAnswer || 'Show User Answer';
      }

      if (buttons['_showCorrectAnswer'] == undefined) {
        buttons._showCorrectAnswer = buttons._showModelAnswer || 'Show Model Answer';
      }

      this.model.set('_buttons', buttons);
    },

    onCompleteChanged: function(model, isComplete, buttonState) {
      this.$textbox.prop('disabled', isComplete);
      this.$answer.html(model.get('_userAnswer').replace(/\n/g, '<br>'));

      if (!isComplete || !model.get('_canShowModelAnswer') || _.isEmpty(buttonState)) return;

      // Toggle the button.
      if (buttonState == BUTTON_STATE.CORRECT || buttonState == BUTTON_STATE.HIDE_CORRECT_ANSWER || buttonState == BUTTON_STATE.SUBMIT) {
        model.set('_buttonState', BUTTON_STATE.SHOW_CORRECT_ANSWER);
      } else {
        model.set('_buttonState', BUTTON_STATE.HIDE_CORRECT_ANSWER);
      }

      // Keep the action button enabled so we can show the model answer.
      // Add a delay to guarantee button receives focus
      setTimeout(function() {
        this.$('.buttons-action').a11y_cntrl_enabled(true).a11y_focus();
      }.bind(this), 500);
    },

    canSubmit: function() {
      var answer = this.model.get('_userAnswer');

      if (typeof String.prototype.trim !== 'function') {
        String.prototype.trim = function() {
          return this.replace(/^\s+|\s+$/g, '');
        };
      }

      return answer && answer.trim() !== '';
    },

    isCorrect: function() {
      return this.canSubmit();
    },

    onQuestionRendered: function() {
      // Set the height of the textarea to the height of the model answer.
      // This creates a smoother user experience
      this.$('.openTextInput-item-textbox').height(this.$('.openTextInput-item-answertext').height());
      this.$('.openTextInput-count-characters').height(this.$('.openTextInput-count-characters').height());

      this.listenTo(this.buttonsView, 'buttons:stateUpdate', this.onActionClicked);

      this.$textbox = this.$('textarea.openTextInput-item-textbox');
      this.$answer = this.$('.openTextInput-item-answertext');
      this.$countChars = this.$('.openTextInput-count-characters-container');

      this.$autosave = this.$('.openTextInput-autosave');
      this.$autosave.text(this.model.get('savedMessage'));

      this.$autosave.css({opacity: 0});

      this.countCharacters();
      this.setReadyStatus();

      if (this.model.get('_isComplete')) {
        this.hideCorrectAnswer();
      }
    },

    getUserAnswer: function() {
      var identifier = this.model.get('_id') + '-OpenTextInput-UserAnswer';
      var userAnswer = '';

      if (this.supportsHtml5Storage() && !this.model.get('_isResetOnRevisit')) {
        userAnswer = localStorage.getItem(identifier);
        if (userAnswer) {
          return userAnswer;
        }
      }

      return false;
    },

    supportsHtml5Storage: function() {
      // check for html5 local storage support
      try {
        return 'localStorage' in window && typeof window['localStorage'] !== 'undefined';
      } catch (e) {
        return false;
      }
    },

    countCharacters: function() {
      var charLengthOfTextarea = this.$textbox.val().length;
      var allowedCharacters = this.model.get('_allowedCharacters');
      if (allowedCharacters != null) {
        var charactersLeft = allowedCharacters - charLengthOfTextarea;
        this.$('.openTextInput-count-amount').html(charactersLeft);
      } else {
        this.$('.openTextInput-count-amount').html(charLengthOfTextarea);
      }
    },

    onKeyUpTextarea: _.throttle(function() {
      this.limitCharacters();
      var text = this.$textbox.val();
      this.model.set('_userAnswer', text);

      this.countCharacters();

      if (this.saveTimeout) {
        clearTimeout(this.saveTimeout);
      }

      var self = this;
      this.saveTimeout = setTimeout(function() {
        self.storeUserAnswer();
      }, 2000);

    }, 300),

    limitCharacters: function() {
      var allowedCharacters = this.model.get('_allowedCharacters');
      if (allowedCharacters != null && this.$textbox.val().length > allowedCharacters) {
        var substringValue = this.$textbox.val().substring(0, allowedCharacters);
        this.$textbox.val(substringValue);
      }
    },

    storeUserAnswer: function() {
      // Use unique identifier to avoid collisions with other components
      var identifier = this.model.get('_id') + '-OpenTextInput-UserAnswer';

      if (this.supportsHtml5Storage() && !this.model.get('_isResetOnRevisit')) {
        // Adding a try-catch here as certain browsers, e.g. Safari on iOS in Private mode,
        // report as being able to support localStorage but fail when setItem() is called.
        try {
          localStorage.setItem(identifier, this.model.get('_userAnswer'));
        } catch (e) {
          console.log('ERROR: HTML5 localStorage.setItem() failed! Unable to save user answer.');
        }
      }

      this.model.set('_isSaved', true);

      this.$autosave.css({ opacity: 100 });
      this.$autosave.delay(1000).animate({ opacity: 0 });
    },

    onActionClicked: function(buttonState) {
      if (buttonState === BUTTON_STATE.SUBMIT && this.canSubmit()) {
        this.onCompleteChanged(this.model, true, buttonState);
      }
    },

    updateActionButton: function(buttonText) {
      // Keep the action button enabled so we can show the model answer
      this.$('.buttons-action').a11y_cntrl_enabled(true);

      this.$('.openTextInput-action-button').html(buttonText);
    },

    postRender: function() {
      if (this.$('.openTextInput-item-modelanswer').height() <= 0) {
        this.$('.openTextInput-item-textbox, .openTextInput-count-characters').css('height', 'auto');
      } else {
        // Set the height of the textarea to the height of the model answer.
        // This creates a smoother user experience
        this.$('.openTextInput-item-textbox').height(this.$('.openTextInput-item-modelanswer').height());
        this.$('.openTextInput-count-characters').height(this.$('.openTextInput-count-characters').height());
      }

      this.$('.openTextInput-item-modelanswer').addClass('hide-openTextInput-modelanswer');

      QuestionView.prototype.postRender.call(this);
    },

    showCorrectAnswer: function() {
      this.scrollToTextArea();
      this.toggleAnswer(BUTTON_STATE.HIDE_CORRECT_ANSWER, 'showUserAnswer', 'modelAnswer');

    },

    hideCorrectAnswer: function() {
      this.toggleAnswer(BUTTON_STATE.SHOW_CORRECT_ANSWER, 'showModelAnswer', '_userAnswer');
    },

    toggleAnswer: function(buttonState, buttonKey, answerKey) {
      this.model.set('_buttonState', buttonState);
      this.updateActionButton(buttonKey);

      // Replace any line breaks in order to display text as user typed it
      var answerText = this.model.get(answerKey).replace(/\n/g, '<br>');

      if (!this.$answer) {
        return;
      }
      this.$answer.html(answerText);
      this.$answer.a11y_focus();
    },

    scrollToTextArea: function() {
      // Smooth scroll to top of TextArea
      Adapt.scrollTo(this.$('.openTextInput-widget'), {
        duration: 400,
        offset: -parseInt($('#wrapper').css('padding-top'))
      });
    },

    /**
     * Used by adapt-contrib-spoor to get the user's answers in the format required by the cmi.interactions.n.student_response data field
     */
    getResponse: function() {
      var userAnswer = this.model.get('_userAnswer') || '';

      return userAnswer;
    },

    /**
     * Used by adapt-contrib-spoor to get the type of this question in the format required by the cmi.interactions.n.type data field
     */
    getResponseType: function() {
      return 'fill-in';
    },

    getInteractionObject: function() {
      return {
        correctResponsesPattern: [
          this.model.get('modelAnswer')
        ]
      };
    },

    /**
     * Used by questionView. Clears the models on Revisit userAnswer so input appears blank
     */
    resetQuestionOnRevisit: function() {
      this.resetQuestion();
    },

    /**
     * Used by questionView. Clears the models userAnswer onResetClicked so input appears blank
     */
    resetQuestion: function() {
      this.model.set('_userAnswer', '');

      if (this.$textbox === undefined) {
        this.$textbox = this.$('textarea.openTextInput-item-textbox');
      }

      this.$textbox.val(this.model.get('_userAnswer'));
    }
  });

  Adapt.register('openTextInput', OpenTextInput);

  Adapt.once('adapt:start', restoreQuestionStatusPolyfill);

  /**
   * Spoor cannot store text input values and so the completion status of this component does not get
   * saved or restored properly. This function ensures that the question's completion status is
   * restored in a way that other extensions e.g. learning objectives can obtain accurate data for processing
   *
   */
  function restoreQuestionStatusPolyfill() {
    Adapt.components.each(function(component) {
      if (component.get('_component') !== 'openTextInput') {
        return;
      }

      // If the component is complete then it must be correct
      // _isInteractionComplete needs to be set to true so marking is restored correctly
      if (component.get('_isComplete')) {
        component.set({
          _isCorrect: true,
          _isInteractionComplete: true
        });

        // Add a manual trigger just in case any extensions listening for this change have already loaded
        component.trigger('change:_isComplete', component, true);
      }
    });
  }

  return OpenTextInput;

});

define('components/adapt-contrib-text/js/adapt-contrib-text',[
    'core/js/adapt',
    'core/js/views/componentView',
    'core/js/models/componentModel'
], function(Adapt, ComponentView, ComponentModel) {

    var TextView = ComponentView.extend({

        preRender: function() {
            this.checkIfResetOnRevisit();
        },

        postRender: function() {
            this.setReadyStatus();

            this.setupInview();
        },

        setupInview: function() {
            var selector = this.getInviewElementSelector();
            if (!selector) {
                this.setCompletionStatus();
                return;
            }

            this.setupInviewCompletion(selector);
        },

        /**
         * determines which element should be used for inview logic - body, instruction or title - and returns the selector for that element
         */
        getInviewElementSelector: function() {
            if (this.model.get('body')) return '.component-body';

            if (this.model.get('instruction')) return '.component-instruction';

            if (this.model.get('displayTitle')) return '.component-title';

            return null;
        },

        checkIfResetOnRevisit: function() {
            var isResetOnRevisit = this.model.get('_isResetOnRevisit');

            // If reset is enabled set defaults
            if (isResetOnRevisit) {
                this.model.reset(isResetOnRevisit);
            }
        }
    },
    {
        template: 'text'
    });

    return Adapt.register('text', {
        model: ComponentModel.extend({}),// create a new class in the inheritance chain so it can be extended per component type if necessary later
        view: TextView
    });
});

define('extensions/adapt-contrib-assistedLearning/js/revisionHeaderView',['core/js/adapt'], function(Adapt) {

  var RevisionHeaderView = Backbone.View.extend({

    tagName: 'div',

    className: function() {
      return 'revision-header ' + this.model.get('_assistedLearning')._classes;
    },

    template: 'revisionHeader',

    events: {
      'click .title-bar': 'onTutorButtonClick',
      'click .revision-header-close': 'onCloseClick',
      'click button.back-to-results': 'onBackToResultsClick'
    },

    initialize: function() {
      this.listenTo(Adapt, {
        'remove': this.remove,
        'assistedLearning:end': this.remove,
        'assistedLearning:close': this.handleClose
      });

      this.render();
    },

    render: function() {
      var template = Handlebars.templates[this.template];
      this.$el.html(template(this.model.toJSON()));

      _.defer(_.bind(function() {
        this.postRender();
      }, this));
    },

    postRender: function() {
      // Cover the navigation bar with the revision header.
      this.$el.css('height', $('div.navigation').height());
    },

    onBackToResultsClick: function(event) {
      event && event.preventDefault();

      Adapt.trigger('assistedLearning:backToResults');
    },

    handleClose: function() {
      Adapt.trigger('assistedLearning:end');
    },

    onCloseClick: function(event) {
      event.preventDefault();

      var config = this.model.get('_assistedLearning');
      var globals = this.model.get('_globals');

      // Display revision.
      var promptObject = {
        title: config.confirmExitTitle,
        body: config.confirmExitBody,
        _prompts: [
          {
            promptText: globals._extensions._assistedLearning.yes,
            _callbackEvent: 'assistedLearning:close'
          },
          {
            promptText: globals._extensions._assistedLearning.no,
            _callbackEvent: ''
          }
        ],
        _showIcon: true
      };

      Adapt.trigger('notify:prompt', promptObject);
    }

  });

  return RevisionHeaderView;
});

define('extensions/adapt-contrib-assistedLearning/js/revisionResultsView',['core/js/adapt'], function(Adapt) {

  var RevisionResultsView = Backbone.View.extend({

    tagName: 'div',

    className: function() {
      return 'revision-results ' + this.model.get('_assistedLearning')._classes;
    },

    template: 'revisionResults',

    events: {
      'click button.revision-review-button': 'onReviewButtonClicked'
    },

    initialize: function(options) {

      if (options && options.model) {
        this.model = options.model;
      }

      this.listenTo(Adapt, {
        'remove': this.remove,
        'assistedLearning:end': this.remove,
        'assistedLearning:cancelObjective': this.resetActiveObjective,
        'assistedLearning:startObjective': this.startRevision
      });

      var config = this.model.get('_assistedLearning');
      config.revisionResultsBodyText = Adapt.assistedLearning.replacePlaceholders(config.revisionResultsBody);

      this.model.set('_assistedLearning', config);

      this.render();
    },

    render: function() {

      var template = Handlebars.templates[this.template];
      this.$el.html(template(this.model.toJSON()));

      _.defer(_.bind(function() {
        this.postRender();
      }, this));
    },

    postRender: function() {},

    resetActiveObjective: function(notifyView) {
      this.model.set('activeObjective', null);
    },

    remove: function() {
      Adapt.trigger('plugin:beginWait');
      this._isRemoved = true;

      _.defer(_.bind(function() {
          Backbone.View.prototype.remove.call(this);
          Adapt.trigger('plugin:endWait');
      }, this));

      return this;
    },

    startRevision: function(notifyView) {
      // Hide the results.
      this.$el.addClass('display-none');

      Adapt.trigger('assistedLearning:next');
    },

    onReviewButtonClicked: function(event) {
      event && event.preventDefault();

      var objectiveId = $(event.currentTarget).attr('data-objective-id');
      var globals = Adapt.course.get('_globals');
      var config = this.model.get('_assistedLearning');

      this.model.set('activeObjective', objectiveId);

      var promptObject = {
        title: config.confirmRevisionTitle,
        body: Adapt.assistedLearning.replacePlaceholders(config.confirmRevisionBodyText),
        _prompts: [
          {
            promptText: globals._extensions._assistedLearning.yes,
            _callbackEvent: 'assistedLearning:startObjective'
          },
          {
            promptText: globals._extensions._assistedLearning.no,
            _callbackEvent: 'assistedLearning:cancelObjective'
          }
        ],
        _showIcon: true
      };

      Adapt.trigger('notify:prompt', promptObject);
    }

  });

  return RevisionResultsView;
});
define('extensions/adapt-contrib-assistedLearning/js/revisionFooterProgressView',['core/js/adapt'], function(Adapt) {

  var RevisionFooterProgressView = Backbone.View.extend({

    className: 'objective-progress',

    events: {
      'click .objective-progress-item button': 'scrollToComponent'
    },

    initialize: function(options) {

      if (options && options.model) {
        this.model = options.model;
      }

      this.listenTo(Adapt, 'remove', this.remove);
      this.render();
    },

    render: function() {
      var objective = _.findWhere(this.model.get('objectives'), {_code: this.model.get('activeObjective')})
      var components = objective && objective.componentsToRevise;

      var data = {
        components: components,
        _globals: Adapt.course.get('_globals')
      };

      var template = Handlebars.templates['revisionFooterProgress'];
      this.$el.html(template(data));
      this.$el.a11y_aria_label(true);
      return this;
    },

    scrollToComponent: function(event) {
      if (event && event.preventDefault) {
        event.preventDefault();
      }

      var componentId = $(event.currentTarget).attr('data-component-id');
      var currentComponentSelector = '.' + componentId;
      var $currentComponent = $(currentComponentSelector);

      Adapt.once('drawer:closed', function() {
        if ($currentComponent.length !== 0) {
          Adapt.scrollTo($currentComponent, { duration: 400 });
        } else {
          Backbone.history.navigate('#id/' + componentId, { trigger: true, replace: true });
        }
      });

      Adapt.trigger('drawer:closeDrawer');
    }

  });

  return RevisionFooterProgressView;

});
define('extensions/adapt-contrib-assistedLearning/js/revisionFooterView',['core/js/adapt', './revisionFooterProgressView'], function(Adapt, RevisionFooterProgressView) {

  var RevisionFooterView = Backbone.View.extend({

    tagName: 'div',

    className: function() {
      return 'revision-footer ' + this.model.get('_assistedLearning')._classes;
    },

    template: 'revisionFooter',

    events: {
      'click button.revision-footer-next-component': 'onNextClick',
      'click button.revision-footer-take-assessment': 'onTakeAssessmentClick',
      'click button.revision-footer-progress-navigation': 'onViewProgressClick'
    },

    initialize: function() {
      this.listenTo(Adapt, 'remove', this.remove);
      this.listenTo(Adapt, 'assistedLearning:end', this.remove);
      this.listenTo(Adapt, 'assistedLearning:objectiveProgressUpdate', this.updateObjectiveProgress);

      // Store a reference to the dynamic ARIA label
      this.ariaText = this.model.get('_globals')._extensions._assistedLearning.revisionProgressIndicatorBar || '';

      var activeObjective = this.model.get('activeObjective');

      if (activeObjective) {
        var objective = _.findWhere(this.model.get('objectives'), {_code: activeObjective});

        if (objective.componentsToRevise.length === 1) {
          // The 'next' button is not required.
          this.model.set('hideNextButton', true);
        } else {
          this.model.set('hideNextButton', false);
        }
      }

      this.render();
    },

    render: function() {

      var template = Handlebars.templates[this.template];
      this.$el.html(template(this.model.toJSON()));

      _.defer(_.bind(function() {
        this.postRender();
      }, this));
    },

    postRender: function() {
      $('div.revision-footer-progress-navigation-bar .aria-label').html(this.ariaText + '0%');
    },

    onNextClick: function() {
      Adapt.trigger('assistedLearning:next');
    },

    onTakeAssessmentClick: function() {
      if (this.model.get('_assistedLearning')._bypassResultsOnRetake || Adapt.location._currentLocation === 'assistedlearning-revision') {
        Adapt.trigger('assistedLearning:takeAssessment');
      } else {
        Adapt.trigger('assistedLearning:backToResults');
      }
    },

    updateObjectiveProgress: function(progress) {
      this.$('div.revision-footer-progress-navigation-bar').css('width', progress + '%');
      this.$('div.revision-footer-progress-navigation-bar .aria-label').html(this.ariaText + progress + '%');
    },

    onViewProgressClick: function(event) {
      event && event.preventDefault();

      Adapt.drawer.triggerCustomView(new RevisionFooterProgressView({model: this.model}).$el, false);
    }

  });

  return RevisionFooterView;
});
define('extensions/adapt-contrib-assistedLearning/js/adapt-contrib-assistedLearning',[
  'core/js/adapt',
  './revisionHeaderView',
  './revisionResultsView',
  './revisionFooterView'
], function(Adapt, RevisionHeaderView, RevisionResultsView, RevisionFooterView) {

  Adapt.assistedLearning = _.extend({

    isLaunched: false,
    model: null,

    initialize: function() {
      // Check if the extension is enabled
      var courseConfig = Adapt.course.get('_assistedLearning');

      if (!courseConfig || !courseConfig._isEnabled) {
        return;
      }

      this.model = new Backbone.Model();

      this.model.set({
        // Absorb the language strings.
        _globals: Adapt.course.get('_globals'),
        // Absorb the extension configuration.
        _assistedLearning: courseConfig
      });

      // Event listeners
      this.listenTo(Adapt, {
        // - Assessment
        'assessments:complete': this.handleAssessmentComplete,
        // - Router
        'router:plugin:assistedlearning': this.handlePluginRoute,
        'router:page': this.maintainInterface,
        // - Assisted Learning (this extension)
        'assistedLearning:start': this.startAssistedLearning,
        'assistedLearning:end': this.endAssistedLearning,
        'assistedLearning:next': this.goToNextComponent,
        'assistedLearning:backToResults': this.goToResults,
        'assistedLearning:takeAssessment': this.goToAssessment
      });

      // Adapt.components -- required to keep track of re-visited components
      this.listenTo(Adapt.components, 'change:_isInteractionComplete', this.handleComponentComplete);

      Adapt.trigger('assistedLearning:ready');
    },

    /**
     * Handle completion of an assessment.
     * @param {object} state - Represents the  state of the assessment
     * @param {object} model - Backbone.Model
     */
    handleAssessmentComplete: function(state, model) {
      // Set the neccessary model proerties.
      this.model.set({
        pageId: state.pageId,
        assessmentId: state.id,
        score: state.score,
        scoreAsPercent: state.scoreAsPercent,
        maxScore: state.maxScore,
        attempts: state.attempts,
        attemptsLeft: state.attemptsLeft,
        attemptsSpent: state.attemptsSpent
      });

      if (!state.isPass) {
        // Launch assisted learning.
        this.handleAssessmentFail(state, model);
      } else {
        var config = this.model.get('_assistedLearning');

        if (config._displaySuccessMessageOnPass) {
          // Display a congratulations message to the user.
          var bodyText = this.replacePlaceholders(config.assessmentPassBody);
          var confirmText = Adapt.course.get('_globals')._accessibility._ariaLabels.closePopup || 'OK';

          var alertObject = {
            title: config.assessmentPassTitle,
            body: bodyText,
            confirmText: confirmText,
            _showIcon: false
          };

          Adapt.trigger('notify:alert', alertObject);
        }
      }
    },

    /**
     * Handle completion of a component.
     * @param {object} componentModel - Backbone.Model
     * @param {bool} isComplete - true or false to indicate if the component was completed
     */
    handleComponentComplete: function(componentModel, isComplete) {
      if (!this.isLaunched || componentModel._isPartOfAssessment || !isComplete) {
        return;
      }

      var id = componentModel.get('_id');
      var objectives = this.model.get('objectives');
      var activeObjective = this.model.get('activeObjective');

      // Iterate over every objective and mark this component complete on all.
      for (var i = 0, l = objectives.length; i < l; i++) {
        var componentIds = _.pluck(objectives[i].componentsToRevise, '_id');
        var index = _.indexOf(componentIds, id);

        if (index !== -1) {
          objectives[i].componentsToRevise[index]._isRevised = true;
        }

        // Check if all the components as part of the current objective are complete.
        if (_.isUndefined(_.findWhere(objectives[i].componentsToRevise, {_isRevised: false}))) {
          // There are no components in this objective to complete.
          // Mark this objective as revised.
          objectives[i]._isRevised = true;
        }

        if (activeObjective === objectives[i]._code) {
          var revisedCount = _.where(objectives[i].componentsToRevise, {_isRevised: true}).length;
          // Update the progress.
          Adapt.trigger('assistedLearning:objectiveProgressUpdate', parseInt((revisedCount / componentIds.length) * 100));

          if (objectives[i]._isRevised) {
            // Hide the 'Next' button.
            $('button.revision-footer-next-component').addClass('display-none');
          } else {
            // Indicate that there is another component to revise.
            $('button.revision-footer-next-component').addClass('button-highlight');
          }
        }
      }

      var objectivesToRevise = _.where(objectives, {_isRevised: false});

      if (objectivesToRevise.length === 0) {
        this.model.set('canTakeAssessment', true);

        // Make the assessment button available.
        $('button.revision-footer-take-assessment').removeClass('display-none').addClass('button-highlight');
      } else {
        // There are other objectives to complete.
        if ($('button.revision-footer-next-component').hasClass('display-none')) {
          $('button.back-to-results').addClass('button-highlight');
        }
      }

      this.model.set('objectives', objectives);
    },

    /**
     * Handles the failure of an assessment.
     * @param {object} state - Represents the  state of the assessment
     * @param {object} model - Backbone.Model
     */
    handleAssessmentFail: function(state, model) {
      var failedObjectives = [];
      var incorrectQuestions = [];
      var objectivesToRevisit;

      // Do nothing if the user has no attempts left.
      if (state.attemptsLeft == 0) {
        return;
      }

      var config = this.model.get('_assistedLearning');

      // Replace the placeholders in the text strings.
      config.revisionResultsBodyText = this.replacePlaceholders(config.revisionResultsBody);
      config.confirmRevisionBodyText = this.replacePlaceholders(config.confirmRevisionBody);

      this.model.set({
        _assistedLearning: config,
        canTakeAssessment: false
      });

      // Iterate over the questions to work out which learning objectives were failed.
      for (var i = 0, length = state.questions.length; i < length; i++) {

        var question = state.questions[i];

        if (question._isCorrect === false) {
          incorrectQuestions.push(question._id);
        }
      }

      if (incorrectQuestions.length === 0) {
        return;
      }

      // Call into the Learning Objectives extension to work out which components need review.
      objectivesToRevisit = Adapt.learningObjectives.getObjectivesForComponents(incorrectQuestions);

      this.model.set('objectives', objectivesToRevisit);

      if (objectivesToRevisit.length !== 0) {
        // Indicate to the user that the revision widget is about to launch.
        var alertObject = {
          title: config.startRevisionTitle,
          body: this.replacePlaceholders(config.startRevisionBody),
          confirmText: config.startRevisionButtonText,
          _callbackEvent: 'assistedLearning:start',
          _showIcon: false
        };

        Adapt.trigger('notify:alert', alertObject);
      }
    },

    /**
     * Opens the revision UI.
     */
    startAssistedLearning: function() {
      this.isLaunched = true;

      Backbone.history.navigate('#/assistedlearning/revision', {trigger: true, replace: true});
    },

    /**
     * Closes the revision UI.
     */
    endAssistedLearning: function() {
      this.isLaunched = false;

      this.cleanUpPreviousRevision();
      this.toggleNavigationAccessibility();

      // Re-directs back to the course homepage.
      Backbone.history.navigate('#/', {trigger: true, replace: true});
    },

    /**
     * Take the user to the next component to revise.
     */
    goToNextComponent: function(event) {
      event && event.preventDefault();

      var objectives = this.model.get('objectives');
      var components = _.findWhere(objectives, { _code: this.model.get('activeObjective') }).componentsToRevise;
      var remainingComponents = _.where(components, { _isRevised: false });
      var $nextButton = $('button.revision-footer-next-component');

      // Remove any highlighing on the button.
      $nextButton.removeClass('button-highlight');

      // Hide the button if this is the last component to revise
      if (remainingComponents.length === 1) {
        $nextButton.hide();
      }

      // Draw UI for component revision.
      var nextComponent = _.find(components, function(component) {
        return component._isRevised === false;
      });

      if (nextComponent) {
        Adapt.findById(nextComponent._id).set({ _isComplete: false });

        var $currentComponent = $('.' + nextComponent._id);

        if ($currentComponent.length !== 0) {
          Adapt.scrollTo($currentComponent, { duration: 400 });
        } else {
          // Need a delay only when accessibility mode is on - HACK!
          var delayTime = 0;
          // 500ms has been selected because thats how long it takes for the accessibility code to clean up after closing a notify window
          // because it is scattered with delays and defers
          if (Adapt.config.get('_accessibility')._isEnabled && Adapt.config.get('_accessibility')._isActive) {
            delayTime = 500;
          }

          _.delay(function() {
            Adapt.navigateToElement('.' + nextComponent._id, { trigger: true, replace: true });
          }, delayTime);
        }
      }
    },

    /**
     * Take the user back to the results page.
     */
    goToResults: function(event) {
      event && event.preventDefault();

      this.model.set('activeObjective', null);

      Backbone.history.navigate('#/assistedlearning/revision', {trigger: true, replace: true});
    },

    /**
     * Return the user to the assessment which triggered this revision.
     */
    goToAssessment: function(event) {
      event && event.preventDefault();

      var assessmentUrl = '#id/' + this.model.get('pageId');

      this.isLaunched = false;

      var goToAssessment = function() {
        Backbone.history.navigate(assessmentUrl, { trigger: true, replace: true });
      };

      if (!this.model.get('_assistedLearning')._resetOnRetake) {
        return goToAssessment();
      }

      // Reset the assessment
      var assessmentModel = Adapt.assessment.get(this.model.get('assessmentId'));

      // Let Single Submit handle reset behaviour if present
      var assessmentSingleSubmit = assessmentModel.get('AssessmentSingleSubmit');
      if (assessmentSingleSubmit) {
        assessmentSingleSubmit.resetAssessment();
        goToAssessment();
      } else {
        assessmentModel.reset(true, goToAssessment);
      }
    },

    /**
     * Ensures that routings to  'assistedlearning/revision' render the revision page.
     */
    handlePluginRoute: function(pluginName, location, action) {
      var self = this;

      if (pluginName === 'assistedlearning' && location === 'revision') {

        this.model.set('activeObjective', null);

        // Remove any existing views, i.e. page.
        require('core/js/router').removeViews(_.bind(function() {

          this.cleanUpPreviousRevision();

          $revision = $('<div class="revision assisted-learning">');
          $('body').append($revision);

          $revision.append(new RevisionHeaderView({model: self.model}).$el);
          $revision.append(new RevisionResultsView({model: self.model}).$el);
          $revision.append(new RevisionFooterView({model: self.model}).$el);

          this.toggleNavigationAccessibility();
          $revision.a11y_popup();
        }, this));
      }
    },

    /**
     * Persists the header and footer navigation
     */
    maintainInterface: function() {
      if (this.isLaunched) {
        this.cleanUpPreviousRevision();

        var $wrapper = $('#wrapper');
        $('#wrapper').remove();

        var $revision = $('<div class="revision assisted-learning">');
        $('body').append($revision);

        $revision.append(new RevisionHeaderView({model: this.model}).$el);
        // Move $wrapper into the revision container to improve the DOM structure for accessibility
        $revision.append($wrapper);
        $revision.append(new RevisionFooterView({model: this.model}).$el);
        // Temporarily disable the original navigation bar accessibility
        this.toggleNavigationAccessibility();
      } else {
        $('.revision').removeClass('assisted-learning');
        this.toggleNavigationAccessibility();

      }
    },

    /**
     * Removes old revision containers if there are any left over and put the content wrapper back into its original position
     */
    cleanUpPreviousRevision: function() {
      var $revision = $('.revision');
      var $wrapper = $('#wrapper');

      // If wrapper is not directly under body, put it back there.
      if (!$wrapper.parent('body').length) {
        $('.navigation').after($wrapper);
      }

      if ($revision.length) {
        // Clean up any previous revision containing divs.
        $revision.remove();
      }
    },

    /**
     * Toggles the accessibility of the navigation bar so we can use the assistedLearning overlay nav bar
     */
    toggleNavigationAccessibility: function() {
      var $nav = $('.navigation');

      // If revision.assisted-learning class exists, and it isn't already hidden, make the nav bar hidden to screen reader
      if ($('.revision.assisted-learning').length) {
        if(!$nav.attr('aria-hidden') && !$nav.hasClass('a11y-ignore')) {
          $nav.attr('aria-hidden', 'true').addClass('a11y-ignore');
        }
      } else {
        $nav.removeAttr('aria-hidden').removeClass('a11y-ignore');
      }
    },

    /**
     * Adds a sub-set of strings to
     * @param {string} inputString - The input string
     * @returns The input string with placeholders inserted
     */
    replacePlaceholders: function(inputString) {
      var score = this.model.get('score');
      var scoreAsPercent = this.model.get('scoreAsPercent');
      var maxScore = this.model.get('maxScore');
      var attempts = this.model.get('attempts');
      var attemptsLeft = this.model.get('attemptsLeft');
      var attemptsSpent = this.model.get('attemptsSpent');

      inputString = inputString.replace(/{{score}}/gi, score);
      inputString = inputString.replace(/{{scoreAsPercent}}/gi, scoreAsPercent);
      inputString = inputString.replace(/{{maxScore}}/gi, maxScore);
      inputString = inputString.replace(/{{attempts}}/gi, attempts);
      inputString = inputString.replace(/{{attemptsLeft}}/gi, attemptsLeft);
      inputString = inputString.replace(/{{attemptsSpent}}/gi, attemptsSpent);

      return inputString;
    }

  }, Backbone.Events);

  Adapt.on('learningObjectives:ready', function() {
    Adapt.assistedLearning.initialize();
    Adapt.on('app:languageChanged', Adapt.assistedLearning.initialize);
  });

});

/**
 When Adapt content is viewed in a FRAME element, on iOS devices it is essential that the top frame contains
 the meta "viewport" element, otherwise the content will not scroll.
 */
define('extensions/adapt-contrib-ios-frameset/js/adapt-contrib-ios-frameset',[
  'core/js/adapt'
], function(Adapt) {

  /**
   * Initialise iframe specific settings and overrides
   */
  function setupIframe() {
    var $html = $('html');

    addHtmlClasses($html);

    if (window.top && !$html.hasClass('ie')) {
      setupMetaViewport();
    }

    if ($html.hasClass('touch')) {
      setupTouchDevice();
    }

    if ($html.hasClass('trickle')) {
      setupTrickle();
    }

    // Check if IOS specific IFRAME handling is required.
    if ($html.hasClass('ios-scroll-fix')) {
      setupIOSEventListeners();
    }
  }

  /**
   * Ensure document has the meta viewport tag with the correct settings
   */
  function setupMetaViewport() {
    try {
      if (!window.top.document.querySelector('meta[name=viewport]')) {
        $('head', window.top.document).append('<meta name="viewport" content="initial-scale=1.0, user-scalable=yes">');
      } else {
        $('meta[name=\'viewport\']', window.top.document).attr('content', 'initial-scale=1.0, user-scalable=yes');
      }
    } catch (e) {
    }
  }

  /**
   * Ensure iPad is detected correctly as ios 13 reports that the OS is "mac"
   * @returns {boolean|*}
   */
  function isIOS() {
    return Adapt.device.OS == 'ios' || (Adapt.device.OS == 'mac' && Adapt.device.touch);
  }

  /**
   * Add iframe and frameset classes to html
   * @param {$} $html
   */
  function addHtmlClasses($html) {
    $html.addClass('frameset');

    if (isIOS() && window.frameElement && window.frameElement.nodeName == 'IFRAME') {
      // Fix for iOS fixed position elements/Trickle.
      $html.addClass('ios-scroll-fix');
    } else if (Adapt.device.OS == 'android') {
      // Fix for Android fixed position elements/Trickle.
      $html.addClass('android-scroll-fix');
    }

    try {
      $html.addClass(window.frameElement.nodeName.toLowerCase());
    } catch (e) {
      // Default to IFRAME styling, in case of cross-domain security issues.
      $html.addClass('iframe');
    }
  }

  /**
   * Styling for body to enable scrolling
   */
  function setupTouchDevice() {
    $('body').css({
      height: '100%',
      left: 0,
      overflowX: 'auto',
      position: 'absolute',
      top: 0,
      width: '100%'
    });
  }

  /**
   * Additional styling for body if trickle is being used
   */
  function setupTrickle() {
    $('body').css({
      height: 'auto',
      minHeight: '100vh'
    });
  }

  function setupIOSEventListeners() {
    Adapt.on({
      'app:dataReady': onDataReady,
      'pageView:ready': fixPageFooterNav
    });
    Adapt.once('adapt:initialize', setupNavContainer);
  }

  /**
   * Apply jQuery method overrides on IOS
   */
  function onDataReady() {
    var $scrollingContainer = createScrollingContainer();

    // Fix scrolling.
    fixScrollTo($scrollingContainer);
    fixScrollTop($scrollingContainer);
    fixJqueryOffset();
  }

  /**
   * Prevent page jumping to bottom when bookmarking location is restored on IOS
   */
  function fixPageFooterNav() {
    $('.page-footer-navigation').appendTo('body').addClass('display-fixed');
  }

  /**
   * Create a scrolling container for IOS devices
   * @returns {$}
   */
  function createScrollingContainer() {
    // Make fake HTML and BODY tags.
    var $scrollingContainer = $('<div class="scrolling-container"><div class="scrolling-inner body"></div></div>');
    var $scrollingInner = $scrollingContainer.find('.scrolling-inner');

    var $body = $('body');
    $body.append($scrollingContainer);

    //move wrapper inside fake tags
    $('#wrapper').appendTo($scrollingInner);

    $scrollingContainer.on('scroll', function() {
      $(window).scroll();
    });

    return $scrollingContainer;
  }

  /**
   * Move navigation to outside the scrolling area
   */
  function setupNavContainer() {
    var $navigationContainer = $('<div class="navigation-container"></div>');
    $navigationContainer.prependTo('body');
    $('.navigation').prependTo($navigationContainer);
  }

  /**
   * Override window.scrollTo, $.scrollTo and $.fn.scrollTo on IOS devices
   * @param $scrollingContainer
   */
  function fixScrollTo($scrollingContainer) {
    var originalScrollTo = $.scrollTo;
    var originalElementScrollTo = $.fn.scrollTo;

    $.scrollTo = function() {
      return originalScrollTo.apply($scrollingContainer, arguments);
    };

    // Ensure new scrollTo function retains previous properties (i.e. defaults, max)
    _.extend($.scrollTo, originalScrollTo);

    $.fn.scrollTo = function() {
      if (this[0] === window || this[0] === document.body) {
        return originalElementScrollTo.apply($scrollingContainer, arguments);
      } else {
        return originalElementScrollTo.apply(this, arguments);
      }
    };

    window.scrollTo = function(x, y) {
      _.defer(function() {
        $scrollingContainer[0].scrollTop = y || 0;
        $scrollingContainer[0].scrollLeft = x || 0;
      });
    };
  }

  /**
   * Override $.fn.scrollTop on IOS devices
   * @param {$} $scrollingContainer
   */
  function fixScrollTop($scrollingContainer) {
    var originalScrollTop = $.fn.scrollTop;

    $.fn.scrollTop = function() {
      if (this[0] === window || this[0] === document.body) {
        return originalScrollTop.apply($scrollingContainer, arguments);
      } else {
        return originalScrollTop.apply(this, arguments);
      }
    };
  }

  /**
   * Override $.fn.offset on IOS devices
   */
  function fixJqueryOffset() {
    var jqueryOffset = $.fn.offset;

    $.fn.offset = function() {
      var offset = jqueryOffset.call(this);
      var $stack = this.parents().add(this);
      var $scrollParents = $stack.filter('.scrolling-container');
      $scrollParents.each(function(index, item) {
        var $item = $(item);
        var scrolltop = parseInt($item.scrollTop());
        var scrollleft = parseInt($item.scrollLeft());

        offset.top += scrolltop;
        offset.left += scrollleft;
      });

      return offset;
    };
  }

  /**
   * Add fixes for vimeo player and android when page is loaded
   * @param page
   */
  function onPageViewReady(page) {
    // Fix for external media sources which use iFrames, e.g. Vimeo, YouTube.
    var $html = $('html');
    if ($html.hasClass('iphone') || $html.hasClass('ipad')) {
      vimeoPlayerScrollFix();
    }

    // Fix for Android persisting the scroll position.
    if ($html.hasClass('android-scroll-fix')) {
      androidScrollFix();
    }
  }

  function vimeoPlayerScrollFix() {
    _.each($('.media-widget.external-source.video-vimeo'), function(item) {
      var $item = $(item);
      var dataId = $item.find('.mejs-container').attr('id');

      // Add a <div> to allow scrolling.
      var $mediaScrollerDiv = $('<div class="ios-media-scroller" data-id="' + dataId + '" data-type="vimeo"></div>');
      $item.find('.mejs-mediaelement').prepend($mediaScrollerDiv);

      // iOS demands that the event handlers are bound individually.
      $mediaScrollerDiv.on('click', function(event) {
        var player = $f($(event.currentTarget).siblings().find('iframe')[0]);
        player.api('play');
      });
    });
  }

  function androidScrollFix() {
    var scrollElm = document.scrollingElement;
    scrollElm.scrollTop = 0;
    // Adapt.trigger('device:changed', Adapt.device.screenSize);
  }

  Adapt.on('pageView:ready', onPageViewReady);

  if (window.self !== window.top) {
    setupIframe();
  }
});

define('extensions/adapt-contrib-languagePicker/js/accessibilityView',[
    'core/js/adapt'
], function(Adapt) {

    var AccessibilityView = Backbone.View.extend({

        el: '#accessibility-toggle',

        events: {
            'click' : 'toggleAccessibility'
        },

        initialize: function() {
            this.setupUsageInstructions();

            if(Adapt.offlineStorage.ready) {
                this.onOfflineStorageReady();
            } else {
                Adapt.once('offlineStorage:ready', _.bind(this.onOfflineStorageReady, this));
            }
        },

        onOfflineStorageReady: function() {
            Adapt.config.get("_accessibility")._isActive = Adapt.offlineStorage.get('a11y') || false;

            this.configureAccessibility();

            this.render();
        },

        render: function() {
            var hasAccessibility = Adapt.config.has('_accessibility')
                && Adapt.config.get('_accessibility')._isEnabled;

            if (!hasAccessibility) {
                return;
            } else {
                var isActive = Adapt.config.get('_accessibility')._isActive;
                var offLabel = this.model.get("_accessibility") && this.model.get("_accessibility").accessibilityToggleTextOff;
                var onLabel = this.model.get("_accessibility") && this.model.get("_accessibility").accessibilityToggleTextOn;

                var toggleText = isActive ? offLabel : onLabel;

                this.$el.attr('aria-label', $.a11y_normalize(toggleText));

                if (isActive) {
                    $("html").addClass('accessibility');
                    $("#accessibility-instructions").a11y_focus();
                } else {
                    $("html").removeClass('accessibility');
                }
            }
        },

        toggleAccessibility: function(event) {
            if(event) event.preventDefault();

            var hasAccessibility = Adapt.config.get('_accessibility')._isActive;

            var toggleAccessibility = (hasAccessibility) ? false : true;

            Adapt.config.get('_accessibility')._isActive = toggleAccessibility;

            this.configureAccessibility();

            this.setupUsageInstructions();

            this.render();

            this.trigger('accessibility:toggle');
        },

        configureAccessibility: function() {

            var isActive = Adapt.config.get('_accessibility')._isActive;

            if (!Modernizr.touch && (Adapt.offlineStorage.get('a11y') !== isActive)) {
                Adapt.offlineStorage.set("a11y", isActive);
            }

            if (isActive) {

                _.extend($.a11y.options, {
                    isTabbableTextEnabled: true,
                    isUserInputControlEnabled: true,
                    isFocusControlEnabled: true,
                    isFocusLimited: true,
                    isRemoveNotAccessiblesEnabled: true,
                    isAriaLabelFixEnabled: true,
                    isFocusWrapEnabled: true,
                    isScrollDisableEnabled: true,
                    isScrollDisabledOnPopupEnabled: false,
                    isSelectedAlertsEnabled: true,
                    isAlertsEnabled: true
                });
            } else {
                _.extend($.a11y.options, {
                    isTabbableTextEnabled: false,
                    isUserInputControlEnabled: true,
                    isFocusControlEnabled: true,
                    isFocusLimited: false,
                    isRemoveNotAccessiblesEnabled: true,
                    isAriaLabelFixEnabled: true,
                    isFocusWrapEnabled: true,
                    isScrollDisableEnabled: true,
                    isScrollDisabledOnPopupEnabled: false,
                    isSelectedAlertsEnabled: false,
                    isAlertsEnabled: false
                });
            }

            $.a11y.ready();
        },

        setupUsageInstructions: function() {
            if (!this.model.get("_accessibility") || !this.model.get("_accessibility")._accessibilityInstructions) {
                $("#accessibility-instructions").remove();
                return;
            }

            var instructionsList =  this.model.get("_accessibility")._accessibilityInstructions;

            var usageInstructions;
            if (instructionsList[Adapt.device.browser]) {
                usageInstructions = instructionsList[Adapt.device.browser];
            } else if (Modernizr.touch) {
                usageInstructions = instructionsList.touch || "";
            } else {
                usageInstructions = instructionsList.notouch || "";
            }

           $("#accessibility-instructions").html( usageInstructions );
        }

    });

    return AccessibilityView;

});
define('extensions/adapt-contrib-languagePicker/js/languagePickerNavigationView',[
    'core/js/adapt',
    './accessibilityView'
], function(Adapt, AccessibilityView) {

    var NavigationView = Backbone.View.extend({

        className: "navigation",

        initialize: function() {
            this.listenToOnce(Adapt, 'accessibility:toggle', this.onA11yToggle);
            this.template = "languagePickerNavigation";
            this.setupHelpers();
            this.preRender();
        },

        preRender: function() {
            Adapt.trigger('navigationView:preRender', this);
            this.render();
        },

        render: function() {
            var template = Handlebars.templates[this.template];
            this.$el.html(template(
                {
                    _config: this.model.get("_accessibility"),
                    _accessibility: Adapt.config.get("_accessibility")
                }
            )).insertBefore('#wrapper');

            _.defer(_.bind(function() {
                Adapt.trigger('navigationView:postRender', this);
            }, this));

            this.setupA11yButton();

            if (Adapt.accessibility.isActive()) {
                this.setupUsageInstructions();
            }

            return this;
        },

        setupHelpers: function() {
            var config = Adapt.config.get("_accessibility");

            Handlebars.registerHelper('a11y_text', function(text) {
                //ALLOW ENABLE/DISABLE OF a11y_text HELPER
                if (config && config._isTextProcessorEnabled === false) {
                    return text;
                } else {
                    return $.a11y_text(text);
                }
            });

            Handlebars.registerHelper('a11y_aria_label', function(text) {
                return '<div class="aria-label prevent-default" tabindex="0" role="region">'+text+'</div>';
            });
        },

        setupA11yButton: function() {
            new AccessibilityView({model:this.model});
        },

        setupUsageInstructions: function() {
            var config = this.model.get("_accessibility");

            if (!config || !config._accessibilityInstructions) {
                this.$('#accessibility-instructions').remove();
                return;
            }

            var instructionsList = config._accessibilityInstructions;

            var usageInstructions;
            if (instructionsList[Adapt.device.browser]) {
                usageInstructions = instructionsList[Adapt.device.browser];
            } else if (Modernizr.touch) {
                usageInstructions = instructionsList.touch || "";
            } else {
                usageInstructions = instructionsList.notouch || "";
            }

           this.$('#accessibility-instructions').html( usageInstructions );
        },

        onA11yToggle:function() {
            // listen once because if a11y active on launch instructions will already be setup
            
            if (Adapt.accessibility.isActive()) {
                this.setupUsageInstructions();
            }
        }

    });

    return NavigationView;

});
define('extensions/adapt-contrib-languagePicker/js/languagePickerView',[
    'core/js/adapt',
    './languagePickerNavigationView'
], function(Adapt, NavigationView) {
    
    var LanguagePickerView = Backbone.View.extend({
        
        events: {
            'click .languagepicker-languages button': 'onLanguageClick'
        },
        
        className: 'languagepicker',
        
        initialize: function () {
            this.initializeAccessibility();
            $("html").addClass("in-languagepicker");
            this.listenTo(Adapt, 'remove', this.remove);
            this.render();
        },
        
        render: function () {
            var data = this.model.toJSON();
            var template = Handlebars.templates[this.constructor.template];
            this.$el.html(template(data));
            this.$el.addClass(data._classes);

            document.title = this.model.get('title') || "";
            
            _.defer(_.bind(function () {
                this.postRender();
            }, this));
        },
        
        postRender: function () {
            $('.loading').hide();
        },
        
        onLanguageClick: function (event) {
            this.destroyAccessibility();
            this.model.setLanguage($(event.target).val());
        },

        initializeAccessibility: function() {
            this.navigationView = new NavigationView({model:this.model});
            
            // we need to re-render if accessibility gets switched on
            this.listenTo(Adapt, 'accessibility:toggle', this.render);
        },

        destroyAccessibility: function() {
            this.navigationView.remove();
        },

        remove: function() {
            $("html").removeClass("in-languagepicker");

            Backbone.View.prototype.remove.apply(this, arguments);
        }
        
    }, {
        template: 'languagePickerView'
    });

    return LanguagePickerView;

});

define('extensions/adapt-contrib-languagePicker/js/languagePickerDrawerView',[
    'core/js/adapt',
    'backbone'
], function(Adapt, Backbone) {
    
    var LanguagePickerDrawerView = Backbone.View.extend({
        
        events: {
            'click button': 'onButtonClick'
        },
        
        initialize: function () {
            this.listenTo(Adapt, 'remove', this.remove);
            this.listenTo(Adapt, 'languagepicker:changelanguage:yes', this.onDoChangeLanguage);
            this.listenTo(Adapt, 'languagepicker:changelanguage:no', this.onDontChangeLanguage);
            this.render();
        },
        
        render: function () {
            var data = this.model.toJSON();
            var template = Handlebars.templates[this.constructor.template];
            this.$el.html(template(data));
        },
        
        onButtonClick: function (event) {
            var newLanguage = $(event.target).attr('data-language');
            this.model.set('newLanguage', newLanguage);
            var data = this.model.getLanguageDetails(newLanguage);
            
            var promptObject = {
                _classes: "dir-ltr",
                title: data.warningTitle,
                body: data.warningMessage,
                _prompts:[
                    {
                        promptText: data._buttons.yes,
                        _callbackEvent: "languagepicker:changelanguage:yes"
                    },
                    {
                        promptText: data._buttons.no,
                        _callbackEvent: "languagepicker:changelanguage:no"
                    }
                ],
                _showIcon: true
            };

            if (data._direction === 'rtl') {
                promptObject._classes = "dir-rtl";
            }
            
            //keep active element incase the user cancels - usually navigation bar icon
            this.$finishFocus = $.a11y.state.focusStack.pop();
            //move drawer close focus to #focuser
            $.a11y.state.focusStack.push($("#focuser"));

            Adapt.once('drawer:closed', function() {
                //wait for drawer to fully close
                _.delay(function(){
                    //show yes/no popup
                    Adapt.once('popup:opened', function() {
                        //move popup close focus to #focuser
                        $.a11y.state.focusStack.pop();
                        $.a11y.state.focusStack.push($("#focuser"));
                    });

                    Adapt.trigger('notify:prompt', promptObject);
                }, 250);
            });

            Adapt.trigger('drawer:closeDrawer');
        },
        
        onDoChangeLanguage: function () {
            // set default languge
            var newLanguage = this.model.get('newLanguage');
            this.model.setLanguage(newLanguage);
            this.remove();
        },
        
        onDontChangeLanguage: function () {
            this.remove();

            //wait for notify to close fully
            _.delay(_.bind(function(){
                //focus on navigation bar icon
                this.$finishFocus.a11y_focus();
            }, this), 500);

        }
        
    }, {
        template: 'languagePickerDrawerView'
    });

    return LanguagePickerDrawerView;

});

define('extensions/adapt-contrib-languagePicker/js/languagePickerNavView',[
    'core/js/adapt',
    'backbone',
    './languagePickerDrawerView'
], function(Adapt, Backbone, LanguagePickerDrawerView) {
    
    var LanguagePickerNavView = Backbone.View.extend({
        
        tagName: 'button',
        
        className: function () {
            var classNames = 'languagepicker-icon base icon';
            var customClass = this.model.get('_languagePickerIconClass') || 'icon-language-2';

            return classNames + ' ' + customClass;
        },
        
        events: {
            'click': 'onClick'
        },
        
        initialize: function () {
            this.listenTo(Adapt, 'remove', this.remove);
        },
        
        onClick: function (event) {
            Adapt.drawer.triggerCustomView(new LanguagePickerDrawerView({model: this.model}).$el, false);
        }
        
    });

    return LanguagePickerNavView;

});

define('extensions/adapt-contrib-languagePicker/js/languagePickerModel',[
        'core/js/adapt',
        'backbone'
], function (Adapt, Backbone) {
    
    var LanguagePickerModel = Backbone.Model.extend({
        
        defaults: {
            "_isEnabled": false,
            "displayTitle": "",
            "body": "",
            "_languages": []
        },
        
        initialize: function () {
            this.listenTo(Adapt.config, 'change:_activeLanguage', this.onConfigChange);
        },

        getLanguageDetails: function (language) {
            var _languages = this.get('_languages');
            return _.find(_languages, function (item) {
                return (item._language == language);
            });
        },

        setLanguage: function (language) {
            Adapt.config.set({
                '_activeLanguage': language,
                '_defaultDirection': this.getLanguageDetails(language)._direction
            });
        },
        
        onConfigChange: function (model, value, options) {
            this.markLanguageAsSelected(value);
        },
        
        markLanguageAsSelected: function(language) {
            var languages = this.get('_languages');

            for (var i = 0; i < languages.length; i++) {
                if (languages[i]._language === language) {
                    languages[i]._isSelected = true;
                } else {
                    languages[i]._isSelected = false;
                }
            }

            this.set('_languages', languages);
        }
        
    });
    
    return LanguagePickerModel;
    
});

define('extensions/adapt-contrib-languagePicker/js/adapt-languagePicker',[
    'core/js/adapt',
    'backbone',
    './languagePickerView',
    './languagePickerNavView',
    './languagePickerModel'
], function(Adapt, Backbone, LanguagePickerView, LanguagePickerNavView, LanguagePickerModel) {

    var languagePickerModel;

    Adapt.once('configModel:dataLoaded', onConfigLoaded);

    /**
     * Once the Adapt config has loaded, check to see if the language picker is enabled. If it is:
     * - stop the rest of the .json from loading
     * - set up the language picker model
     * - register for events to allow us to display the language picker icon in the navbar on pages and menus
     * - wait for offline storage to be ready so that we can check to see if there's a stored language choice or not
     */
    function onConfigLoaded() {
        if (!Adapt.config.has('_languagePicker')) return;
        if (!Adapt.config.get('_languagePicker')._isEnabled) return;
    
        Adapt.config.set("_canLoadData", false);

        languagePickerModel = new LanguagePickerModel(Adapt.config.get('_languagePicker'));
        
        Adapt.on('router:page', setupNavigationView);
        Adapt.on('router:menu', setupNavigationView);
            
        if(Adapt.offlineStorage.ready) {// on the offchance that it may already be ready...
            onOfflineStorageReady();
        } else {
            Adapt.once('offlineStorage:ready', onOfflineStorageReady);
        }
    }

    /**
     * Once offline storage is ready, check to see if a language was previously selected by the user
     * If it was, load it. If it wasn't, show the language picker
     */
    function onOfflineStorageReady() {
        var storedLanguage = Adapt.offlineStorage.get("lang");

        if (storedLanguage) {
            languagePickerModel.setLanguage(storedLanguage);
        } else if (languagePickerModel.get('_showOnCourseLoad') === false) {
            languagePickerModel.setLanguage(Adapt.config.get('_defaultLanguage'));
        } else {
            showLanguagePickerView();
        }
    }

    function showLanguagePickerView () {
        var languagePickerView = new LanguagePickerView({
            model: languagePickerModel
        });
        
        languagePickerView.$el.appendTo('#wrapper');
    }
    
    function setupNavigationView () {
        /* 
         * On the framework this isn't an issue, but courses built in the authoring tool before the ARIA label 
         * was added will break unless the extension is removed then added again.
         */
        var courseGlobals = Adapt.course.get('_globals')._extensions;
        var navigationBarLabel = '';
        if (courseGlobals._languagePicker) {
            navigationBarLabel = courseGlobals._languagePicker.navigationBarLabel;
        }

        var languagePickerNavView = new LanguagePickerNavView({
            model: languagePickerModel,
            attributes:  {
                "aria-label": navigationBarLabel
            }
        });
        
        languagePickerNavView.$el.appendTo('.navigation-inner');
    }
    
});

define('extensions/adapt-contrib-trickle/js/trickleView',[
    'core/js/adapt'
], function(Adapt) {

    var TrickleView = Backbone.View.extend({

        isSteplocked: false,

        completionAttribute : null,

        initialize: function(options) {
            this.setupEventListeners();
        },

        setupEventListeners: function() {
            var AdaptEvents = {
                "trickle:kill": this.onKill,
                "remove": this.onRemove
            };

            this.onPreRender(this);

            AdaptEvents[this.model.get("_type") + "View:postRender"] = this.onPostRender;
            this.listenTo(Adapt, AdaptEvents);

            this.on("steplock", this.onStepLock);
            this.on("stepunlock", this.onStepUnlock);
        },

        onPreRender: function(view) {
            this.completionAttribute = Adapt.trickle.getCompletionAttribute();
            if (!this.isElementEnabled()) return;

            Adapt.trigger("trickle:preRender", this);
        },

        onPostRender: function(view) {
            if (view.model.get("_id") !== this.model.get("_id")) return;
            if (!this.isElementEnabled()) return;

            Adapt.trigger("trickle:postRender", this);
        },

        isElementEnabled: function() {
            var trickle = Adapt.trickle.getModelConfig(this.model);
            if (!trickle) return false;

            if (this.model.get(this.completionAttribute)) return false;

            var isArticleWithOnChildren = (this.model.get("_type") === "article" && trickle._onChildren);
            if (isArticleWithOnChildren) {
                return false;
            }

            if (trickle._isEnabled === true) return true;
            return false;
        },

        onStepLock: function() {
            if (!this.isElementEnabled()) {
                this.continueToNext();
                return;
            }

            var trickle = Adapt.trickle.getModelConfig(this.model);
            var isSteplocking = (trickle._stepLocking && trickle._stepLocking._isEnabled);
            if (!isSteplocking) {
                this.continueToNext();
                return;
            }

            Adapt.trigger("trickle:steplock", this);
            this.isSteplocked = true;
        },

        continueToNext: function() {
            _.defer(function() {
                Adapt.trigger("trickle:continue", this);
            }.bind(this));
        },


        onStepUnlock: function() {
            if (!this.isSteplocked) return;
            this.isSteplocked = false;
            Adapt.trigger("trickle:stepunlock", this);
        },

        onKill: function() {
            this.detachFromElement();
        },

        onRemove: function() {
            this.detachFromElement();
        },

        detachFromElement: function() {
            this.undelegateEvents();
            this.stopListening();
            this.model = null;
            this.articleModel = null;
            this.$el = null;
            this.el = null;
        }

    });

    return TrickleView;

});

define('extensions/adapt-contrib-trickle/js/pageView',[
    'core/js/adapt',
    './trickleView'
], function(Adapt, TrickleView) {

    var PageView = Backbone.View.extend({

        currentDescendantIndex: 0,
        currentLocksOnDescendant: 0,
        currentDescendant: null,

        initialize: function(options) {
            if (!this.isPageEnabled()) {
                return this.detachFromPage();
            }
            this.setupDescendants();
            if (!this.haveDescendantsGotTrickle()) {
                return this.detachFromPage();
            }
            this.addClassToHtml();
            this.setupEventListeners();
        },

        isPageEnabled: function() {
            var trickleConfig = Adapt.trickle.getModelConfig(this.model);
            if (trickleConfig && trickleConfig._isEnabled === false) return false;
            return true;
        },

        setupDescendants: function() {
            this.currentDescendant = null;
            this.descendantViews = {};
            this.getDescendants();
            Adapt.trigger("trickle:descendants", this);
        },

        descendantsChildFirst: null,
        descendantsParentFirst: null,
        descendantViews: null,

        getDescendants: function() {
            this.descendantsChildFirst = this.model.getAllDescendantModels();
            this.descendantsParentFirst = this.model.getAllDescendantModels(true);

            // if some descendants flip between _isAvailable true/false they
            // must have their defaults set before the filter is applied
            this.setDescendantsTrickleDefaults();

            this.descendantsChildFirst = this.filterComponents(this.descendantsChildFirst);
            this.descendantsParentFirst = this.filterComponents(this.descendantsParentFirst);

        },

        filterComponents: function(descendants) {
            return descendants.filter(function(descendant) {
                if (descendant.get("_type") === "component") return false;
                if (!descendant.get("_isAvailable")) return false;
                return true;
            });
        },

        setDescendantsTrickleDefaults: function() {
            // use parent first as likely to get to article
            this.descendantsParentFirst.forEach(function(descendant) {
                var trickle = Adapt.trickle.getModelConfig(descendant);
                if (!trickle) {
                    return;
                }

                // check if trickle is configures on descendant
                // NOTE: Removed for banked assessments
                // var isTrickleConfigured = descendant.get("_isTrickleConfigured");
                // if (isTrickleConfigured) return;

                // setup steplocking defaults
                trickle._stepLocking = _.extend({
                    "_isEnabled": true, //(default=true)
                    "_isCompletionRequired": true, //(default=true)
                    "_isLockedOnRevisit": false //(default=false)
                }, trickle._stepLocking);

                // setup main trickle defaults
                trickle = _.extend({
                    "_isEnabled": true, //(default=true)
                    "_autoScroll": true, //(default=true)
                    "_scrollDuration": 500, //(default=500)
                    "_onChildren": true, //(default=true)
                    "_scrollTo": "@block +1" //(default="@block +1")
                }, trickle);

                Adapt.trickle.setModelConfig(descendant, trickle);

                //check article "onChildren" rule
                if (trickle._onChildren &&
                    descendant.get("_type") === "article") {
                    this.setupArticleOnChildren(descendant, trickle);
                }

                // set descendant trickle as configured
                descendant.set("_isTrickleConfigured", true);

            }.bind(this));
        },

        setupArticleOnChildren: function(articleModel, articleTrickleConfig) {
            // set trickle on all blocks, using article config with block overrides
            var articleBlocks = articleModel.getChildren();

            articleBlocks.each(function(blockModel, index) {
                var blockTrickleConfig = Adapt.trickle.getModelConfig(blockModel);

                // overlay block trickle on article trickle
                // this allows values to carry through from the article to the block
                // retains any value overriden in the block
                for (var k in blockTrickleConfig) {
                    //handle nested objects to one level
                    if (typeof blockTrickleConfig[k] === "object") {
                        blockTrickleConfig[k] = _.extend({}, articleTrickleConfig[k], blockTrickleConfig[k]);
                    }
                }

                blockTrickleConfig = _.extend({}, articleTrickleConfig, blockTrickleConfig);


                // setup start/final config
                if (articleBlocks.length === index+1) {
                    blockTrickleConfig._isFinal = true;
                }
                if (index === 0) {
                    blockTrickleConfig._isStart = true;
                }

                Adapt.trickle.setModelConfig(blockModel, blockTrickleConfig);
            });

        },

        haveDescendantsGotTrickle: function() {
            return this.descendantsChildFirst.some(function(descendant) {
                var trickle = Adapt.trickle.getModelConfig(descendant);
                return trickle && trickle._isEnabled === true;
            });
        },

        addClassToHtml: function() {
            $("html").addClass("trickle");
        },

        setupEventListeners: function() {
            this.listenTo(Adapt, {
                "remove": this.onRemove,

                "articleView:preRender": this.onDescendantPreRender,
                "blockView:preRender": this.onDescendantPreRender,

                "trickle:unwait": this.onUnwait,
                "trickle:wait": this.onWait,
                "trickle:continue": this.onContinue,
                "trickle:skip": this.onSkip,

                "trickle:kill": this.onKill
            });
            this.listenToOnce(this.model, "change:_isReady", this.onPageReady);
        },

        onDescendantPreRender: function(view) {
            // ignore components
            if (view.model.get("_type") === "component") return;

            var descendantView = new TrickleView({
                model: view.model,
                el: view.el
            });
            this.descendantViews[view.model.get("_id")] = descendantView;
        },

        // trickle lifecycle

        onPageReady: function(model, value) {
            if (!value) return;

            this.currentDescendant = null;

            Adapt.trigger("trickle:started");
            this.gotoNextDescendant();
        },

        gotoNextDescendant: function() {
            this.getDescendants();

            if (this.currentDescendant) {
                this.currentDescendant.trigger("stepunlock");
                this.currentDescendant = null;
            }

            for (var index = this.currentDescendantIndex || 0, l = this.descendantsChildFirst.length; index < l; index++) {
                var descendant = this.descendantsChildFirst[index];
                switch ( descendant.get("_type") ) {
                    case "block":
                    case "article":
                        this.currentLocksOnDescendant = 0;
                        this.currentDescendantIndex = index;
                        var currentId = descendant.get("_id");
                        this.currentDescendant = this.descendantViews[currentId];
                        this.currentDescendant.trigger("steplock");
                        return;
                }
            }
            this.finished();
        },

        onContinue: function(view) {
            if (!this.currentDescendant) return;
            if (view.model.get("_id") !== this.currentDescendant.model.get("_id")) return;

            this.onSkip();
        },

        onWait: function() {
            this.currentLocksOnDescendant++;
        },

        onUnwait: function() {
            this.currentLocksOnDescendant--;
            if (this.currentLocksOnDescendant > 0) return;

            var lastDescendant = this.currentDescendant.model;

            this.currentDescendantIndex++;
            this.gotoNextDescendant();

            Adapt.trickle.scroll(lastDescendant);

        },

        onSkip: function() {
            // wait for all handlers to accept skip
            _.defer(function() {
                this.currentDescendantIndex++;
                this.gotoNextDescendant();
            }.bind(this));
        },

        onKill: function() {
            this.finished();
            this.detachFromPage();
        },

        finished: function() {
            Adapt.trigger("trickle:finished");
            this.detachFromPage();
        },

        // end of trickle lifecycle

        onRemove: function() {
            this.finished();
        },

        detachFromPage: function() {
            $("html").removeClass("trickle");
            this.undelegateEvents();
            this.stopListening();
            this.model = null;
            this.$el = null;
            this.el = null;
            this.currentDescendant = null;
            this.descendantViews = null;
            this.descendantsChildFirst = null;
            this.descendantsParentFirst = null;
            Adapt.trickle.pageView = null;
        }

    });

    return PageView;

});

define('extensions/adapt-contrib-trickle/js/handlers/buttonView',[
    'core/js/adapt',
    'core/js/views/componentView'
], function(Adapt, ComponentView) {

    var completionAttribute = "_isComplete";

    var TrickleButtonView = Backbone.View.extend({

        isStepLocking: false,
        hasStepLocked: false,
        isStepLocked: false,
        isStepLockFinished: false,
        hasStepPreCompleted: false,
        isWaitingForClick: false,
        allowVisible: false,
        allowEnabled: true,
        overlayShownCount: 0,

        el: function() {

            this.setupPreRender();

            return Handlebars.templates['trickle-button'](this.model.toJSON());
        },

        setupPreRender: function() {

            this.setupButtonVisible();
            this.setupButtonEnabled();
        },

        setupButtonVisible: function() {
            var trickle = Adapt.trickle.getModelConfig(this.model);
            this.allowVisible = false;
            trickle._button._isVisible = false;

            if (trickle._button._styleBeforeCompletion === "visible") {
                this.allowVisible = true;
                if (trickle._button._autoHide && trickle._button._isFullWidth) {
                    trickle._button._isVisible = false;
                } else {
                    trickle._button._isVisible = true;
                }
            }
        },

        setupButtonEnabled: function() {
            var trickle = Adapt.trickle.getModelConfig(this.model);

            if (trickle._stepLocking._isCompletionRequired === false) {
                this.allowEnabled = true;
                trickle._button._isDisabled = false;
            } else if (trickle._button._styleBeforeCompletion === "visible") {
                this.allowEnabled = false;
                trickle._button._isDisabled = true;
            } else {
                trickle._button._isDisabled = false;
                this.allowEnabled = true;
            }

        },

        events: {
            "click button": "onButtonClick"
        },

        initialize: function(options) {
            this.getCompletionAttribute();
            this.debounceCheckAutoHide();
            this.setupStepLocking();
            this.setupEventListeners();
        },

        getCompletionAttribute: function() {
            var trickle = Adapt.trickle.getModelConfig(Adapt.config);
            if (!trickle) return;
            if (!trickle._completionAttribute) return;
            completionAttribute = trickle._completionAttribute;
        },

        setupStepLocking: function() {
            var trickle = Adapt.trickle.getModelConfig(this.model);
            this.isStepLocked = Boolean(trickle._stepLocking._isEnabled);
        },

        setupEventListeners: function() {
            this.listenTo(Adapt, {
                "trickle:overlay": this.onOverlay,
                "trickle:unoverlay": this.onUnoverlay,
                "trickle:steplock": this.onStepLock,
                "trickle:stepunlock": this.onStepUnlock,
                "trickle:skip": this.onSkip,
                "trickle:kill": this.onKill,
                "trickle:update": this.onUpdate,
                "remove": this.onRemove
            });

            this.listenTo(this.model, "change:"+completionAttribute, this.onCompletion);
        },

        debounceCheckAutoHide: function() {
            this.checkButtonAutoHideSync = this.checkButtonAutoHide.bind(this);
            this.checkButtonAutoHide = _.debounce(this.checkButtonAutoHideSync, 100);
        },

        checkButtonAutoHide: function() {
            if (!this.allowVisible) {
                this.setButtonVisible(false);
                return;
            }

            var trickle = Adapt.trickle.getModelConfig(this.model);
            if (!trickle._button._autoHide) {
                this.setButtonVisible(true);
                return;
            } else if (this.overlayShownCount > 0) {
                this.setButtonVisible(false);
                return;
            }

            var measurements = this.$el.onscreen();

            // This is to fix common miscalculation issues
            var isJustOffscreen = (measurements.bottom > -100);

            // add show/hide animation here if needed
            if (measurements.onscreen || isJustOffscreen) {
                this.setButtonVisible(true);
            } else {
                this.setButtonVisible(false);
            }
        },

        setButtonVisible: function(isVisible) {
            var trickle = Adapt.trickle.getModelConfig(this.model);
            trickle._button._isVisible = Boolean(isVisible);
            this.$(".component-inner").toggleClass("display-none", !trickle._button._isVisible);
        },

        checkButtonEnabled: function() {
            this.setButtonEnabled(this.allowEnabled);
        },

        setButtonEnabled: function(isEnabled) {
            var trickle = Adapt.trickle.getModelConfig(this.model);
            var $button = this.$("button");
            if (isEnabled) {
                $button.removeClass("disabled").removeAttr("disabled");
                trickle._button._isDisabled = true;
                // make label unfocusable as it is no longer needed
                this.$('.aria-label').a11y_cntrl(false);
            } else {
                $button.addClass("disabled").attr("disabled", "disabled");
                trickle._button._isDisabled = false;
            }
        },

        onStepLock: function(view) {
            if (!this.isViewMatch(view)) return;

            this.hasStepLocked = true;
            this.isStepLocking = true;
            this.overlayShownCount = 0;

            var trickle = Adapt.trickle.getModelConfig(this.model);

            if (!this.isButtonEnabled()) return;
            var isCompleteAndShouldRelock = (trickle._stepLocking._isLockedOnRevisit &&
                this.model.get(completionAttribute));

            if (isCompleteAndShouldRelock) {
                this.isStepLocked = true;
                this.model.set("_isTrickleAutoScrollComplete", false);
                Adapt.trigger("trickle:wait");
                this.allowVisible = true;
                this.checkButtonAutoHide();
            } else if (this.hasStepPreCompleted) {
                // force the button to show if section completed before it was steplocked
                this.isStepLocked = true;
                this.model.set("_isTrickleAutoScrollComplete", false);
                this.allowVisible = true;
                this.stepCompleted();
            }
            this.setupOnScreenListener();
        },

        onOverlay: function() {
            this.overlayShownCount++;
        },

        onUnoverlay: function() {
            this.overlayShownCount--;
            this.checkButtonAutoHide();
        },

        setupOnScreenListener: function() {
            var trickle = Adapt.trickle.getModelConfig(this.model);

            if (!trickle._button._autoHide) return;
            this.$el.on("onscreen", this.checkButtonAutoHideSync);

        },

        isViewMatch: function(view) {
            return view.model.get("_id") === this.model.get("_id");
        },

        isButtonEnabled: function() {
            var trickle = Adapt.trickle.getModelConfig(this.model);

            if (!trickle._isEnabled || !trickle._button._isEnabled) return false;
            return true;
        },

        onCompletion: function(model, value) {
            if (value === false) return;

            this.hasStepPreCompleted = true;

            if (!this.hasStepLocked) return;

            _.defer(this.stepCompleted.bind(this));
        },

        stepCompleted: function() {

            if (this.isStepLockFinished) return;

            this.isStepLocked = false;
            this.allowVisible = false;
            this.allowEnabled = false;

            if (this.isButtonEnabled()) {
                if (this.isStepLocking) {

                    this.isStepLocked = true;
                    this.isWaitingForClick = true;
                    Adapt.trigger("trickle:wait");

                } else {

                    this.isStepLockFinished = true;
                }

                this.allowVisible = true;
                this.allowEnabled = true;
            }

            this.model.set("_isTrickleAutoScrollComplete", false);
            this.checkButtonAutoHide();
            this.checkButtonEnabled();

        },

        onButtonClick: function() {
            if (this.isStepLocked) {
                Adapt.trigger("trickle:unwait");
                this.isStepLocked = false;
                this.isStepLockFinished = true;

            } else {
                this.model.set("_isTrickleAutoScrollComplete", false);
                _.defer(function() {
                    Adapt.trickle.scroll(this.model);
                }.bind(this));
            }

            var trickle = this.model.get("_trickle");
            switch (trickle._button._styleAfterClick) {
            case "hidden":
                this.allowVisible = false;
                this.checkButtonAutoHideSync();
                break;
            case "disabled":
                this.allowEnabled = false;
                this.checkButtonAutoHideSync();
            }
        },

        onUpdate: function() {
            var trickle = Adapt.trickle.getModelConfig(this.model);

            if (trickle._button._autoHide && this.isStepLocking) {
                this.$el.off("onscreen", this.checkButtonAutoHideSync);
            }

            var $original = this.$el;
            var $newEl = $(Handlebars.templates['trickle-button'](this.model.toJSON()));
            $original.replaceWith($newEl);

            this.setElement($newEl);

            if (trickle._button._autoHide && this.isStepLocking) {
                this.$el.on("onscreen", this.checkButtonAutoHideSync);
            }
        },

        onStepUnlock: function(view) {
            if (!this.isViewMatch(view)) return;
            this.$el.off("onscreen", this.checkButtonAutoHideSync);
            this.isStepLocking = false;
            this.overlayShownCount = 0;
            // make label unfocusable as it is no longer needed
            this.$('.aria-label').a11y_cntrl(false);
        },

        onSkip: function() {
            if (!this.isStepLocking) return;

            this.onKill();
        },

        onKill: function() {
            this.$el.off("onscreen", this.checkButtonAutoHideSync);
            if (this.isWaitingForClick) {
                this.model.set("_isTrickleAutoScrollComplete", true);
            }
            this.isWaitingForClick = false;
            this.isStepLocked = false;
            this.isStepLocking = false;
            this.allowVisible = false;
            this.allowEnabled = false;
            this.isStepLockFinished = true;
            this.model.set("_isTrickleAutoScrollComplete", false);
            this.checkButtonAutoHide();
            this.checkButtonEnabled();
        },

        onRemove: function() {
            if (this.isWaitingForClick) {
                this.model.set("_isTrickleAutoScrollComplete", true);
            }
            this.isWaitingForClick = false;
            this.$el.off("onscreen", this.checkButtonAutoHideSync);
            this.isStepLocking = true;
            this.remove();
        }

    });

    return TrickleButtonView;
});

define('extensions/adapt-contrib-trickle/js/handlers/button',[
    'core/js/adapt',
    './buttonView'
], function(Adapt, ButtonView) {

    var TrickleButtonHandler = Backbone.Controller.extend({

        buttonViews: null,

        initialize: function() {
            this.listenToOnce(Adapt, {
                'app:dataReady': this.onAppDataReady,
                remove: this.onRemove
            });
        },

        onAppDataReady: function() {
            this.buttonViews = {};
            this.setupEventListeners();
        },

        setupEventListeners: function() {
            this.listenTo(Adapt, {
                'trickle:preRender': this.onPreRender,
                'trickle:postRender': this.onPostRender
            });
        },

        onPreRender: function(view) {
            // setup button on prerender to allow it to control the steplocking process
            if (!this.isTrickleEnabled(view.model)) return;

            this.setupConfigDefaults(view.model);

            this.buttonViews[view.model.get('_id')] = new ButtonView({
                model: view.model
            });
        },

        onPostRender: function(view) {
            // inject the button at post render
            if (!this.isTrickleEnabled(view.model)) return;

            view.$el.append(this.buttonViews[view.model.get('_id')].$el);
        },

        isTrickleEnabled: function(model) {
            var trickle = Adapt.trickle.getModelConfig(model);
            if (!trickle || !trickle._isEnabled) return false;

            if (trickle._onChildren && model.get('_type') === 'article') return false;

            return true;
        },

        setupConfigDefaults: function(model) {
            if (model.get('_isTrickleButtonConfigured')) return;

            var defaults = {
                _isEnabled: true,
                _styleBeforeCompletion: 'hidden',
                _styleAfterClick: 'hidden',
                _isFullWidth: true,
                _autoHide: false,
                _className: '',
                text: 'Continue',
                startText: 'Begin',
                finalText: 'Finish',
                _component: 'trickle-button',
                _isLocking: true,
                _isVisible: false,
                _isDisabled: false
            };

            var trickle = Adapt.trickle.getModelConfig(model);
            trickle._button = _.extend(defaults, trickle._button);

            if (trickle._button._isFullWidth) {
                trickle._stepLocking._isEnabled = true;
                trickle._button._styleAfterClick = 'hidden';
            } else {
                trickle._button._autoHide = false;
            }

            Adapt.trickle.setModelConfig(model, trickle);
            model.set('_isTrickleButtonConfigured', true);

        },

        onRemove: function() {
            this.buttonViews = {};
        }

    });

    return new TrickleButtonHandler();
});

define('extensions/adapt-contrib-trickle/js/handlers/completion',[
    'core/js/adapt'
], function(Adapt) {

    var completionAttribute = "_isComplete";

    var TrickleCompletionHandler = Backbone.Controller.extend({

        isStepLocking: false,
        isCompleted: false,

        stepModel: null,

        initialize: function() {
            this.listenToOnce(Adapt, "app:dataReady", this.onAppDataReady);
        },

        onAppDataReady: function() {
            this.getCompletionAttribute();
            this.setupEventListeners();
        },

        getCompletionAttribute: function() {
            var trickle = Adapt.trickle.getModelConfig(Adapt.config);
            if (!trickle) return;
            if (!trickle._completionAttribute) return;
            completionAttribute = trickle._completionAttribute;
        },

        setupEventListeners: function() {
            this.listenTo(Adapt, {
                "trickle:descendants": this.onDescendants,
                "trickle:steplock": this.onStepLock,
                "trickle:stepunlock": this.onStepUnlock,
                "trickle:kill": this.onKill,
                "remove": this.onRemove
            });
        },

        onDescendants: function(view) {
            // save the original completion state of the component before steplocking
            view.descendantsParentFirst.forEach(function(descendant) {
                var trickle = Adapt.trickle.getModelConfig(descendant);
                if (!trickle) return;
                trickle._wasCompletedPreRender = descendant.get(completionAttribute);
            });
        },

        onStepLock: function(view) {
            var isModelComplete = view.model.get(completionAttribute);

            var trickle = Adapt.trickle.getModelConfig(view.model);
            if (!trickle._stepLocking._isCompletionRequired &&
                !trickle._stepLocking._isLockedOnRevisit) {
                if (!isModelComplete) return;
                // skip any components that do not require completion but that are already complete
                // this is needed for a second visit to a page with 'inview'
                // components that aren't reset and don't require completion and are not relocked on revisit
                Adapt.trigger("trickle:continue", view);
                return;
            }

            if (trickle._stepLocking._isCompletionRequired
                && isModelComplete
                && trickle._wasCompletedPreRender) {
                // skip any components that are complete, have require completion
                // and we completed before the page rendered
                Adapt.trigger("trickle:continue", view);
                return;
            }

            Adapt.trigger("trickle:wait");

            if (isModelComplete) {
                _.defer(function() {
                    Adapt.trigger("trickle:unwait");
                });
                return;
            }

            view.model.set("_isTrickleAutoScrollComplete", false);
            this.isCompleted = false;
            this.isStepLocking = true;
            this.stepModel = view.model;

            this.listenTo(this.stepModel, "change:"+completionAttribute, this.onCompletion);
        },

        onCompletion: function(model, value) {
            if (value === false) return;
            _.defer(this.stepCompleted.bind(this));
        },

        stepCompleted: function() {

            if (!this.isStepLocking) return;

            if (this.isCompleted) return;
            this.isCompleted = true;

            this.stopListening(this.stepModel, "change:"+completionAttribute, this.onCompletion);

            _.defer(function(){
                Adapt.trigger("trickle:unwait");
            });
        },

        onKill: function() {
            this.onStepUnlock();
        },

        onRemove: function() {
            this.onStepUnlock();
        },

        onStepUnlock: function() {
            this.stopListening(this.stepModel, "change:"+completionAttribute, this.onCompletion);
            this.isStepLocking = false;
            this.stepModel = null;
            this.isCompleted = false;
        }

    });

    return new TrickleCompletionHandler();

});

define('extensions/adapt-contrib-trickle/js/handlers/notify',[
    'core/js/adapt'
], function(Adapt) {

    var TrickleNotifyHandler = Backbone.Controller.extend({

        isStepLocking: false,
        isNotifyOpen: false,

        initialize: function() {
            this.listenToOnce(Adapt, "app:dataReady", this.onAppDataReady);
        },

        onAppDataReady: function() {
            this.setupEventListeners();
        },

        setupEventListeners: function() {
            this.listenTo(Adapt, {
                "trickle:steplock": this.onStepLock,
                "notify:opened": this.onNotifyOpened,
                "notify:closed": this.onNotifyClosed,
                "trickle:stepunlock": this.onStepUnlock,
                "remove": this.onRemove
            });
        },

        onStepLock: function(view) {
            this.isStepLocking = true;
        },

        onNotifyOpened: function() {
            if (!this.isStepLocking) return;

            this.isNotifyOpen = true;
            Adapt.trigger("trickle:overlay");
            Adapt.trigger("trickle:wait");
        },

        onNotifyClosed: function() {
            if (!this.isStepLocking) return;
            if (!this.isNotifyOpen) return;

            this.isNotifyOpen = false;
            Adapt.trigger("trickle:unoverlay");
            Adapt.trigger("trickle:unwait");
        },

        onStepUnlock: function() {
            this.isStepLocking = false;
        },

        onRemove: function() {
            this.onStepUnlock();
        }

    });

    return new TrickleNotifyHandler();

});

define('extensions/adapt-contrib-trickle/js/handlers/resize',[
    'core/js/adapt'
], function(Adapt) {

    var TrickleBodyResizeHandler = Backbone.Controller.extend({

        isStepLocking: false,

        stepView: null,

        initialize: function() {
            this.listenToOnce(Adapt, {
                "app:dataReady": this.onAppDataReady,
                "adapt:initialize": this.onAdaptInitialized
            });
        },

        onAppDataReady: function() {
            this.onResize = _.debounce(this.onResize.bind(this), 10);
            this.preventWrapperScroll = this.preventWrapperScroll.bind(this);
            this.setupEventListeners();
        },

        setupEventListeners: function() {
            this.listenTo(Adapt, {
                "trickle:steplock": this.onStepLock,
                "trickle:resize": this.onTrickleResize,
                "trickle:stepunlock": this.onStepUnlock,
                "trickle:kill": this.onKill,
                "trickle:finished": this.onFinished,
                "remove": this.onRemove
            });
        },

        onAdaptInitialized: function() {
            this.wrapper = document.getElementById('wrapper');
            this.wrapper.addEventListener("scroll", this.preventWrapperScroll);
        },

        onStepLock: function(view) {
            this.isStepLocking = true;
            this.stepView = view;
            $(window).on("resize", this.onResize);
            $(".page").on("resize", this.onResize);

            // wait for height / visibility to adjust
            _.defer(function() {
                Adapt.trigger("trickle:resize");
            });
        },

        preventWrapperScroll: function(event) {
            if (!this.isStepLocking) return;
            // Screen reader can scroll the #wrapper instead of the window.
            // This code overcomes that behaviour.
            var top = this.wrapper.scrollTop;
            if (top === 0) return;
            this.wrapper.scrollTop = 0;
            window.scrollTo(0, window.pageYOffset + top);
        },

        onResize: function() {
            if (!this.isStepLocking) return;
            Adapt.trigger("trickle:resize");
        },

        onTrickleResize: function() {
            if (!this.isStepLocking) return;
            var offset = this.stepView.$el.offset();
            var height = this.stepView.$el.height();

            var $wrapper = $(this.wrapper);

            var topPadding = parseInt($wrapper.css("padding-top") || "0");

            var bottom = (offset['top'] - topPadding) + height;

            $wrapper.css("height", bottom );
        },

        onStepUnlock: function(view) {
            this.isStepLocking = false;
            this.stepView = null;
            $(window).off("resize", this.onResize);
            $(".page").off("resize", this.onResize);
        },

        onKill: function() {
            this.onFinished();
            this.onStepUnlock();
        },

        onFinished: function() {
            this.wrapper.removeEventListener("scroll", this.preventWrapperScroll);
            $(this.wrapper).css("height", "");
        },

        onRemove: function() {
            this.onStepUnlock();
            this.stepView = null;
        }

    });

    return new TrickleBodyResizeHandler();

});

define('extensions/adapt-contrib-trickle/js/handlers/tutor',[
    'core/js/adapt'
], function(Adapt) {

    var TrickleTutorHandler = Backbone.Controller.extend({

        stepLockedId: null,
        isStepLocking: false,
        isTutorOpen: false,

        initialize: function() {
            this.listenToOnce(Adapt, "app:dataReady", this.onAppDataReady);
        },

        onAppDataReady: function() {
            this.setupEventListeners();
        },

        setupEventListeners: function() {
            this.listenTo(Adapt, {
                "trickle:steplock": this.onStepLock,
                "tutor:opened": this.onTutorOpened,
                "tutor:closed": this.onTutorClosed,
                "trickle:stepunlock": this.onStepUnlock,
                "remove": this.onRemove
            });
        },

        onStepLock: function(view) {
            if (view) {
                this.stepLockedId = view.model.get("_id");
            }
            this.isStepLocking = true;
        },

        onTutorOpened: function(view, alertObject) {
            if (!this.isStepLocking) return;
            if (!this.isOriginStepLocked(view)) return;

            this.isTutorOpen = true;
            Adapt.trigger("trickle:overlay");
            Adapt.trigger("trickle:wait");
        },

        isOriginStepLocked: function(view) {
            if (!view || !this.stepLockedId) return true;

            var parents = view.model.getAncestorModels();
            var hasStepLockedParent = _.find(parents, function(ancestor) {
                return ancestor.get('_id') === this.stepLockedId;
            }, this);
            if (!hasStepLockedParent) return false;
            return true;
        },

        onTutorClosed: function(view, alertObject) {
            if (!this.isStepLocking) return;
            if (!this.isTutorOpen) return;
            if (!this.isOriginStepLocked(view)) return;

            this.isTutorOpen = false;
            Adapt.trigger("trickle:unoverlay");
            Adapt.trigger("trickle:unwait");
        },

        onStepUnlock: function() {
            this.isStepLocking = false;
            this.stepLockedId = null;
        },

        onRemove: function() {
            this.onStepUnlock();
        }

    });

    return new TrickleTutorHandler();

});

define('extensions/adapt-contrib-trickle/js/handlers/visibility',[
    'core/js/adapt'
], function(Adapt) {

    var TrickleVisibilityHandler = Backbone.Controller.extend({

        isStepLocking: false,

        trickleModel: null,

        initialize: function() {
            this.listenToOnce(Adapt, "app:dataReady", this.onAppDataReady);
        },

        onAppDataReady: function() {
            this.setupEventListeners();
        },

        setupEventListeners: function() {
            this.listenTo(Adapt, {
                "trickle:steplock": this.onStepLock,
                "trickle:visibility": this.onVisibility,
                "trickle:stepunlock": this.onStepUnlock,
                "trickle:kill": this.onKill,
                "trickle:finished": this.onFinished,
                "remove": this.onRemove
            });

        },

        onStepLock: function(view) {
            this.isStepLocking = true;
            this.trickleModel = view.model;
            Adapt.trigger("trickle:visibility");
        },

        onVisibility: function() {
            if (!this.isStepLocking) return;

            if (!Adapt.trickle.pageView) return;

            var descendantsParentFirst = Adapt.trickle.pageView.descendantsParentFirst;

            var trickleModelId = this.trickleModel.get("_id");
            var trickleType = this.trickleModel.get("_type");

            var atIndex = _.findIndex(descendantsParentFirst, function(descendant) {
                if (descendant.get("_id") === trickleModelId) return true;
            });

            descendantsParentFirst.forEach(function(descendant, index) {
                var components = descendant.findDescendantModels("components");
                if (index <= atIndex) {
                    descendant.set("_isVisible", true, {pluginName:"trickle"});
                    components.forEach(function(componentModel) {
                        componentModel.set("_isVisible", true, {pluginName:"trickle"});
                    });
                    return;
                }

                if (trickleType === "article" && descendant.get("_type") === "block") {
                    // make sure article blocks are shown
                    if (descendant.get("_parentId") === trickleModelId) {
                        descendant.set("_isVisible", true, {pluginName:"trickle"});
                        components.forEach(function(componentModel) {
                            componentModel.set("_isVisible", true, {pluginName:"trickle"});
                        });
                        return;
                    }
                }

                descendant.set("_isVisible", false, {pluginName:"trickle"});
                components.forEach(function(componentModel) {
                    componentModel.set("_isVisible", false, {pluginName:"trickle"});
                });

            });

        },

        onStepUnlock: function(view) {
            this.isStepLocking = false;
            this.trickleModel = null;
        },

        onKill: function() {
            this.onFinished();
            this.onStepUnlock();
        },

        onFinished: function() {

            var descendantsParentFirst = Adapt.trickle.pageView.descendantsParentFirst;
            descendantsParentFirst.forEach(function(descendant) {
                descendant.set("_isVisible", true, {pluginName:"trickle"});
                var components = descendant.findDescendantModels("components");
                components.forEach(function(componentModel) {
                    componentModel.set("_isVisible", true, {pluginName:"trickle"});
                });
            });

        },

        onRemove: function() {
            this.onStepUnlock();
        }

    });

    return new TrickleVisibilityHandler();

});

define('extensions/adapt-contrib-trickle/js/handlers/done',[
    'core/js/adapt'
], function(Adapt) {

    var TrickleDone = Backbone.Controller.extend({

        initialize: function() {
            this.listenToOnce(Adapt, "app:dataReady", this.onAppDataReady);
        },

        onAppDataReady: function() {
            this.setupEventListeners();
        },

        setupEventListeners: function() {
            this.onDone = _.debounce(this.onDone.bind(this), 50);
            this.listenTo(Adapt, {
                "trickle:steplock": this.onDone,
                "trickle:stepunlock": this.onDone,
                "trickle:continue": this.onDone,
                "trickle:finished": this.onDone
            });
        },

        onDone: function() {
            Adapt.trigger("trickle:done");
        }

    });

    return new TrickleDone();

});

define('extensions/adapt-contrib-trickle/js/adapt-contrib-trickle',[
    'core/js/adapt',
    './pageView',
    './handlers/button',
    './handlers/completion',
    './handlers/notify',
    './handlers/resize',
    './handlers/tutor',
    './handlers/visibility',
    './handlers/done'
], function(Adapt, PageView) {

    var Trickle = Backbone.Controller.extend({

        model: null,
        pageView: null,

        initialize: function() {
            this.listenToOnce(Adapt, {
                "app:dataReady": this.onAppDataReady
            });
        },

        onAppDataReady: function() {
            this.getCourseModel();
            if (!this.isCourseEnabled()) return;
            this.setupListeners();
        },

        getCourseModel: function() {
            this.model = Adapt.course;
        },

        isCourseEnabled: function() {
            var trickleConfig = this.getModelConfig(this.model);
            if (trickleConfig && trickleConfig._isEnabled === false) return false;
            return true;
        },

        getModelConfig: function(model) {
            return model.get("_trickle");
        },

        getCompletionAttribute: function() {
            var trickle = this.getModelConfig(Adapt.config);
            if (!trickle) return "_isComplete";
            return trickle._completionAttribute || "_isComplete";
        },

        setModelConfig: function(model, config) {
            return model.set("_trickle", config);
        },

        setupListeners: function() {
            this.listenTo(Adapt, {
                "pageView:preRender": this.onPagePreRender,
                "remove": this.onRemove
            });
        },

        onPagePreRender: function(view) {
            this.pageView = new PageView({
                model: view.model,
                el: view.el
            });
        },

        scroll: function(fromModel) {
            // Wait for model visibility to handle
            _.delay(function() {

                if (!this.shouldScrollPage(fromModel)) return;

                var trickle = Adapt.trickle.getModelConfig(fromModel);
                var scrollTo = trickle._scrollTo;
                if (scrollTo === undefined) scrollTo = "@block +1";

                fromModel.set("_isTrickleAutoScrollComplete", true);

                var scrollToId = "";
                switch (scrollTo.substr(0,1)) {
                    case "@":
                        // NAVIGATE BY RELATIVE TYPE

                        // Allows trickle to scroll to a sibling / cousin component
                        // relative to the current trickle item
                        var relativeModel = fromModel.findRelativeModel(scrollTo, {
                            filter: function(model) {
                                return model.get("_isAvailable");
                            }
                        });

                        if (relativeModel === undefined) return;
                        scrollToId = relativeModel.get("_id");
                        break;
                    case ".":
                        // NAVIGATE BY CLASS
                        scrollToId = scrollTo.substr(1, scrollTo.length-1);
                        break;
                    default:
                        scrollToId = scrollTo;
                }

                if (scrollToId == "") return;

                var isAutoScrollOff = (!trickle._autoScroll);
                if (isAutoScrollOff) {
                    $("." + scrollToId).focusOrNext();
                    return false;
                }

                var duration = fromModel.get("_trickle")._scrollDuration || 500;
                Adapt.scrollTo("." + scrollToId, { duration: duration });

            }.bind(this), 250);
        },

        shouldScrollPage: function(fromModel) {
            var trickle = Adapt.trickle.getModelConfig(fromModel);
            if (!trickle || !trickle._isEnabled) return false;

            var hasScrolled = fromModel.get("_isTrickleAutoScrollComplete");
            if (hasScrolled) return false;

            var isArticleWithOnChildren = (fromModel.get("_type") === "article" && trickle._onChildren);
            if (isArticleWithOnChildren) return false;

            return true;
        }

    });

    return Adapt.trickle = new Trickle();

});

define('extensions/adapt-contrib-tutor/js/adapt-contrib-tutor',[
    'coreJS/adapt'
],function(Adapt) {

    Adapt.on('questionView:showFeedback', function(view) {

        var alertObject = {
            title: view.model.get("feedbackTitle"),
            body: view.model.get("feedbackMessage")
        };

        var attributes = {};
        var classes = [];

        if (view.model.has('_isCorrect')) {
            // Attach specific classes so that feedback can be styled.
            if (view.model.get('_isCorrect')) {
                classes.push('correct');
            } else {
                if (view.model.has('_isAtLeastOneCorrectSelection')) {
                    // Partially correct feedback is an option.
                    if (view.model.get('_isAtLeastOneCorrectSelection')) {
                        classes.push('partially-correct');
                    } else {
                        classes.push('incorrect');
                    }
                } else {
                    classes.push('incorrect');
                }
            }
        }

        // Add the extension/component type which triggered this.
        if (view.model.has('_component')) {
            classes.push('component-' + view.model.get('_component'));
        } else if (view.model.has('_extension')) {
            classes.push('extension-' + view.model.get('_extension'));
        }

        // Add the _id property as attribute.
        attributes['data-adapt-id'] = view.model.get('_id');

        alertObject._classes = classes.join(' ');
        alertObject._attributes = attributes;

        Adapt.once("notify:closed", function() {
            Adapt.trigger("tutor:closed", view, alertObject);
        });

        Adapt.trigger('notify:popup', alertObject);

        Adapt.trigger('tutor:opened', view, alertObject);
    });

});

/*
 * adapt-contrib-xapi
 * License      - http://github.com/adaptlearning/adapt_framework/LICENSE
 * Maintainers  - Dennis Heaney <dennis@learningpool.com>
 *              - Barry McKay <barry@learningpool.com>
 *              - Brian Quinn <brian@learningpool.com>
 */
define('extensions/adapt-contrib-xapi/js/adapt-contrib-xapi',[
  'core/js/adapt',
  'core/js/enums/completionStateEnum',
  'libraries/async.min',
  'libraries/xapiwrapper.min',
  'libraries/url-polyfill.min'
], function(Adapt, COMPLETION_STATE, Async) {

  'use strict';

  /**
   * @callback ErrorOnlyCallback
   * @param {?Error} error
   */
  var xAPI = Backbone.Model.extend({

    /** Declare defaults and model properties */

    // Default model properties.
    defaults: {
      lang: 'en-US',
      displayLang: 'en-US',
      generateIds: false,
      activityId: null,
      actor: null,
      shouldTrackState: true,
      shouldUseRegistration: false,
      componentBlacklist: 'blank,graphic',
      isInitialised: false,
      state: {}
    },

    startAttemptDuration: 0,
    startTimeStamp: null,
    courseName: '',
    courseDescription: '',
    defaultLang: 'en-US',
    isComplete: false,

    // Default events to send statements for.
    coreEvents: {
      Adapt: {
        'router:page': false,
        'router:menu': false,
        'assessments:complete': true,
        'questionView:recordInteraction': true
      },
      contentObjects: {
        'change:_isComplete': false
      },
      articles: {
        'change:_isComplete': false
      },
      blocks: {
        'change:_isComplete': false
      },
      components: {
        'change:_isComplete': true
      }
    },

    // An object describing the core Adapt framework collections.
    coreObjects: {
      course: 'course',
      contentObjects: ['menu', 'page'],
      articles: 'article',
      blocks: 'block',
      components: 'component',
      offlineStorage: 'offlineStorage'
    },

    /** Implementation starts here */
    initialize: function() {
      if (!Adapt.config) {
        return;
      }

      this.config = Adapt.config.get('_xapi');

      if (!this.getConfig('_isEnabled')) {
        return this;
      }

      Adapt.wait.begin();

      // Initialize the xAPIWrapper.
      this.initializeWrapper(_.bind(function(error) {
        if (error) {
          this.onInitialised(error);
          return this;
        }

        this.set({
          activityId: (this.getLRSAttribute('activity_id') || this.getConfig('_activityID') || this.getBaseUrl()),
          displayLang: Adapt.config.get('_defaultLanguage'),
          lang: this.getConfig('_lang'),
          generateIds: this.getConfig('_generateIds'),
          shouldTrackState: this.getConfig('_shouldTrackState'),
          shouldUseRegistration: this.getConfig('_shouldUseRegistration') || false,
          componentBlacklist: this.getConfig('_componentBlacklist') || []
        });

        var componentBlacklist = this.get('componentBlacklist');

        if (!_.isArray(componentBlacklist)) {
          // Create the blacklist array and force the items to lowercase.
          componentBlacklist = componentBlacklist.split(/,\s?/).map(function(component) {
            return component.toLowerCase();
          });
        }

        this.set('componentBlacklist', componentBlacklist);

        if (!this.validateProps()) {
          var error = new Error('Missing required properties');
          Adapt.log.error('adapt-contrib-xapi: xAPI Wrapper initialisation failed', error);
          this.onInitialised(error);
          return this;
        }

        this.startTimeStamp = new Date();
        this.courseName = Adapt.course.get('displayTitle') || Adapt.course.get('title');
        this.courseDescription = Adapt.course.get('description') || '';

        // Send the 'launched' and 'initialized' statements.
        var statements = [
          this.getCourseStatement(ADL.verbs.launched),
          this.getCourseStatement(ADL.verbs.initialized)
        ];

        this.sendStatements(statements, _.bind(function(error) {
          if (error) {
            this.onInitialised(error);
            return this;
          }

          if (['ios', 'android'].indexOf(Adapt.device.OS) > -1) {
            $(document).on('visibilitychange', this.onVisibilityChange.bind(this));
          } else {
            $(window).on('beforeunload unload', this.sendUnloadStatements.bind(this));
          }

          if (!this.get('shouldTrackState')) {
            // xAPI is not managing the state.
            this.onInitialised();
            return this;
          }

          // Retrieve the course state.
          this.getState(_.bind(function(error) {
            if (error) {
              this.onInitialised(error);
              return this;
            }

            if (_.isEmpty(this.get('state'))) {
              // This is a new attempt, send 'attempted'.
              this.sendStatement(this.getCourseStatement(ADL.verbs.attempted));
            } else {
              // This is a continuation of an existing attempt, send 'resumed'.
              this.sendStatement(this.getCourseStatement(ADL.verbs.resumed));
            }

            this.restoreState();
            this.onInitialised();
            return this;
          }, this));
        }, this));
      }, this));
    },

    /**
     * Replace the hard-coded _learnerInfo data in _globals with the actual data from the LRS.
     */
    getLearnerInfo: function() {
      var globals = Adapt.course.get('_globals');

      if (!globals._learnerInfo) {
          globals._learnerInfo = {};
      }

      _.extend(globals._learnerInfo, Adapt.offlineStorage.get('learnerinfo'));
    },
  
    /**
     * Intializes the ADL xapiWrapper code.
     * @param {ErrorOnlyCallback} callback
     */
    initializeWrapper: function(callback) {
      // If no endpoint has been configured, assume the ADL Launch method.
      if (!this.getConfig('_endpoint')) {
        //check to see if configuration has been passed in URL
        this.xapiWrapper = window.xapiWrapper || ADL.XAPIWrapper;
        if (this.checkWrapperConfig()) {
          // URL had all necessary configuration so we continue using it.
          // Set the LRS specific properties.
          this.set({
            registration: this.getLRSAttribute('registration'),
            actor: this.getLRSAttribute('actor')
          });

          this.xapiWrapper.strictCallbacks = true;

          callback();
        } else {
          // If no endpoint is configured, assume this is using the ADL launch method.
          ADL.launch(_.bind(function(error, launchData, xapiWrapper) {
            if (error) {
              return callback(error);
            }

            // Initialise the xAPI wrapper.
            this.xapiWrapper = xapiWrapper;

            this.set({
              actor: launchData.actor
            });

            this.xapiWrapper.strictCallbacks = true;

            callback();
          }, this), true, true);
        }
      } else {
        // The endpoint has been defined in the config, so use the static values.
        // Initialise the xAPI wrapper.
        this.xapiWrapper = window.xapiWrapper || ADL.XAPIWrapper;

        // Set any attributes on the xAPIWrapper.
        var configError;
        try {
          this.setWrapperConfig();
        } catch (error) {
          configError = error;
        }

        if (configError) {
          return callback(error);
        }

        // Set the LRS specific properties.
        this.set({
          registration: this.getLRSAttribute('registration'),
          actor: this.getLRSAttribute('actor')
        });

        this.xapiWrapper.strictCallbacks = true;

        callback();
      }
    },

    /**
     * Triggers 'plugin:endWait' event (if required).
     */
    onInitialised: function(error) {
      this.set({ isInitialised: !!!error });

      Adapt.wait.end();

      _.defer(function() {
        if (error) {
          Adapt.trigger('xapi:lrs:initialize:error', error);
          return;
        }

        Adapt.trigger('xapi:lrs:initialize:success');
      });
    },

    onLanguageChanged: function(newLanguage) {
      // Update the language.
      this.set({ displayLang: newLanguage });

      // Since a language change counts as a new attempt, reset the state.
      this.deleteState(function() {
        // Send a statement to track the (new) course.
        this.sendStatement(this.getCourseStatement(ADL.verbs.launched));
      });
    },

    /**
     * Sends 'suspended' and 'terminated' statements to the LRS when the window
     * is closed or the browser app is minimised on a device. Sends a 'resume'
     * statement when switching back to a suspended session.
     */
    onVisibilityChange: function() {
      if (document.visibilityState === 'visible') {
        this.isTerminated = false;

        return this.sendStatement(this.getCourseStatement(ADL.verbs.resumed));
      }

      this.sendUnloadStatements();
    },

    // Sends (optional) 'suspended' and 'terminated' statements to the LRS.
    sendUnloadStatements: function() {
      if (this.isTerminated) {
        return;
      }

      var statements = [];

      if (!this.isComplete) {
        // If the course is still in progress, send the 'suspended' verb.
        statements.push(this.getCourseStatement(ADL.verbs.suspended));
      }

      // Always send the 'terminated' verb.
      statements.push(this.getCourseStatement(ADL.verbs.terminated));

      // Note: it is not possible to intercept these synchronous statements.
      this.sendStatementsSync(statements);

      this.isTerminated = true;
    },

    /**
    * Check Wrapper to see if all parameters needed are set.
    */
    checkWrapperConfig: function() {
      if (this.xapiWrapper.lrs.endpoint && this.xapiWrapper.lrs.actor
        && this.xapiWrapper.lrs.auth && this.xapiWrapper.lrs.activity_id ) {
          return true;
        } else {
          return false;
        }
    },

    /**
     * Attempt to extract endpoint, user and password from the config.json.
     */
    setWrapperConfig: function() {
      var keys = ['endpoint', 'user', 'password'];
      var newConfig = {};

      _.each(keys, function(key) {
        var val = this.getConfig('_' + key);

        if (val) {
          // Note: xAPI wrapper requires a trailing slash and protocol to be present
          if (key === 'endpoint') {
            val = val.replace(/\/?$/, '/');

            if (!/^https?:\/\//i.test(val)) {
              Adapt.log.warn('adapt-contrib-xapi: "_endpoint" value is missing protocol (defaulting to http://)');

              val = 'http://' + val;
            }
          }

          newConfig[key] = val;
        }
      }, this);

      if (!_.isEmpty(newConfig)) {
        this.xapiWrapper.changeConfig(newConfig);

        if (!this.xapiWrapper.testConfig()) {
          throw new Error('Incorrect xAPI configuration detected');
        }
      }
    },

    /**
     * Gets the URL the course is currently running on.
     * @return {string} The URL to the current course.
     */
    getBaseUrl: function() {
      var url = window.location.origin + window.location.pathname;

      Adapt.log.info('adapt-contrib-xapi: Using detected URL (' + url + ') as ActivityID');

      return url;
    },

    getAttemptDuration: function() {
      return this.startAttemptDuration + this.getSessionDuration();
    },

    getSessionDuration: function() {
      return Math.abs((new Date()) - this.startTimeStamp);
    },

    /**
     * Converts milliseconds to an ISO8601 duration
     * @param {int} inputMilliseconds - Duration in milliseconds
     * @return {string} - Duration in ISO8601 format
     */
    convertMillisecondsToISO8601Duration: function(inputMilliseconds) {
      var hours;
      var minutes;
      var seconds;
      var i_inputMilliseconds = parseInt(inputMilliseconds, 10);
      var i_inputCentiseconds;
      var inputIsNegative = '';
      var rtnStr = '';

      // Round to nearest 0.01 seconds.
      i_inputCentiseconds = Math.round(i_inputMilliseconds / 10);

      if (i_inputCentiseconds < 0) {
        inputIsNegative = '-';
        i_inputCentiseconds = i_inputCentiseconds * -1;
      }

      hours = parseInt(((i_inputCentiseconds) / 360000), 10);
      minutes = parseInt((((i_inputCentiseconds) % 360000) / 6000), 10);
      seconds = (((i_inputCentiseconds) % 360000) % 6000) / 100;

      rtnStr = inputIsNegative + 'PT';
      if (hours > 0) {
        rtnStr += hours + 'H';
      }

      if (minutes > 0) {
        rtnStr += minutes + 'M';
      }

      rtnStr += seconds + 'S';

      return rtnStr;
    },

    setupListeners: function() {
      if (!this.get('isInitialised')) {
        Adapt.log.warn('adapt-contrib-xapi: Unable to setup listeners for xAPI');
        return;
      }

      // Allow surfacing the learner's info in _globals.
      this.getLearnerInfo()

      this.listenTo(Adapt, 'app:languageChanged', this.onLanguageChanged);

      if (this.get('shouldTrackState')) {
        this.listenTo(Adapt, 'state:change', this.sendState);
      }

      // Use the config to specify the core events.
      this.coreEvents = _.extend(this.coreEvents, this.getConfig('_coreEvents'));

      // Always listen out for course completion.
      this.listenTo(Adapt, 'tracking:complete', this.onTrackingComplete);

      // Conditionally listen to the events.
      // Visits to the menu.
      if (this.coreEvents['Adapt']['router:menu']) {
        this.listenTo(Adapt, 'router:menu', this.onItemExperience);
      }

      // Visits to a page.
      if (this.coreEvents['Adapt']['router:page']) {
        this.listenTo(Adapt, 'router:page', this.onItemExperience);
      }

      // When an interaction takes place on a question.
      if (this.coreEvents['Adapt']['questionView:recordInteraction']) {
        this.listenTo(Adapt, 'questionView:recordInteraction', this.onQuestionInteraction);
      }

      // When an assessment is completed.
      if (this.coreEvents['Adapt']['assessments:complete']) {
        this.listenTo(Adapt, 'assessments:complete', this.onAssessmentComplete);
      }

      // Standard completion events for the various collection types, i.e.
      // course, contentobjects, articles, blocks and components.
      _.each(_.keys(this.coreEvents), function(key) {
        if (key !== 'Adapt') {
          var val = this.coreEvents[key];

          if (typeof val === 'object' && val['change:_isComplete'] === true) {
            this.listenTo(Adapt[key], 'change:_isComplete', this.onItemComplete);
          }
        }
      }, this);
    },

    /**
     * Gets an xAPI Activity (with an 'id of the activityId) representing the course.
     * @returns {ADL.XAPIStatement.Activity} Activity representing the course.
     */
    getCourseActivity: function() {
      var object = new ADL.XAPIStatement.Activity(this.get('activityId'));
      var name = {};
      var description = {};

      name[this.get('displayLang')] = this.courseName;
      description[this.get('displayLang')] = this.courseDescription;

      object.definition = {
        type: ADL.activityTypes.course,
        name: name,
        description: description
      };

      return object;
    },

    /**
     * Creates an xAPI statement related to the Adapt.course object.
     * @param {object | string} verb - A valid ADL.verbs object or key.
     * @param {object} [result] - An optional result object.
     * @return A valid ADL statement object.
     */
    getCourseStatement: function(verb, result) {
      if (typeof result === 'undefined') {
        result = {};
      }

      var object = this.getCourseActivity()

      // Append the duration.
      switch (verb) {
        case ADL.verbs.launched:
        case ADL.verbs.initialized:
        case ADL.verbs.attempted: {
          result.duration = 'PT0S';
          break;
        }

        case ADL.verbs.failed:
        case ADL.verbs.passed:
        case ADL.verbs.suspended: {
          result.duration = this.convertMillisecondsToISO8601Duration(this.getAttemptDuration());
          break;
        }

        case ADL.verbs.terminated: {
          result.duration = this.convertMillisecondsToISO8601Duration(this.getSessionDuration());
          break;
        }
      }

      return this.getStatement(this.getVerb(verb), object, result);
    },

    /**
     * Gets a name object from a given model.
     * @param {Backbone.Model} model - An instance of Adapt.Model (or Backbone.Model).
     * @return {object} An object containing a key-value pair with the language code and name.
     */
    getNameObject: function(model) {
      var name = {};

      name[this.get('displayLang')] = model.get('displayTitle') || model.get('title');

      return name;
    },

    /**
     * Gets the activity type for a given model.
     * @param {Backbone.Model} model - An instance of Adapt.Model (or Backbone.Model).
     * @return {string} A URL to the current activity type.
     */
    getActivityType: function(model) {
      var type = '';

      switch (model.get('_type')) {
        case 'component': {
          type = model.get('_isQuestionType') ? ADL.activityTypes.interaction : ADL.activityTypes.media;
          break;
        }
        case 'block':
        case 'article': {
          type = ADL.activityTypes.interaction; //??
          break;
        }
        case 'course': {
          type = ADL.activityTypes.course;
          break;
        }
        case 'menu': {
          type = ADL.activityTypes.module;
          break;
        }
        case 'page': {
          type = ADL.activityTypes.lesson;
          break;
        }
      }

      return type;
    },

    /**
     * Sends an 'answered' statement to the LRS.
     * @param {ComponentView} view - An instance of Adapt.ComponentView.
     */
    onQuestionInteraction: function(view) {
      if (!view.model || view.model.get('_type') !== 'component' && !view.model.get('_isQuestionType')) {
        return;
      }

      if (this.isComponentOnBlacklist(view.model.get('_component'))) {
        // This component is on the blacklist, so do not send a statement.
        return;
      }

      var object = new ADL.XAPIStatement.Activity(this.getUniqueIri(view.model));
      var isComplete = view.model.get('_isComplete');
      var lang = this.get('displayLang');
      var statement;
      var description = {};

      description[this.get('displayLang')] = this.stripHtml(view.model.get('body'));

      object.definition = {
        name: this.getNameObject(view.model),
        description: description,
        type: ADL.activityTypes.question,
        interactionType: view.getResponseType()
      };

      if (typeof view.getInteractionObject === 'function') {
        // Get any extra interactions.
        _.extend(object.definition, view.getInteractionObject());

        // Ensure any 'description' properties are objects with the language map.
        _.each(_.keys(object.definition), function(key) {
          if (_.isArray(object.definition[key]) && object.definition[key].length !== 0) {
            for (var i = 0; i < object.definition[key].length; i++) {
              if (!object.definition[key][i].hasOwnProperty('description')) {
                break;
              }

              if (typeof object.definition[key][i].description === 'string') {
                var description = {};
                description[lang] = object.definition[key][i].description;

                object.definition[key][i].description = description;
              }
            }
          }
        });
      }

      var result = {
        score: {
          raw: view.model.get('_score') || 0
        },
        success: view.model.get('_isCorrect'),
        completion: isComplete,
        response: this.processInteractionResponse(object.definition.interactionType, view.getResponse())
      };

      // Answered
      statement = this.getStatement(this.getVerb(ADL.verbs.answered), object, result);

      this.addGroupingActivity(view.model, statement)
      this.sendStatement(statement);
    },

    /**
     * Removes the HTML tags/attributes and returns a string.
     * @param {string} html - A string containing HTML
     * @returns {string} The same string minus HTML
     */
    stripHtml: function(html) {
      var tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;

      return tempDiv.textContent || tempDiv.innerText || '';
    },

    /**
     * In order to support SCORM 1.2 and SCORM 2004, some of the components return a non-standard
     * response.
     * @param {string} responseType - The type of the response.
     * @param {string} response - The unprocessed response string.
     * @returns {string} A response formatted for xAPI compatibility.
     */
    processInteractionResponse: function(responseType, response) {
      switch (responseType) {
        case 'choice': {
          response = response.replace(/,|#/g, '[,]');

          break;
        }
        case 'matching': {
          // Example: 1[.]1_1[,]2[.]2_5
          response = response
            .split('#')
            .map(function(val, i) {
              return (i + 1) + '[.]' + val.replace('.', '_')
            })
            .join('[,]');
          break;
        }
      }

      return response;
    },

    /**
     * Sends an xAPI statement when an item has been experienced.
     * @param {AdaptModel} model - An instance of AdaptModel, i.e. ContentObjectModel, etc.
     */
    onItemExperience: function(model) {
      if (model.get('_id') === 'course') {
        // We don't really want to track actions on the home menu.
        return;
      }

      var object = new ADL.XAPIStatement.Activity(this.getUniqueIri(model));
      var statement;

      object.definition = {
        name: this.getNameObject(model),
        type: this.getActivityType(model)
      };

      // Experienced.
      statement = this.getStatement(this.getVerb(ADL.verbs.experienced), object);

      this.addGroupingActivity(model, statement)
      this.sendStatement(statement);
    },

    /**
     * Checks if a given component is blacklisted from sending statements.
     * @param {string} component - The name of the component.
     * @returns {boolean} true if the component exists on the blacklist.
     */
    isComponentOnBlacklist: function(component) {
      return this.get('componentBlacklist').indexOf(component) !== -1;
    },

    /**
     * Sends an xAPI statement when an item has been completed.
     * @param {AdaptModel} model - An instance of AdaptModel, i.e. ComponentModel, BlockModel, etc.
     * @param {boolean} isComplete - Flag to indicate if the model has been completed
     */
    onItemComplete: function(model, isComplete) {
      if (isComplete === false) {
        // The item is not actually completed, e.g. it may have been reset.
        return;
      }

      // If this is a question component (interaction), do not record multiple statements.
      if (model.get('_type') === 'component' && model.get('_isQuestionType') === true
        && this.coreEvents['Adapt']['questionView:recordInteraction'] === true
        && this.coreEvents['components']['change:_isComplete'] === true) {
        // Return because 'Answered' will already have been passed.
        return;
      }

      if (model.get('_type') === 'component' && this.isComponentOnBlacklist(model.get('_component'))) {
        // This component is on the blacklist, so do not send a statement.
        return;
      }

      var result = { completion: true };
      var object = new ADL.XAPIStatement.Activity(this.getUniqueIri(model));
      var statement;

      object.definition = {
        name: this.getNameObject(model),
        type: this.getActivityType(model)
      };

      // Completed.
      statement = this.getStatement(this.getVerb(ADL.verbs.completed), object, result);

      this.addGroupingActivity(model, statement)
      this.sendStatement(statement);
    },

    /**
     * Gets a lesson activity for a given page.
     * @param {string|Adapt.Model} page - Either an Adapt contentObject model of type 'page', or the _id of one.
     * @returns {XAPIStatement.Activity} Activity corresponding to the lesson.
     */
    getLessonActivity: function(page) {
      var pageModel = (typeof page === 'string')
        ? Adapt.findById(page)
        : page
      var activity = new ADL.XAPIStatement.Activity(this.getUniqueIri(pageModel))
      var name = this.getNameObject(pageModel)

      activity.definition = {
        name: name,
        type: ADL.activityTypes.lesson
      }

      return activity;
    },

    /**
     * Adds a 'grouping' and/or 'parent' value to a statement's contextActivities.
     * Note: the 'parent' is only added in the case of a question component which is part of
     * an assessment. All articles, blocks and components are grouped by page.
     * @param {Adapt.Model} model - Any Adapt model.
     * @param {ADL.XAPIStatement} statement - A valid xAPI statement object.
     */
    addGroupingActivity: function(model, statement) {
      var type = model.get('_type');

      if (type !== 'course') {
        // Add a grouping for the course.
        statement.addGroupingActivity(this.getCourseActivity())
      }

      if (['article', 'block', 'component'].indexOf(type) !== -1) {
        // Group these items by page/lesson.
        var pageModel = model.findAncestor('pages')

        statement.addGroupingActivity(this.getLessonActivity(pageModel));
      }

      if (type === 'component' && model.get('_isPartOfAssessment')) {
        // Get the article containing this question component.
        let articleModel = model.findAncestor('articles')

        if (articleModel && articleModel.has('_assessment') && articleModel.get('_assessment')._isEnabled) {
          // Set the assessment as the parent.
          var assessment = {
            id: articleModel.get('_assessment')._id,
            articleId: articleModel.get('_id'),
            type: 'article-assessment',
            pageId: articleModel.get('_parentId')
          }

          statement.addParentActivity(this.getAssessmentObject(assessment))
        }
      }
    },

    /**
     * Takes an assessment state and returns a results object based on it.
     * @param {object} assessment - An instance of the assessment state.
     * @return {object} - A result object containing score, success and completion properties.
     */
    getAssessmentResultObject: function(assessment) {
      var result = {
        score: {
          scaled: (assessment.scoreAsPercent / 100),
          raw: assessment.score,
          min: 0,
          max: assessment.maxScore
        },
        success: assessment.isPass,
        completion: assessment.isComplete
      };

      return result;
    },

    /**
     * Gets an Activity for use in an xAPI statement.
     * @param {object} assessment - Object representing the assessment.
     * @returns {ADL.XAPIStatement.Activity} - Activity representing the assessment.
     */
    getAssessmentObject: function(assessment) {
      // Instantiate a Model so it can be used to obtain an IRI.
      var fakeModel = new Backbone.Model({
        _id: assessment.id || assessment.articleId,
        _type: assessment.type,
        pageId: assessment.pageId
      });

      var object = new ADL.XAPIStatement.Activity(this.getUniqueIri(fakeModel));
      var name = {};

      name[this.get('displayLang')] = assessment.id || 'Assessment';

      object.definition = {
        name: name,
        type: ADL.activityTypes.assessment
      };

      return object
    },

    /**
     * Sends an xAPI statement when an assessment has been completed.
     * @param {object} assessment - Object representing the state of the assessment.
     */
    onAssessmentComplete: function(assessment) {
      var self = this;

      var object = this.getAssessmentObject(assessment)
      var result = this.getAssessmentResultObject(assessment);
      var statement;

      if (assessment.isPass) {
        // Passed.
        statement = this.getStatement(this.getVerb(ADL.verbs.passed), object, result);
      } else {
        // Failed.
        statement = this.getStatement(this.getVerb(ADL.verbs.failed), object, result);
      }

      statement.addGroupingActivity(this.getCourseActivity())
      statement.addGroupingActivity(this.getLessonActivity(assessment.pageId))

      // Delay so that component completion can be recorded before assessment completion.
      _.delay(function() {
        self.sendStatement(statement);
      }, 500);
    },

    /**
     * Gets a valid 'verb' object in the ADL.verbs and returns the correct language version.
     * @param {object|stirng} verb - A valid ADL verb object or key, e.g. 'completed'.
     * @return {object} An ADL verb object with 'id' and language specific 'display' properties.
     */
    getVerb: function(verb) {
      if (typeof verb === 'string') {
        var key = verb.toLowerCase();
        verb = ADL.verbs[key];

        if (!verb) {
          Adapt.log.error('adapt-contrib-xapi: Verb "' + key + '" does not exist in ADL.verbs object');
        }
      }

      if (typeof verb !== 'object') {
        throw new Error('Unrecognised verb: ' + verb);
      }

      var lang = this.get('lang') || this.defaultLang;

      var singleLanguageVerb = {
        id: verb.id,
        display: {}
      };

      var description = verb.display[lang];

      if (description) {
        singleLanguageVerb.display[lang] = description;
      } else {
        // Fallback in case the verb translation doesn't exist.
        singleLanguageVerb.display[this.defaultLang] = verb.display[this.defaultLang];
      }

      return singleLanguageVerb;
    },

    /**
     * Gets a unique IRI for a given model.
     * @param {AdaptModel} model - An instance of an AdaptModel object.
     * @return {string} An IRI formulated specific to the passed model.
     */
    getUniqueIri: function(model) {
      var iri = this.get('activityId');
      var type = model.get('_type');

      if (type !== 'course') {
        if (type === 'article-assessment') {
          iri = iri + ['#', 'assessment', model.get('_id')].join('/');
        } else {
          iri = iri + ['#/id', model.get('_id')].join('/');
        }
      }

      return iri;
    },

    /**
     * Handler for the Adapt Framework's 'tracking:complete' event.
     * @param {object} completionData
     */
    onTrackingComplete: function(completionData) {
      var self = this;
      var result = {};
      var completionVerb;

      // Check the completion status.
      switch (completionData.status) {
        case COMPLETION_STATE.PASSED: {
          completionVerb = ADL.verbs.passed;
          break;
        }

        case COMPLETION_STATE.FAILED: {
          completionVerb = ADL.verbs.failed;
          break;
        }

        default: {
          completionVerb = ADL.verbs.completed;
        }
      }

      if (completionVerb === ADL.verbs.completed) {
        result = { completion: true };
      } else {
        // The assessment(s) play a part in completion, so use their result.
        result = this.getAssessmentResultObject(completionData.assessment);
      }

      // Store a reference that the course has actually been completed.
      this.isComplete = true;

      _.defer(function() {
        // Send the completion status.
        self.sendStatement(self.getCourseStatement(completionVerb, result));
      });
    },

    /**
     * Refresh course progress from loaded state.
     */
    restoreState: function() {
      var state = this.get('state');

      if (_.isEmpty(state)) {
        return;
      }

      var Adapt = require('core/js/adapt');

      if (state.components) {
        _.each(state.components, function(stateObject) {
          var restoreModel = Adapt.findById(stateObject._id);

          if (restoreModel) {
            restoreModel.setTrackableState(stateObject);
          } else {
            Adapt.log.warn('adapt-contrib-xapi: Unable to restore state for component: ' + stateObject._id);
          }
        });
      }

      if (state.blocks) {
        _.each(state.blocks, function(stateObject) {
          var restoreModel = Adapt.findById(stateObject._id);

          if (restoreModel) {
            restoreModel.setTrackableState(stateObject);
          } else {
            Adapt.log.warn('adapt-contrib-xapi: Unable to restore state for block: ' + stateObject._id);
          }
        });
      }
    },

    /**
     * Generate an XAPIstatement object for the xAPI wrapper sendStatement methods.
     * @param {object} verb - A valid ADL.verbs object.
     * @param {object} object -
     * @param {object} [result] - optional
     * @param {object} [context] - optional
     * @return {ADL.XAPIStatement} A formatted xAPI statement object.
     */
    getStatement: function(verb, object, result, context) {
      var statement = new ADL.XAPIStatement(
        new ADL.XAPIStatement.Agent(this.get('actor')),
        verb,
        object
      );

      if (result && !_.isEmpty(result)) {
        statement.result = result;
      }

      if (context) {
        statement.context = context;
      }

      if (this.get('_generateIds')) {
        statement.generateId();
      }

      return statement;
    },

    /**
     * Sends the state to the or the given model to the configured LRS.
     * @param {AdaptModel} model - The AdaptModel whose state has changed.
     */
    sendState: function(model, modelState) {
      if (this.get('shouldTrackState') !== true) {
        return;
      }

      var activityId = this.get('activityId');
      var actor = this.get('actor');
      var type = model.get('_type');
      var state = this.get('state');
      var registration = this.get('shouldUseRegistration') === true 
        ? this.get('registration')
        : null;
      var collectionName = _.findKey(this.coreObjects, function(o) {
        return o === type || o.indexOf(type) > -1
      });
      var stateCollection = _.isArray(state[collectionName]) ? state[collectionName] : [];
      var newState;

      if (collectionName !== 'course' && collectionName !== 'offlineStorage') {
        var index = _.findIndex(stateCollection, { _id: model.get('_id') });

        if (index !== -1) {
          stateCollection.splice(index, 1, modelState);
        } else {
          stateCollection.push(modelState);
        }

        newState = stateCollection;
      } else {
        newState = modelState;
      }

      // Update the locally held state.
      state[collectionName] = newState;
      this.set({
        state: state
      });

      // Pass the new state to the LRS.
      this.xapiWrapper.sendState(activityId, actor, collectionName, registration, newState, null, null, function(error, xhr) {
        if (error) {
          Adapt.trigger('xapi:lrs:sendState:error', error);
        }

        Adapt.trigger('xapi:lrs:sendState:success', newState);
      });
    },

    /**
     * Retrieves the state information for the current course.
     * @param {ErrorOnlyCallback} [callback]
     */
    getState: function(callback) {
      callback = _.isFunction(callback) ? callback : function() { };

      var self = this;
      var activityId = this.get('activityId');
      var actor = this.get('actor');
      var registration = this.get('shouldUseRegistration') === true 
        ? this.get('registration')
        : null;
      var state = {};

      Async.each(_.keys(this.coreObjects), function(type, nextType) {
        self.xapiWrapper.getState(activityId, actor, type, registration, null, function(error, xhr) {
          _.defer(function() {
            if (error) {
              Adapt.log.warn('adapt-contrib-xapi: getState() failed for ' + activityId + ' (' + type + ')');
              return nextType(error);
            }

            if (!xhr) {
              Adapt.log.warn('adapt-contrib-xapi: getState() failed for ' + activityId + ' (' + type + ')');
              return nextType(new Error('\'xhr\' parameter is missing from callback'));
            }

            if (xhr.status === 404) {
              return nextType();
            }

            if (xhr.status !== 200) {
              Adapt.log.warn('adapt-contrib-xapi: getState() failed for ' + activityId + ' (' + type + ')');
              return nextType(new Error('Invalid status code ' + xhr.status + ' returned from getState() call'));
            }

            var response;
            var parseError;

            // Check for empty response, otherwise the subsequent JSON.parse() will fail.
            if (xhr.response === '') {
              return nextType();
            }

            try {
              response = JSON.parse(xhr.response);
            } catch (e) {
              parseError = e;
            }

            if (parseError) {
              return nextType(parseError);
            }

            if (!_.isEmpty(response)) {
              state[type] = response;
            }

            return nextType();
          });
        });
      }, function(error) {
        if (error) {
          Adapt.log.error('adapt-contrib-xapi:', error);
          return callback(error);
        }

        if (!_.isEmpty(state)) {
          self.set({ state: state });
        }

        Adapt.trigger('xapi:stateLoaded');

        callback();
      });
    },

    /**
     * Deletes all state information for the current course.
     * @param {ErrorOnlyCallback} [callback]
     */
    deleteState: function(callback) {
      callback = _.isFunction(callback) ? callback : function() { };

      var self = this;
      var activityId = this.get('activityId');
      var actor = this.get('actor');
      var registration = this.get('shouldUseRegistration') === true 
        ? this.get('registration')
        : null;
 
      Async.each(_.keys(this.coreObjects), function(type, nextType) {
        self.xapiWrapper.deleteState(activityId, actor, type, registration, null, null, function(error, xhr) {
          if (error) {
            Adapt.log.warn('adapt-contrib-xapi: deleteState() failed for ' + activityId + ' (' + type + ')');
            return nextType(error);
          }

          if (!xhr) {
            Adapt.log.warn('adapt-contrib-xapi: deleteState() failed for ' + activityId + ' (' + type + ')');
            return nextType(new Error('\'xhr\' parameter is missing from callback'));
          }

          if (xhr.status !== 204) {
            Adapt.log.warn('adapt-contrib-xapi: deleteState() failed for ' + activityId + ' (' + type + ')');
            return nextType(new Error('Invalid status code ' + xhr.status + ' returned from getState() call'));
          }

          return nextType();
        });
      }, function(error) {
        if (error) {
          Adapt.log.error('adapt-contrib-xapi:', error);
          return callback(error);
        }

        callback();
      });
    },

    /**
     * Retrieve a config item for the current course, e.g. '_activityID'.
     * @param {string} key - The data attribute to fetch.
     * @return {object|boolean} The attribute value, or false if not found.
     */
    getConfig: function(key) {
      if (!this.config || key === '' || typeof this.config[key] === 'undefined') {
        return false;
      }

      return this.config[key];
    },

    /**
     * Retrieve an LRS attribute for the current session, e.g. 'actor'.
     * @param {string} key - The attribute to fetch.
     * @return {object|null} the attribute value, or null if not found.
     */
    getLRSAttribute: function(key) {
      if (!this.xapiWrapper || !this.xapiWrapper.lrs || undefined === this.xapiWrapper.lrs[key]) {
        return null;
      }

      try {
        switch(key) {
          case 'actor': {
            var actor = JSON.parse(this.xapiWrapper.lrs[key]);

            if (_.isArray(actor.name)) {
              // Convert the name from an array to a string.
              actor.name = actor.name[0];
            }

            if (_.isArray(actor.mbox)) {
              // Convert mbox from an array to a string.
              actor.mbox = actor.mbox[0];
            }

            // If the account is an array, some work will be required.
            if (_.isArray(actor.account)) {
              var account = {};

              // Convert 'accountServiceHomePage' to 'homePage'.
              if (typeof actor.account[0].accountServiceHomePage !== 'undefined') {
                account.homePage = actor.account[0].accountServiceHomePage;
              } else if (actor.account[0].homePage !== 'undefined') {
                account.homePage = actor.account[0].homePage;
              }

              // Convert 'accountName' to 'name'.
              if (typeof actor.account[0].accountName !== 'undefined') {
                account.name = actor.account[0].accountName;
              } else if (typeof actor.account[0].name !== 'undefined') {
                account.name = actor.account[0].name;
              }

              // Out with the old array.
              delete actor.account;

              // In with the new object.
              actor.account = account;
            }

            return actor;
          }
          // case 'registration': {
          //   var registration = this.xapiWrapper.lrs[key];
          //   if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(registration)) {
          //     // The 'registration' isn't a valid UUID, generate one.
          //     return ADL.ruuid();
          //   } else {
          //     return registration;
          //   }
          // }
          default:
            return this.xapiWrapper.lrs[key];
        }
      } catch (e) {
        return null;
      }
    },

    getLRSExtendedAttribute: function(key) {
      var extended = this.getLRSAttribute('extended');
      if (extended == null) {
        return null;
      }

      try {
        if (key === 'definition') {
          return JSON.parse(extended.definition);
        }

        return extended[key];
      } catch (e) {
        return null;
      }
    },

    /**
     * Checks that the required properties -- actor and activityId -- are defined, and
     * logs a warning if any of them are not.
     * @return {boolean} true if the properties are valid, false otherwise.
     */
    validateProps: function() {
      var errorCount = 0;

      if (!this.get('actor') || typeof this.get('actor') !== 'object') {
        Adapt.log.warn('adapt-contrib-xapi: "actor" attribute not found!');
        errorCount++;
      }

      if (!this.get('activityId')) {
        Adapt.log.warn('adapt-contrib-xapi: "activityId" attribute not found!');
        errorCount++;
      }

      // if (!this.get('registration')) {
      //   Adapt.log.warn('adapt-contrib-xapi: "registration" attribute not found!');
      // }

      if (errorCount > 0) {
        return false;
      }

      return true;
    },

    /**
     * Prepares to send a single xAPI statement to the LRS.
     * @param {ADL.XAPIStatement} statement - A valid ADL.XAPIStatement object.
     * @param {ADLCallback} [callback]
     * @param {array} [attachments] - An array of attachments to pass to the LRS.
     */
    sendStatement: function(statement, callback, attachments) {
      callback = _.isFunction(callback) ? callback : function() { };

      if (!statement) {
        return;
      }

      Adapt.trigger('xapi:preSendStatement', statement);

      // Allow the trigger above to augment attachments if the attachments
      // parameter is not set.
      if (_.isUndefined(attachments) && statement.attachments) {
        return this.processAttachments(statement, callback);
      } else {
        this.onStatementReady(statement, callback, attachments);
      }
    },

    /**
     * Sends statements using the Fetch API in order to make use of the keepalive
     * feature not available in AJAX requests. This makes the sending of suspended
     * and terminated statements more reliable.
     */
    sendStatementsSync: function(statements) {
      var lrs = ADL.XAPIWrapper.lrs;

      // Fetch not supported in IE and keepalive/custom headers
      // not supported for CORS preflight requests so attempt
      // to send the statement in the usual way
      if (!window.fetch || this.isCORS(lrs.endpoint)) {
        return this.sendStatements(statements);
      }

      var url = lrs.endpoint + 'statements';
      var credentials = ADL.XAPIWrapper.withCredentials ? 'include' : 'omit';
      var headers = {
        'Content-Type': 'application/json',
        'Authorization': lrs.auth,
        'X-Experience-API-Version': ADL.XAPIWrapper.xapiVersion
      };

      // Add extended LMS-specified values to the URL
      var extended = _.map(lrs.extended, function(value, key) {
        return key + '=' + encodeURIComponent(value);
      });

      if (extended.length > 0) {
        url += (url.indexOf('?') > -1 ? '&' : '?') + extended.join('&');
      }

      fetch(url, {
        body: JSON.stringify(statements),
        cache: 'no-cache',
        credentials: credentials,
        headers: headers,
        mode: 'same-origin',
        keepalive: true,
        method: 'POST'
      }).then(function() {
        Adapt.trigger('xapi:lrs:sendStatement:success', statements);
      }).catch(function(error) {
        Adapt.trigger('xapi:lrs:sendStatement:error', error);
      })
    },

    /**
     * Determine if sending the statement involves a Cross Origin Request
     * @param {string} url - the lrs endpoint
     * @returns {boolean}
     */
    isCORS: function(url) {
      var urlparts = url.toLowerCase().match(/^(.+):\/\/([^:\/]*):?(\d+)?(\/.*)?$/);
      var isCORS = (location.protocol.toLowerCase().replace(':', '') !== urlparts[1] || location.hostname.toLowerCase() !== urlparts[2]);
      if (!isCORS) {
        var urlPort = (urlparts[3] === null ? (urlparts[1] === 'http' ? '80' : '443') : urlparts[3]);
        isCORS = (urlPort === location.port);
      }

      return isCORS;
    },

    /**
     * Send an xAPI statement to the LRS once all async operations are complete
     * @param {ADL.XAPIStatement} statement - A valid ADL.XAPIStatement object.
     * @param {ADLCallback} [callback]
     * @param {array} [attachments] - An array of attachments to pass to the LRS.
     */
    onStatementReady: function(statement, callback, attachments) {
      this.xapiWrapper.sendStatement(statement, function(error) {
        if (error) {
          Adapt.trigger('xapi:lrs:sendStatement:error', error);
          return callback(error);
        }

        Adapt.trigger('xapi:lrs:sendStatement:success', statement);
        return callback();
      }, attachments);
    },

    /**
     * Process any attachments that have been added to the statement object by
     * intercepting the send operation at the xapi:preSendStatement trigger
     * If a url is specified for an attachment then retrieve the text content
     * and store this instead
     * @param {ADL.XAPIStatement} statement - A valid ADL.XAPIStatement object.
     * @param {ADLCallback} [callback]
     */
    processAttachments: function(statement, callback) {
      var attachments = statement.attachments;

      Async.each(attachments, function(attachment, nextAttachment) {

        // First check the attachment for a value
        if (attachment.value) {
          nextAttachment();
        } else if (attachment.url) {
          // If a url is specified then we need to obtain the string value
          // Use native xhr so we can set the responseType to 'blob'
          var xhr = new XMLHttpRequest();
          xhr.onreadystatechange = function() {
            if (this.readyState === 4 && this.status === 200) {

              // Use FileReader to retrieve the blob contents as a string
              var reader = new FileReader();
              reader.onload = function() {

                // Store the string value in the attachment object and
                // delete the url property which is no longer needed
                attachment.value = reader.result;
                delete attachment.url;
                nextAttachment()
              };
              reader.readAsBinaryString(this.response);
            }
          };
          xhr.open('GET', attachment.url);
          xhr.responseType = 'blob';
          xhr.send();
        } else {
          Adapt.log.warn('Attachment object contained neither a value or url property.');
        }
      }, function() {
        delete statement.attachments;
        this.onStatementReady(statement, callback, attachments);
      }.bind(this));
    },

    /**
     * Sends multiple xAPI statements to the LRS.
     * @param {ADL.XAPIStatement[]} statements - An array of valid ADL.XAPIStatement objects.
     * @param {ErrorOnlyCallback} [callback]
     */
    sendStatements: function(statements, callback) {
      callback = _.isFunction(callback) ? callback : function() { };

      if (!statements || statements.length === 0) {
        return;
      }

      Adapt.trigger('xapi:preSendStatements', statements);

      // Rather than calling the wrapper's sendStatements() function, iterate
      // over each statement and call sendStatement().
      Async.each(statements, function(statement, nextStatement) {
        this.sendStatement(statement, nextStatement);
      }.bind(this), function(error) {
        if (error) {
          Adapt.log.error('adapt-contrib-xapi:', error);
          return callback(error);
        }

        callback();
      });
    },

    getGlobals: function() {
      return _.defaults(
        (
          Adapt &&
          Adapt.course &&
          Adapt.course.get('_globals') &&
          Adapt.course.get('_globals')._extensions &&
          Adapt.course.get('_globals')._extensions._xapi
        ) || {},
        {
          'confirm': 'OK',
          'lrsConnectionErrorTitle': 'LRS not available',
          'lrsConnectionErrorMessage': 'We were unable to connect to your Learning Record Store (LRS). This means that your progress cannot be recorded.'
        }
      );
    },

    showError: function() {
      if (this.getConfig('_lrsFailureBehaviour') === 'ignore') {
        return;
      }

      var notifyObject = {
        title: this.getGlobals().lrsConnectionErrorTitle,
        body: this.getGlobals().lrsConnectionErrorMessage,
        confirmText: this.getGlobals().confirm
      };

      // Setup wait so that notify does not get dismissed when the page loads
      Adapt.wait.begin();
      Adapt.trigger('notify:alert', notifyObject);
      // Ensure notify appears on top of the loading screen
      $('.notify').css({ position: 'relative', zIndex: 5001 });
      Adapt.once('notify:closed', Adapt.wait.end);
    }
  });

  xAPI.getInstance = function() {
    if (!xAPI.instance) {
      xAPI.instance = new xAPI();
    }

    return xAPI.instance;
  };

  /** Adapt event listeners begin here */
  Adapt.once('app:dataLoaded', function() {
    var xapi = xAPI.getInstance();

    xapi.initialize();

    Adapt.on('adapt:initialize', function() {
      xapi.setupListeners();
    });

    Adapt.on('xapi:lrs:initialize:error', function(error) {
      Adapt.log.error('adapt-contrib-xapi: xAPI Wrapper initialisation failed', error);
      xapi.showError();
    });

    Adapt.on('xapi:lrs:sendStatement:error', function(error) {
      xapi.showError();
    });

    Adapt.on('xapi:lrs:sendState:error', function(error) {
      xapi.showError();
    });
  });

  return xAPI.getInstance();
});

define('extensions/adapt-contrib-xapi/js/adapt-offlineStorage-xapi',[
  'core/js/adapt',
  './adapt-contrib-xapi'
], function(Adapt, xapi) {

  //xAPI handler for Adapt.offlineStorage interface.
  var offlineStorage = {

    load: function() {
      // Use a lightweight fake model to pass into xAPI.sendState
      var fakeModel = {
        get: function() {
          return 'offlineStorage';
        }
      };

      var store = new Backbone.Model();
      var isDataRestored = false;

      Adapt.offlineStorage.initialize({

        get: function(name) {
          if (!name) {
            return this.getAll();
          }

          if (!this.useTemporaryStore() && name.toLowerCase() === 'learnerinfo') {
            return this.getLearnerInfo();
          }

          return store.get(name);
        },

        getAll: function() {
          if (!isDataRestored) {
            var state = xapi.get('state') || {};
            store.set(state.offlineStorage);
            isDataRestored = true;
          }

          //If not connected return just the store.
          if (this.useTemporaryStore()) {
            return store.toJSON();
          }

          return _.extend(store.toJSON(), {
            learnerInfo: this.getLearnerInfo()
          });
        },

        set: function(name, value) {
          store.set(name, value);

          // xAPI may not yet be initialised so use a soft trigger rather than hard calling xAPI.sendState
          Adapt.trigger('state:change', fakeModel, store.toJSON());
        },

        useTemporaryStore: function() {
          return !xapi.get('isInitialised');
        },

        /**
         * @returns {{id: string, name: string, firstname: string, lastname: string}} The learner's id, full name (in the format Firstname Lastname), first and last names
         */
        getLearnerInfo: function() {
          var actor = xapi.get('actor') || {};
          var name = actor.name || '';
          var lastname;
          var firstname;
          var matches = name.match(/(\S+)\s(.+)/);

          if (matches && matches.length > 2) {
            lastname = matches[2];
            firstname = matches[1];
          } else {
            console.log('xAPI: actor name not in "firstname lastname" format');
          }

          return {
            id: this.getLearnerId(actor),
            name: name,
            lastname: lastname,
            firstname: firstname
          };
        },

        /**
         * Get the learner's id by checking the actor properties in the order 'name', 'openid', 'mbox'
         * @param {object} actor
         * @return {string} the learner's unique id
         */
        getLearnerId: function(actor) {
          var name = actor.account && actor.account.name;

          if (name) {
            return name;
          }

          if (actor.openid) {
            return actor.openid;
          }

          if (typeof actor.mbox === 'string' && actor.mbox.length > 0) {
            return actor.mbox.replace('mailto:', '')
          }

          console.log('xAPI: could not determine the learner\'s ID');

          return null;
        }

      });
    }

  };

  return offlineStorage;

});

define('extensions/adapt-contrib-xapi/js/index',[
  'core/js/adapt',
  './adapt-offlineStorage-xapi',
  './adapt-contrib-xapi',
], function(Adapt, offlineStorage) {

  Adapt.on('app:dataLoaded', initialise);

  function initialise() {
    var config = Adapt.config.get('_xapi') || {};

    if (!config._isEnabled) {
      return;
    }

    offlineStorage.load();

    // Wait for offline storage to be restored if _shouldTrackState is enabled
    var successEvent = config._shouldTrackState ? 'xapi:stateLoaded' : 'xapi:lrs:initialize:success';

    // Ensure that the course still loads if there is a connection error
    Adapt.once('xapi:lrs:initialize:error ' + successEvent, function() {
      Adapt.offlineStorage.get();
      Adapt.offlineStorage.setReadyStatus();
    });
  }

});
define('core/js/views/menuView',[
    'core/js/adapt',
    'core/js/views/adaptView'
], function(Adapt, AdaptView) {

    var MenuView = AdaptView.extend({

    	className: function() {
            var visible = "visibility-hidden";
            if (this.model.get('_isVisible')) {
                visible = "";
            }
    		return 'menu ' +
            'menu-' +
            this.model.get('_id') +
            " " + this.model.get('_classes') +
            " " + this.setVisibility() +
            " " + (this.model.get('_isComplete') ? 'completed' : '');
    	},

        preRender: function() {
            this.disableAnimation = Adapt.config.has('_disableAnimation') ? Adapt.config.get('_disableAnimation') : false;
            this.$el.css('opacity', 0);
            this.listenTo(this.model, 'change:_isReady', this.isReady);
        },

        postRender: function() {
        },

        isReady: function() {
            if (this.model.get('_isReady')) {
                _.defer(function() {
                    $('.loading').hide();
                    $(window).scrollTop(0);
                    Adapt.trigger('menuView:ready', this);
                    var styleOptions = { opacity: 1 };
                    if (this.disableAnimation) {
                        this.$el.css(styleOptions);
                        $.inview();
                    } else {
                        this.$el.velocity(styleOptions, {
                            duration: 'fast',
                            complete: function() {
                                $.inview();
                            }
                        });
                    }
                    $(window).scroll();
                }.bind(this));
            }
        }

    }, {
        type:'menu'
    });

    return MenuView;

});

define('menu/5efb30230d955f585ae93641-5f05eb71a346885f34d09a92/js/adapt-menu-boxmenu',[
  'coreJS/adapt',
  'coreViews/menuView'
], function (Adapt, MenuView) {

  var BoxMenuView = MenuView.extend({

    postRender: function () {
      var nthChild = 0;
      this.model.getChildren().each(function (item) {
        if (item.get('_isAvailable')) {
          nthChild++;
          item.set("_nthChild", nthChild);
          this.$('.menu-container-inner').append(new BoxMenuItemView({ model: item }).$el);
        }
      });
    }

  }, {
      template: 'boxmenu'
    });

  var BoxMenuItemView = MenuView.extend({

    events: {
      'click button': 'onClickMenuItemButton'
    },

    className: function () {
      var nthChild = this.model.get("_nthChild");
      return [
        'menu-item',
        'menu-item-' + this.model.get('_id'),
        this.model.get('_classes'),
        this.model.get('_isVisited') ? 'visited' : '',
        this.model.get('_isComplete') ? 'completed' : '',
        this.model.get('_isLocked') ? 'locked' : '',
        'nth-child-' + nthChild,
        nthChild % 2 === 0 ? 'nth-child-even' : 'nth-child-odd'
      ].join(' ');
    },

    preRender: function () {
      this.model.checkCompletionStatus();
      this.model.checkInteractionCompletionStatus();
    },

    postRender: function () {
      var graphic = this.model.get('_graphic');
      if (graphic && graphic.src && graphic.src.length > 0) {
        this.$el.imageready(_.bind(function () {
          this.setReadyStatus();
        }, this));
      } else {
        this.setReadyStatus();
      }
    },

    onClickMenuItemButton: function (event) {
      if (event && event.preventDefault) event.preventDefault();
      if (this.model.get('_isLocked')) return;
      Backbone.history.navigate('#/id/' + this.model.get('_id'), { trigger: true });
    }

  }, {
      template: 'boxmenu-item'
    });

  Adapt.on('router:menu', function (model) {

    $('#wrapper').append(new BoxMenuView({ model: model }).$el);

  });

  Adapt.on('menuView:ready', function (page) {
    $('.menu-item-body-inner p').removeClass('prevent-default');
  });
});

define('theme/5efb30230d955f585ae93641-5f05eb71a346885f34d09a92/js/accessibility',['require','coreJS/adapt'],function(require) {
  var Adapt = require('coreJS/adapt');

  return {
    // Checks if Accessibility has been turned on if it hasn't,
    // adjust the tab-index of popup links so they don't steal focus
    popupLinkAccessibility: function() {
      var isAccessible = Adapt.config.has('_accessibility') && Adapt.config.get('_accessibility')._isEnabled === true;

      var popupLinks = $.merge(
        $('.notify-popup button'),
        $('.hotgraphic-popup a')
      );

      // Check that accessibility is NOT enabled OR
      // that it has been enabled but not turned on
      var $html = $('html');
      if (!isAccessible || !$html.hasClass('accessibility')) {
        // ADAPT-5205 - Ignore tab index IE only
        if ($html.hasClass('ie')) {
          popupLinks.each(function() {
            $(this).addClass('a11y-ignore');
          });
        } else {
          popupLinks.each(function() {
            $(this)
              .attr('tabindex', -1)
              .addClass('a11y-ignore');
          });
        }
      } else {
        popupLinks.each(function() {
          $(this).removeClass('a11y-ignore');
        });
      }
    }
  };
});
define('theme/5efb30230d955f585ae93641-5f05eb71a346885f34d09a92/js/classes',[],function() {
  return {

    // Adding class to allow styling of headings
    // Previously included in the Theme templates
    addTemplateClasses: function() {
      $('.article-title-inner').addClass('h2');
      $('.block-title-inner').addClass('h3');
      $('.component-title-inner').addClass('h4');
    },

    addComponentButtonClasses: function(componentView) {
      if (!componentView.model.get('_isQuestionType') || componentView.model.get('_canShowFeedback')) {
        return;
      }
      var $buttons = componentView.$('.buttons-cluster');
      $buttons.find('.buttons-marking-icon, .buttons-feedback').addClass('no-feedback');
      $buttons.find('.buttons-action').addClass('buttons-action-large');
    },

    addClasses: function() {
      // Adding the theme name as a class to the HTML
      $('html').addClass('salsatheme');

      // Selectors
      var elementStatic = [
        '.article-title-inner',
        '.block-title-inner',
        '.block-body-inner',
        '.component-title',
        '.component-body',
        '.component-instruction',
        '.reveal-widget-item-text',
        '.slider-outer-bar',
        '.slider-widget',
        '.textinput-item',
        '.narrative-content',
        '.narrative-strapline',
        '.matching-item-title',
        '.stacker-item-texts',
        '.flipcard-item-back',
        '.media-transcript-container',
        '.mcq-results-feedback',
        '.references-list-widget',
        '.results-widget'
      ].join(',');

      var elementDynamic = [
        '.accordion-item-title',
        '.matching-select-container',
        '.matching-select',
        '.mcq-item label',
        '.gmcq-item label',
        '.select2-container'
      ].join(',');

      var elementIcons = [
        '.accordion-item-title-icon',
        '.narrative-popup-open',
        '.narrative-controls',
        '.narrative-strapline-title .icon',
        '.openTextInput-count-characters',
        '.slider-scale-marker',
        '.rangeslider__fill',
        '.accordion-item-title-icon',
        '.mcq-results-table-container .selected'
      ].join(',');

      var elementTextIcons = [
        '.matching-select-icon',
        '.mcq-item-icon',
        '.gmcq-item-icon',
        '.select2-selection',
        '.select2-selection__placeholder'
      ].join(',');

      var elementControls = [
        '.matching-select-state',
        '.buttons-feedback',
        '.buttons-action',
        '.narrative-popup-open',
        '.narrative-controls',
        '.narrative-strapline-title .icon',
        '.button',
        'button',
        '.stacker-item-navigation',
        '.reveal-widget-control'
      ].join(',');

      var elementColorBorder = [
        'table td',
        'table th'
      ].join(',');

      var elementColorInverted = [
        '.reveal-popup-open',
        '.mcq-results-table-container td',
        '.mcq-results-table-container th'
      ].join(',');

      var elementColorControlIcon = [
        '.buttons-display',
        '.hotgraphic-graphic-pin-icon'
      ].join(',');

      var elementColorControlTable = [
        'table th'
      ].join(',');

      var elementColorBackgroundTextColor = [
        '.slider-scaler',
        '.slider-markers',
        '.rangeslider__handle'
      ].join(',');

      var elementColorDynamicIcon = [
        '.stacker-item-sorter'
      ].join(',');

      // Adding the classes to the Selectors
      $(elementStatic).addClass('element-color-static');
      $(elementDynamic).addClass('element-color-dynamic');
      $(elementIcons).addClass('element-color-icon');
      $(elementTextIcons).addClass('element-color-text-icon');
      $(elementControls).addClass('element-color-control');
      $(elementColorBorder).addClass('element-color-border');
      $(elementColorInverted).addClass('element-color-inverted');
      $(elementColorControlIcon).addClass('element-color-control-icon');
      $(elementColorControlTable).addClass('element-color-table');
      $(elementColorBackgroundTextColor).addClass('element-color-bg-text-color');
      $(elementColorDynamicIcon).addClass('element-color-icon-dynamic');
    }
  };
});
define('theme/5efb30230d955f585ae93641-5f05eb71a346885f34d09a92/js/helpers',['coreJS/adapt'],function() {
  var Adapt = require('coreJS/adapt');

  return {

    /**
     * Append a 'pagelevelprogress' class to the HTML tag when the
     * Page Level Progress extension is enabled
     *
     * @param Backbone.Model courseModel
     */
    checkPageLevelProgress: function(courseModel) {
      var $html = $('html');

      if (courseModel && courseModel.attributes.hasOwnProperty('_pageLevelProgress')) {
        if (courseModel.get('_pageLevelProgress')._isEnabled) {
          // Indicate that Page Level Progress is enabled.
          $html.addClass('pagelevelprogress');

          /*
          4866 position bottom buggy in iframe

          // Check position of Page Level Progress
          var plpPos = getComputedStyle(document.documentElement).getPropertyValue('--progress-bar-LESS-position').trim();

          // early return if Page Level Progress position is not set to bottom
          if (plpPos !== 'Bottom' || plpPos === undefined) {
            return;
          }

          // if set to bottom and an iOS device this DOM rework will stop a scroll judder
          if (Adapt.device.OS === 'ios' && $html.hasClass('location-page')) {
            var progressBar = $('.page-level-progress-navigation');
            progressBar.remove();
            $('#wrapper').append(progressBar);
          }
          */
        }
      }
    },

    // Check if the page has been scrolled and add / remove a class accordingly
    scrollChecker: function() {
      var shouldAddClass = $(window).scrollTop() > 0;

      $('.navigation').toggleClass('collapsed', shouldAddClass);
      $('html').toggleClass('scrolled', shouldAddClass);
    },

    // Turn off the Home button if the start
    // controller and disable menu settings are both true
    hideHomeButton: function() {
      var startController = Adapt.course.get('_start') || null;

      if (startController && startController._isEnabled && startController._isMenuDisabled) {
        $('.navigation-home-button, .navigation-logo-home-button').css('display', 'none');
      }
    },

    setCourseSubtitle: function(displayTitle) {
      var loadingSubTitle = $('#course-title-sub-title');
      loadingSubTitle && loadingSubTitle.html(displayTitle);
    },

    // Check to see if elements are animated and clean up
    // unwanted classes after animation to avoid bugs
    removeAnimationClasses: function() {
      var $animatedElements = $('.animated');
      var itemCount = $animatedElements.length;

      if (itemCount === 0) {
        return;
      }

      var animationEndedCount = 0;

      $animatedElements.on('animationend', function onAnimationEnd(e) {
        var $animatedItem = $(this);

        animationEndedCount++;

        // when its animation ends remove the animation class it
        // listened for, plus any other animated classes
        $animatedItem.removeClass(e.animationName + ' animated animated-hide');

        if (animationEndedCount === itemCount) {
          $animatedElements.off(onAnimationEnd);
        }
      });
    },

    // If media components use vimeo or youtube config switch them out for their respective components
    checkExternalMediaConfig: function() {
      Adapt.components.each(function(component) {
        if (component.get('_component') !== 'media') {
          return;
        }

        var mediaConfig = component.get('_media');

        if (['video/youtube', 'video/vimeo'].indexOf(mediaConfig.type) === -1) {
          return;
        }

        if (mediaConfig.type === 'video/youtube') {
          var rx = /(?:https?:\/\/)?(?:www\.)?(?:youtu\.be\/|youtube\.com(?:\/embed\/|\/v\/|\/watch\?v=|\/watch\?.+&v=))([\w-]{11})(?:.+)?$/;
          var matches = mediaConfig.source.match(rx);

          if (matches) {
            var videoId = matches[1];
            mediaConfig._source = '//www.youtube.com/embed/' + videoId;
            mediaConfig._controls = true;
            mediaConfig._allowFullscreen = component.get("_allowFullScreen");
          }
        } else {
          mediaConfig._source = mediaConfig.source;
        }

        var extMediaType = mediaConfig.type.split('/')[1];

        // Switch the component type and patch the config
        component.set('_component', extMediaType);
        mediaConfig._autoplay = false;
        mediaConfig._loop = false;
      })
    },

    applyEdgeBackgroundFix: function() {
      if (Adapt.device.browser !== 'microsoft edge') {
        return;
      }

      var $page = $('.page');
      var backgroundImage = $page.css('background-image');

      if (backgroundImage === 'none') {
        return;
      }

      var $bgContainer = $('<div style="background: center no-repeat fixed"></div>');
      $bgContainer.appendTo('.page');
      $bgContainer.css({
        position: 'fixed',
        left: 0,
        top: 0,
        zIndex: -1,
        width: '100%',
        height: '100%',
        backgroundImage: backgroundImage,
        backgroundSize: 'cover',
      });

      // Adding this class removes the page's :after element, allowing $bgContainer to become visible
      $page.addClass('edge-background-fix');
    },

    /**
     * Ensure focus remains on inputs when window is resized e.g. when keyboard is displayed on android
     */
    patchNarrative: function() {
      if (!Adapt.componentStore.narrative) {
        return;
      }

      var NarrativeView = Adapt.componentStore.narrative.view.prototype;
      var originalResizeHandler = NarrativeView.resizeControl;

      // Overwrite original resize handler
      NarrativeView.resizeControl = function() {
        var inputElements = ['TEXTAREA', 'INPUT', 'SELECT'];
        var isInputFocused = _.contains(inputElements, document.activeElement.tagName);

        // Only proceed if the active element is not an input
        if (!isInputFocused) {
          originalResizeHandler.call(this);
        }
      };
    }
  }
});

define('theme/5efb30230d955f585ae93641-5f05eb71a346885f34d09a92/js/navigation',['coreJS/adapt'],function() {
  var Adapt = require('coreJS/adapt');

  return {

    // Used alongside resizeLogoHomeLink to check the size of the nav logo
    // and create a button that links back to the menu page the exact width
    // and height of the uploaded asset. Function is turned on in the theme
    // Theme > Edit > Navigation > Logo as home button
    getDefaultLogoSize: function() {
      var defer = $.Deferred();

      var bgImg = $('.navigation-inner').css('background-image');

      if (bgImg === 'none') {
        return defer.promise();
      }

      var bgImgUrl = bgImg.replace(/(url\(|\)|'|")/gi, "");

      var tmpImg = document.createElement('img');
      tmpImg.src = bgImgUrl;

      $(tmpImg).one('load', function() {
        defer.resolve(tmpImg);
      });

      return defer.promise();
    },

    // Notes as per getDefaultLogoSize() above
    resizeLogoHomeLink: function(tmpImg) {
      // Get the width and height of the nav-inner img as set in the CSS
      var bgSize = $('.navigation-inner').css('background-size');

      // If this is empty, no further work required
      if (!bgSize || !bgSize.split(' ')[1]) {
        return;
      }

      // Get the height of the nav-inner img - parse and trim to use in calcs
      // Image will be shrunk to the height of the nav-inner - check what that percentage is
      // Then use that percentage to reduce the width by the same ratio
      var bgSizeHeight = parseInt(bgSize.split(' ')[1].replace('px', ''));
      var percentageValue = (bgSizeHeight / tmpImg.height);
      var calculatedImgWidth = (tmpImg.width * percentageValue) + 20;

      // Append 'px' for the CSS and round the calc return
      calculatedImgWidth = Math.round(calculatedImgWidth) + 'px';

      // Apply the new width value to the button CSS
      $('.navigation-logo-home-button').css('width', calculatedImgWidth);
    },

    // If the course is launched in an iframe or frameset
    // hide the exit course button
    toggleExitButtonVisibility: function() {
      if (window.top !== window && !window.opener) {
        $('.navigation-exit-button').addClass('display-none');
      }
    },

    // Add buttons into the nav bar
    addNavigationBtns: function() {
      if ($('.navigation-home-button').length > 0) {
        return;
      }

      if (!Adapt.course) {
        return;
      }

      // Append extra icons to the navigation for theme
      var ariaLabels = Adapt.course.get('_globals')._accessibility._ariaLabels;
      // Build up additional icons for theme
      var logoHomeBtn = this.createBtn('navigation-logo-home-button', 'homeButton', ariaLabels.menuBack);
      var homeIconBtn = this.createBtn('navigation-home-button icon icon-home', 'homeButton', ariaLabels.menuBack);

      // courseExitConfirmation extension is enabled,
      // so remove the exit button used in the themes
      if ($('.navigation-course-exit-button').length === 0) {
        var exitIconBtn = this.createBtn('navigation-exit-button icon', 'exitButton', ariaLabels.exit);
        $('.navigation-inner').append(exitIconBtn);
      }

      // Prepend 2 btns and append exit btn to navigation
      $('.navigation-inner').prepend(logoHomeBtn).prepend(homeIconBtn);
    },

    // Used in the addNavigationBtns() function above
    createBtn: function(btnClasses, dataEvent, ariaLabel) {
      return '<button class="' + btnClasses + '" data-event="' + dataEvent + '" aria-label="' + ariaLabel + '"></button>';
    }
  };
});
define('theme/5efb30230d955f585ae93641-5f05eb71a346885f34d09a92/js/salsa',[
  'core/js/adapt',
  './accessibility',
  './classes',
  './helpers',
  './navigation'
], function(Adapt, Accessibility, Classes, Helpers, Navigation) {

  Adapt.on('app:dataLoaded', function() {
    Helpers.checkExternalMediaConfig();
  });

  Helpers.patchNarrative();

  var scrollPosition = 0;
  var canScroll = true;

  Adapt.on('popup:opened', function($el) {
    // Disable scrolling
    scrollPosition = window.pageYOffset;
    canScroll = false;

    if (!$el) {
      return;
    }

    // To take the focus off links in popups when accessibility is false
    Accessibility.popupLinkAccessibility();
  });

  // Remove popup mask and re-enable scroll
  Adapt.on({
    'device:changed': Helpers.disablePopupOverlay
  });


  Adapt.on('popup:closed', function($el) {
    // Enable scrolling
    scrollPosition = 0;
    canScroll = true;

    if (!$el) {
      return;
    }
  });

  Adapt.on('navigationView:postRender', function(page) {
    Navigation.addNavigationBtns();
    Navigation.toggleExitButtonVisibility();
    Navigation.getDefaultLogoSize().done(Navigation.resizeLogoHomeLink);
  });

  Adapt.on('pageView:ready', function(page) {
    lazyLayout();
    Helpers.checkPageLevelProgress(this.course);
    Helpers.hideHomeButton();
    Helpers.removeAnimationClasses();
    Helpers.applyEdgeBackgroundFix();

    // Set Navigation Exit Button - Click to close course
    $('.navigation-exit-button').click(function() {
      window.top.close();
    });
  });

  // Add classes after any hidden components are added
  // e.g. assessmentComponent can be hidden initially
  Adapt.on('componentView:postRender', function(componentView) {
    lazyLayout();
    Classes.addComponentButtonClasses(componentView);
  });

  Adapt.on('menuView:ready', function(page) {
    Helpers.checkPageLevelProgress(this.course);
    Helpers.setCourseSubtitle(this.course.get('displayTitle'));
    Helpers.removeAnimationClasses();

    // Adding the theme name as a class to the HTML
    $('html').addClass('salsatheme');

    // Navigation Exit Button
    $('.navigation-exit-button').click(function() {
      window.top.close();
    });
  });

  // Limit amount of calls based on
  // time of the previous call
  var lazyLayout = _.debounce(function() {
    Classes.addTemplateClasses();
    Classes.addClasses();
  }, 150);

  // Update classes on device change
  Adapt.on('device:resize', lazyLayout);

  _.defer(function() {
    $(window).on('scroll touchstart', function() {
      // Disable scrolling
      if (!canScroll) {
        window.scroll(0, scrollPosition);
      }
    });
  });
});

;
define("plugins", ["components/adapt-contrib-gmcq/js/adapt-contrib-gmcq","components/adapt-contrib-hiddenHotspots/js/adapt-contrib-hiddenHotspots","components/adapt-contrib-mcq/js/adapt-contrib-mcq","components/adapt-contrib-narrative/js/adapt-contrib-narrative","components/adapt-contrib-openTextInput/js/adapt-contrib-openTextInput","components/adapt-contrib-text/js/adapt-contrib-text","extensions/adapt-contrib-assistedLearning/js/adapt-contrib-assistedLearning","extensions/adapt-contrib-ios-frameset/js/adapt-contrib-ios-frameset","extensions/adapt-contrib-languagePicker/js/adapt-languagePicker","extensions/adapt-contrib-trickle/js/adapt-contrib-trickle","extensions/adapt-contrib-tutor/js/adapt-contrib-tutor","extensions/adapt-contrib-xapi/js/index","menu/5efb30230d955f585ae93641-5f05eb71a346885f34d09a92/js/adapt-menu-boxmenu","theme/5efb30230d955f585ae93641-5f05eb71a346885f34d09a92/js/salsa"], function(){});

require([
    'core/js/adapt',
    'core/js/adaptCollection',
    'core/js/startController',
    'core/js/models/buildModel',
    'core/js/models/articleModel',
    'core/js/models/blockModel',
    'core/js/models/configModel',
    'core/js/models/contentObjectModel',
    'core/js/models/componentModel',
    'core/js/models/courseModel',
    'core/js/models/questionModel',
    'core/js/views/navigationView',
    'core/js/accessibility',
    'core/js/offlineStorage',
    'core/js/logging',
    'core/js/tracking',
    'core/js/device',
    'core/js/drawer',
    'core/js/notify',
    'core/js/popupManager',
    'core/js/router',
    'core/js/models/lockingModel',
    'core/js/helpers',
    'plugins'
], function (Adapt, AdaptCollection, StartController, BuildModel, ArticleModel, BlockModel, ConfigModel, ContentObjectModel, ComponentModel, CourseModel, QuestionModel, NavigationView) {

    // Append loading template and show
    window.Handlebars = _.extend(require("handlebars"), window.Handlebars);

    var template = Handlebars.templates['loading'];
    $('#wrapper').append(template());

    Adapt.build = new BuildModel(null, {url: "adapt/js/build.min.js", reset:true});

    // This function is called anytime a course object is loaded
    // Once all course files are loaded trigger events and call Adapt.initialize
    Adapt.checkDataIsLoaded = function(newLanguage) {
        if (Adapt.contentObjects.models.length > 0 &&
            Adapt.articles.models.length > 0 &&
            Adapt.blocks.models.length > 0 &&
            Adapt.components.models.length > 0 &&
            Adapt.course.get('_id')) { 

            mapAdaptIdsToObjects();

            Adapt.log.debug('Firing app:dataLoaded');

            try {
                Adapt.trigger('app:dataLoaded');// Triggered to setup model connections in AdaptModel.js
            } catch(e) {
                Adapt.log.error('Error during app:dataLoading trigger', e);
            }

            Adapt.setupMapping();

            Adapt.wait.queue(function() {
                triggerDataReady(newLanguage);
            });

        }
    };

    function triggerDataReady(newLanguage) {
        if (newLanguage) {

            Adapt.trigger('app:languageChanged', newLanguage);

            _.defer(function() {
                var startController = new StartController();
                var hash = '#/';

                if (startController.isEnabled()) {
                    hash = startController.getStartHash(true);
                }

                Backbone.history.navigate(hash, { trigger: true, replace: true });
            });
        }

        Adapt.log.debug('Firing app:dataReady');

        try {
            Adapt.trigger('app:dataReady');
        } catch(e) {
            Adapt.log.error('Error during app:dataReady trigger', e);
        }

        Adapt.wait.queue(triggerInitialize);

    }

    function triggerInitialize() {
        Adapt.log.debug('Calling Adapt.initialize');

        addNavigationBar();

        Adapt.initialize();

        Adapt.off('adaptCollection:dataLoaded courseModel:dataLoaded');
    }

    function addNavigationBar() {

        var adaptConfig = Adapt.course.get("_navigation");

        if (adaptConfig && adaptConfig._isDefaultNavigationDisabled) {
            Adapt.trigger("navigation:initialize");
            return;
        }

        Adapt.navigation = new NavigationView();// This should be triggered after 'app:dataReady' as plugins might want to manipulate the navigation

    }

    function mapAdaptIdsToObjects () {
        Adapt.contentObjects._byAdaptID = Adapt.contentObjects.groupBy("_id");
        Adapt.articles._byAdaptID = Adapt.articles.groupBy("_id");
        Adapt.blocks._byAdaptID = Adapt.blocks.groupBy("_id");
        Adapt.components._byAdaptID = Adapt.components.groupBy("_id");
    }

    // This function is called when the config model triggers 'configModel:loadCourseData'
    // Once the config model is loaded get the course files
    // This enables plugins to tap in before the course files are loaded & also to change the default language
    Adapt.loadCourseData = function(newLanguage) {
        Adapt.on('adaptCollection:dataLoaded courseModel:dataLoaded', function() {
            Adapt.checkDataIsLoaded(newLanguage);
        });

        // All code that needs to run before adapt starts should go here
        var language = Adapt.config.get('_activeLanguage');
        var jsonext = Adapt.build.get("jsonext");
        var courseFolder = "course/" + language +"/";

        $('html').attr("lang", language);

        Adapt.course = new CourseModel(null, {url:courseFolder + "course."+jsonext, reset:true});

        Adapt.contentObjects = new AdaptCollection(null, {
            model: ContentObjectModel,
            url: courseFolder +"contentObjects."+jsonext
        });

        Adapt.articles = new AdaptCollection(null, {
            model: ArticleModel,
            url: courseFolder + "articles."+jsonext
        });

        Adapt.blocks = new AdaptCollection(null, {
            model: BlockModel,
            url: courseFolder + "blocks."+jsonext
        });

        Adapt.components = new AdaptCollection(null, {
            model: function(json) {

                //use view+model object
                var ViewModelObject = Adapt.componentStore[json._component];

                if(!ViewModelObject) {
                    throw new Error('One or more components of type "'+json._component+'" were included in the course - but no component of that type is installed...');
                }

                //if model defined for component use component model
                if (ViewModelObject.model) {
                    return new ViewModelObject.model(json);
                }

                var View = ViewModelObject.view || ViewModelObject;
                //if question type use question model
                if (View._isQuestionType) {
                    return new QuestionModel(json);
                }

                //otherwise use component model
                return new ComponentModel(json);
            },
            url: courseFolder + "components."+jsonext
        });
    };

    function onLanguageChange(model, language) {
        Adapt.offlineStorage.set('lang', language);
        Adapt.loadCourseData(language);
    }

    function onDirectionChange(model, direction) {
        if (direction === 'rtl') {
            $('html').removeClass('dir-ltr').addClass('dir-rtl').attr('dir', 'rtl');
        } else {
            $('html').removeClass('dir-rtl').addClass('dir-ltr').attr('dir', 'ltr');
        }
    }

    /**
    * Before we actually go to load the course data, we first need to check to see if a language has been set
    * If it has we can go ahead and start loading; if it hasn't, apply the defaultLanguage from config.json
    */
    function onLoadCourseData() {
        if (Adapt.config.get('_activeLanguage')) {
            Adapt.loadCourseData();
        } else {
            Adapt.config.set('_activeLanguage', Adapt.config.get('_defaultLanguage'));
        }
    }

    function onBuildDataLoaded() {
        $('html').attr("data-adapt-framework-version", Adapt.build.get('package').version);  
        Adapt.config = new ConfigModel(null, {url: "course/config."+Adapt.build.get("jsonext"), reset:true});
        Adapt.config.on({
            'change:_activeLanguage': onLanguageChange,
            'change:_defaultDirection': onDirectionChange
        });

        // Events that are triggered by the main Adapt content collections and models
        Adapt.once('configModel:loadCourseData', onLoadCourseData);

    }

    Adapt.once('buildModel:dataLoaded', onBuildDataLoaded);

});

define("core/js/app", function(){});

